#!/usr/local/bin/tclsh
# This is a tclshar created Mon Dec 28 19:18:51 MST 1998.
# Source this file into tclsh to extract the directories and files
# from this archive.
# Files included in this archive:
#  subtile subtile/Makefile subtile/README subtile/ToDo subtile/_fourier.c
#  subtile/fourier subtile/lib subtile/lib/about.tcl subtile/lib/assign.tcl
#  subtile/lib/bound-tiles.tcl subtile/lib/canvasview.tcl
#  subtile/lib/dimension-tiles.tcl subtile/lib/get-boolean.tcl
#  subtile/lib/list.tcl subtile/lib/new-window-name.tcl
#  subtile/lib/orient-tiles.tcl subtile/lib/recenter-tiles.tcl
#  subtile/lib/rescale-tiles.tcl subtile/lib/scale.tcl subtile/lib/scroll.tcl
#  subtile/lib/tclIndex subtile/lib/textview.tcl subtile/lib/vector.tcl
#  subtile/lib/vertex-atlas.tcl subtile/lib/text-files.tcl subtile/subtile
#  subtile/tiling subtile/tiling/ammann.tcl subtile/tiling/binary.tcl
#  subtile/tiling/chair.tcl subtile/tiling/danzer.tcl subtile/tiling/penrose.tcl
#  subtile/tiling/pinwheel.tcl subtile/tiling/sphinx.tcl
#  subtile/tiling/xdanzer.tcl
#
set restore [file join subtile]
puts "creating directory $restore"
if {[catch {file mkdir $restore} error]} { puts "failed to create directory $restore" } 
set restore [file join subtile Makefile]
puts "restoring file $restore"
if {[catch {open $restore w} fp]} { puts "failed to create file $restore" } 
puts $fp VERSION=0.2
puts $fp {all: _fourier}
puts $fp {	cd lib; echo  'auto_mkindex . *.tcl' | tclsh}
puts $fp {}
puts $fp {_fourier: _fourier.c}
puts $fp {	$(CC) -O -o _fourier _fourier.c -lm}
puts $fp {}
puts $fp clean:
puts $fp {	rm -f _fourier *~ tiling.ps */*~ */\#* */core}
puts $fp {}
puts $fp {shar: clean}
puts $fp {	cd ..;	shar subtile subtile/* subtile/*/* > /tmp/subtile-$(VERSION).shar}
puts $fp {}
close $fp
set restore [file join subtile README]
puts "restoring file $restore"
if {[catch {open $restore w} fp]} { puts "failed to create file $restore" } 
puts $fp ------------------------------------------------------------------------
puts $fp {subtile - a program for generating and drawing aperiodic tilings which}
puts $fp {are generated by substitution, or composition, rules and examining the}
puts $fp {fourier transforms of their vertex sets.}
puts $fp {}
puts $fp {Copyright 1995 by Roger Evans Critchlow Jr, San Francisco, California.}
puts $fp {Copyright 1998 by Roger Evans Critchlow Jr, Santa Fe, New Mexico, USA.}
puts $fp {All rights reserved, fair use permitted, no warranty.}
puts $fp {}
puts $fp {rec@elf.org, December 4, 1998}
puts $fp {}
puts $fp ------------------------------------------------------------------------
puts $fp {}
puts $fp {This program was inspired by Marjorie Senechal (Quasicrystals and}
puts $fp {Geometry, Cambridge UP, Cambridge, 1995), with contributing}
puts $fp {inspirations from Branko Gruenbaum and G. C. Shephard (Tilings and}
puts $fp {Patterns, WH Freeman, New York, 1987).}
puts $fp {}
puts $fp {These programs were developed with the aid of materials which Marjorie}
puts $fp {Senechal made available at ftp://minkowski.smith.edu, namely}
puts $fp {Mathematica programs for computing some tilings and a C program,}
puts $fp {written by Stuart Levy, for computing the fourier transform of a set}
puts $fp {of points in the plane.}
puts $fp {}
puts $fp {This version, subtile-0.3, differs from the previous version in that}
puts $fp {it has been upgraded to run with the latest version of tcl/tk, 8.0.3,}
puts $fp {the file name manipulations have been modified so they will work on}
puts $fp {windows or the macintosh as well as unix, and in using a tcl archive}
puts $fp {for distribution which will extract the files on windows or the mac as }
puts $fp {well as unix.}
puts $fp {}
puts $fp ------------------------------------------------------------------------
puts $fp {    }
puts $fp {There are three programs in this package:}
puts $fp {}
puts $fp {subtile - a program written in the Tcl language using the Tk GUI}
puts $fp {    toolkit to compute and display substitution tilings.  subtile}
puts $fp {    consists of the main source file, subtile, several library sources}
puts $fp {    in the directory ./lib, and tiling implementation files in the}
puts $fp {    directory ./tiling.}
puts $fp {}
puts $fp {fourier - a program written in the Tcl language using the Tk GUI}
puts $fp {    toolkit to compute and display fourier transforms of point sets in}
puts $fp {    the plane.  fourier consists solely of its main source file,}
puts $fp {    fourier.  If possible, it compiles and uses the C program}
puts $fp {    _fourier.c to actually compute the fourier transform.}
puts $fp {}
puts $fp {_fourier.c - a program written in C to compute fourier transforms of}
puts $fp {    points in the plane.  It is based on Stuart Levy's program with}
puts $fp {    the computation somewhat rearranged.}
puts $fp {}
puts $fp {------------------------------------------------------------------------    }
puts $fp {}
puts $fp {Acquisition and installation.}
puts $fp {}
puts $fp {The sources are available from:}
puts $fp {}
puts $fp {	http://www.elf.org/pub/subtile-0.3.tcl }
puts $fp {}
puts $fp {They require the Tcl-8.0.3/Tk-8.0.3 distribution, specifically the}
puts $fp {wish8.0 interpreter and its associated libraries.  This may be obtained}
puts $fp from:
puts $fp {	http://www.scriptics.com}
puts $fp {}
puts $fp {On unix the first lines of subtile and fourier may need to be modified}
puts $fp {if your wish8.0 isn't found in the default location, namely}
puts $fp {/usr/local/bin/wish8.0.  If your copy of wish8.0 is found in}
puts $fp {/usr/bin/wish8.0, then you would change the first lines of subtile and}
puts $fp {fourier to read:}
puts $fp {}
puts $fp #!/usr/bin/wish8.0
puts $fp {}
puts $fp {The supplied Makefile will compile _fourier.c, if possible and it}
puts $fp {should be possible on any unix machine that hosts a C compiler.}
puts $fp {}
puts $fp ------------------------------------------------------------------------
puts $fp {}
puts $fp {Using the programs.}
puts $fp {}
puts $fp {subtile uses the Tk GUI toolkit to present a graphical user interface.}
puts $fp {You can probably use it without these instructions, just type subtile}
puts $fp {to get it going.}
puts $fp {}
puts $fp {subtile presents a simple menu and a catalog of initial tilings.  The}
puts $fp {menu allows you to display this documentation or quit.  Click with the}
puts $fp {left mouse button on an initial tiling to select it.}
puts $fp {}
puts $fp {A subtile window will be drawn with the selected tiling and a menu of}
puts $fp {operations.  The operations menu may be modified as operations are}
puts $fp performed.
puts $fp {}
puts $fp {The operations menu always provides entries for:}
puts $fp {}
puts $fp {	resetting the current tiling to its initial subdivision.}
puts $fp {	subdividing the current tiling.}
puts $fp {	computing the vertex atlas of the currently displayed}
puts $fp {		tiling (sometimes).}
puts $fp {	computing the fourier transform of the current tiling.}
puts $fp {	saving a postscript drawing of the current tiling.}
puts $fp {    	enabling tile by tile display rather than waiting for all}
puts $fp {		tiles to be drawn.}
puts $fp {	enabling overlay of successive drawings. }
puts $fp {}
puts $fp {The operations menu will also present tiling specific operations.}
puts $fp {}
puts $fp {Specifically, the Penrose tilings implement operations for}
puts $fp {interconversions among:}
puts $fp {}
puts $fp {	kite and dart tiling}
puts $fp {	A triangulation}
puts $fp {	B triangulation}
puts $fp {	rhombic tiling}
puts $fp {}
puts $fp {And if you want the subdivide a Penrose tiling, you should convert}
puts $fp {to the A or B triangulation first, subdivide, and then anneal back}
puts $fp {to the original tiling.}
puts $fp {}
puts $fp {The subtile window may be resized under window manager control.}
puts $fp {}
puts $fp {The subtile window may be scrolled using the scrollbars which are}
puts $fp {adjacent to it, or by pressing the middle mouse button inside the}
puts $fp {canvas and dragging the canvas in the desired direction.}
puts $fp {}
puts $fp {The tiling may be scaled in size by pressing the right mouse button}
puts $fp {and dragging toward or away from the upper left corner of the window.}
puts $fp {}
puts $fp {Scrolling and scaling may be done while a tiling is being constructed}
puts $fp {if tile by tile display is enabled.}
puts $fp {}
puts $fp {The tiles in a displayed tiling may be deleted by clicking on them}
puts $fp {with the left mouse button.  Deleted tiles may be undeleted by clicking}
puts $fp {on them with the left mouse button, too, if you remember or can guess}
puts $fp {where they are.}
puts $fp {}
puts $fp {The fourier program presents menues for:}
puts $fp {}
puts $fp {	operations to be performed}
puts $fp {	size of image to be computed}
puts $fp {	srange, or the range of fourier space to be computed}
puts $fp {	brightness of the image displayed}
puts $fp {}
puts $fp {The transform is computed without any brightness scaling so the}
puts $fp {brightness may be adjusted after the transform computation is begun.}
puts $fp {}
puts $fp {A good strategy is to use small image sizes, eg 64, until you've found}
puts $fp {the appropriate srange, because the transform requires size^2}
puts $fp {computations to complete.}
puts $fp {}
puts $fp ------------------------------------------------------------------------
puts $fp {}
puts $fp {To do list for subtile:}
puts $fp {}
puts $fp {   4) make dissections go in adjacent pieces rather than skipping around}
puts $fp {   8) color the tiles}
puts $fp {   10) clip a tiling to a disk or polygon}
puts $fp {   14) graphically edit prototiles and dissection rules}
puts $fp {   16) generate vertex atlases}
puts $fp {   17) generate tile names from vertex atlases}
puts $fp {   18) color tiles according to names}
puts $fp {   19) save and restore tilings as tcl}
puts $fp {   20) reproduce edge markings}
puts $fp {}
puts $fp {To do list for fourier:}
puts $fp {}
puts $fp {   1) allow the computation to be aborted}
puts $fp {   2) save images to ppm files}
puts $fp {   3) reload saved images}
puts $fp {   4) compute layers to improve the resolution of an existing image}
puts $fp {}
puts $fp ------------------------------------------------------------------------
puts $fp {}
puts $fp {-- rec@elf.org --}
puts $fp {December 4, 1998}
puts $fp {}
puts $fp {}
close $fp
set restore [file join subtile ToDo]
puts "restoring file $restore"
if {[catch {open $restore w} fp]} { puts "failed to create file $restore" } 
puts $fp {2) Allow sweeping deletions}
puts $fp {4) Generate vertex atlases}
puts $fp {}
close $fp
set restore [file join subtile _fourier.c]
puts "restoring file $restore"
if {[catch {open $restore w} fp]} { puts "failed to create file $restore" } 
puts $fp {#include <stdio.h>}
puts $fp {#include <stdlib.h>}
puts $fp {#include <math.h>		/* Declares sin(), cos(), etc. */}
puts $fp {}
puts $fp /*
puts $fp { * To compile:}
puts $fp { *	cc -o _fourier  _fourier.c -lm}
puts $fp { */}
puts $fp {}
puts $fp struct\ point\ \{
puts $fp {    double x, y;}
puts $fp \}\;
puts $fp {}
puts $fp {void fatal(char *msg)}
puts $fp \{
puts $fp {  fprintf(stderr, "_fourier: %s\n", msg);}
puts $fp {  exit(1);}
puts $fp \}
puts $fp {}
puts $fp {main(int argc, char *argv[])}
puts $fp \{
puts $fp {  int n;							/* width and height of image */}
puts $fp {  double srange;						/* width/2 and height/2 of fourier space */}
puts $fp {  double scale;							/* scaling applied to magnitude */}
puts $fp {  int w, i, j, k;}
puts $fp {  struct point s;}
puts $fp {  struct point *source;}
puts $fp {  double re, im, *coeff;}
puts $fp {  int nsource;}
puts $fp {  double dot, mag;}
puts $fp {  int imag;}
puts $fp {}
puts $fp {  /*}
puts $fp {   * Read parameters.}
puts $fp {   */}
puts $fp {  if (argc != 1)}
puts $fp {    fatal("wrong number of arguments");}
puts $fp {  if (3 != scanf("%d %lf %d\n", &n, &srange, &nsource))}
puts $fp {    fatal("incomplete parameter line");}
puts $fp {  if (n <= 0)}
puts $fp {    fatal("size of image must be greater than 0");}
puts $fp {  if (srange <= 0)}
puts $fp {    fatal("range of fourier space must be greater than 0");}
puts $fp {}
puts $fp {  /*}
puts $fp {   * Allocate and read light sources.}
puts $fp {   */}
puts $fp {  source = (struct point *)malloc(nsource * sizeof(struct point));}
puts $fp {  for (i = 0; i < nsource; i += 1)}
puts $fp {    if (2 != scanf("%lf %lf\n", &source[i].x, &source[i].y))}
puts $fp {      fatal("bad point line");}
puts $fp {}
puts $fp {  /*}
puts $fp {   * Pre compute coefficients}
puts $fp {   */}
puts $fp {  coeff = calloc(n, sizeof(double));}
puts $fp {  for (i = 0; i < n; i += 1)}
puts $fp {    coeff[i] = 2 * M_PI * srange * ((float)i/(n-1) - .5);}
puts $fp {}
puts $fp {  scale = nsource > 0 ? 1.0 / nsource : 1;}
puts $fp {}
puts $fp {  /*}
puts $fp {   * Compute transform by blocks, starting from a block that sets the}
puts $fp {   * entire image to the value of the 0,0 pixel, then computing the}
puts $fp {   * other three quadrants of the image, and continuing by computing}
puts $fp {   * subquadrants until the individual pixels are done.}
puts $fp {   */}
puts $fp \ \ for\ (w\ =\ n\;\ w\ >=\ 1\;\ w\ /=\ 2)\ \{
puts $fp {    int wt2 = 2*w;}
puts $fp \ \ \ \ for\ (i\ =\ 0\;\ i\ <\ n\;\ i\ +=\ w)\ \{
puts $fp {      s.y = coeff[i];}
puts $fp \ \ \ \ \ \ for\ (j\ =\ 0\;\ j\ <\ n\;\ j\ +=\ w)\ \{
puts $fp \tif\ ((i%wt2)\ !=\ 0\ ||\ (j%wt2)\ !=\ 0\ ||\ w\ ==\ n)\ \{
puts $fp {	  s.x = coeff[j];}
puts $fp {	  re = im = 0;}
puts $fp \t\ \ for(k\ =\ 0\;\ k\ <\ nsource\;\ k++)\ \{
puts $fp {	    dot = s.x*source[k].x + s.y*source[k].y;}
puts $fp {	    re += cos(dot);}
puts $fp {	    im += sin(dot);}
puts $fp \t\ \ \}
puts $fp {	  mag = scale * sqrt(re*re + im*im);}
puts $fp {	  /*}
puts $fp {	   * Report the current estimate for the magnitude in the rectangle}
puts $fp {	   * from j i to j+w i+w, namely the magnitude at j i.}
puts $fp {	   */}
puts $fp {	  printf("%f %d %d %d %d\n", mag, j, i, j+w, i+w);}
puts $fp {	  fflush(stdout);}
puts $fp \t\}
puts $fp \ \ \ \ \ \ \}
puts $fp \ \ \ \ \}
puts $fp \ \ \}
puts $fp {  exit(0);}
puts $fp \}
puts $fp {}
puts $fp {}
close $fp
set restore [file join subtile fourier]
puts "restoring file $restore"
if {[catch {open $restore w} fp]} { puts "failed to create file $restore" } 
puts $fp #!/usr/local/bin/wish8.0
puts $fp {}
puts $fp #
puts $fp {# a program to compute and display fourier transforms of a point set}
puts $fp {# in two dimensions.}
puts $fp #
puts $fp {}
puts $fp #
puts $fp {# input data}
puts $fp #
puts $fp {set fourier(points) [split [read stdin] \n];}
puts $fp {set fourier(npoints) [llength $fourier(points)]}
puts $fp {}
puts $fp #
puts $fp {# parameters for the user interface}
puts $fp #
puts $fp {set fourier(size) 256;}
puts $fp {set fourier(size-menu) {16 32 64 128 256 512 1024};}
puts $fp {set fourier(srange) 50;}
puts $fp {set fourier(srange-menu) {200 150 100 90 80 70 60 50 40 30 20 10}}
puts $fp {set fourier(brightness) 2;}
puts $fp {set fourier(brightness-menu) {1 1.5 2 3 4 5 10 20 40 80 100 120}}
puts $fp {}
puts $fp #
puts $fp {# computed variables}
puts $fp #
puts $fp {set fourier(scale) [expr $fourier(brightness)*256.0];}
puts $fp {set fourier(percent) 0;}
puts $fp {set fourier(image) {};}
puts $fp {}
puts $fp #
puts $fp {# menubutton frame}
puts $fp #
puts $fp {pack [frame .m -border 2 -relief raised] -fill x;}
puts $fp {}
puts $fp #
puts $fp {# operations menu}
puts $fp #
puts $fp {pack [menubutton .m.o -text Operations -menu .m.o.m] -side left;}
puts $fp {menu .m.o.m -tearoff no;}
puts $fp {.m.o.m add command -label Fourier -command fourier}
puts $fp {.m.o.m add separator}
puts $fp {.m.o.m add command -label Quit -command {destroy .}}
puts $fp {}
puts $fp #
puts $fp {# parameter menu}
puts $fp #
puts $fp {pack [menubutton .m.p -text Parameters -menu .m.p.m] -side left}
puts $fp {menu .m.p.m -tearoff no;}
puts $fp {.m.p.m add cascade -label Size -menu .m.p.m.n;}
puts $fp {.m.p.m add cascade -label Srange -menu .m.p.m.s;}
puts $fp {.m.p.m add cascade -label Brightness -menu .m.p.m.b;}
puts $fp {}
puts $fp #
puts $fp {# image size submenu}
puts $fp #
puts $fp {menu .m.p.m.n -tearoff no;}
puts $fp foreach\ v\ \$fourier(size-menu)\ \{
puts $fp {    .m.p.m.n add radiobutton -label $v -value $v -variable fourier(size) -command {.c configure -width $fourier(size) -height $fourier(size)};}
puts $fp \}
puts $fp {}
puts $fp #
puts $fp {# fourier space range submenu}
puts $fp #
puts $fp {menu .m.p.m.s -tearoff no;}
puts $fp foreach\ v\ \$fourier(srange-menu)\ \{
puts $fp {    .m.p.m.s add radiobutton -label $v -value $v -variable fourier(srange);}
puts $fp \}
puts $fp {}
puts $fp #
puts $fp {# brightness menu}
puts $fp #
puts $fp {menu .m.p.m.b -tearoff no;}
puts $fp foreach\ v\ \$fourier(brightness-menu)\ \{
puts $fp {    .m.p.m.b add radiobutton -label $v -value $v -variable fourier(brightness) -command set-brightness;}
puts $fp \}
puts $fp {}
puts $fp #
puts $fp {# number of vertices in data set}
puts $fp #
puts $fp {pack [label .m.n -text "$fourier(npoints) points"] -side left;}
puts $fp {}
puts $fp #
puts $fp {# canvas for displaying results}
puts $fp #
puts $fp {pack [canvas .c -width $fourier(size) -height $fourier(size)] -fill both -expand true;}
puts $fp {pack [scale .s -orient horizontal -from 0 -to 1000 -label {} -showvalue false -variable fourier(percent) -state disabled] -side top -fill x;}
puts $fp {}
puts $fp #
puts $fp {# compute the fourier transform}
puts $fp #
puts $fp proc\ fourier\ \{\}\ \{
puts $fp {    global fourier;}
puts $fp {    .c delete all;}
puts $fp {    set fourier(image) {};}
puts $fp {    set fourier(picture) [image create photo -height $fourier(size) -width $fourier(size)];}
puts $fp {    .c create image 0 0 -anchor nw -image $fourier(picture);}
puts $fp {    transform $fourier(picture) $fourier(size) $fourier(srange) $fourier(npoints) $fourier(points);}
puts $fp \}
puts $fp {}
puts $fp #
puts $fp {# decide whether the _fourier.c program can be used}
puts $fp #
puts $fp proc\ transform\ \{image\ n\ srange\ npoints\ points\}\ \{
puts $fp \ \ \ \ if\ \{\[file\ exists\ _fourier\]
puts $fp \ \ \ \ \ ||\ (\[file\ exists\ _fourier.c\]\ &&\ \[catch\ \{exec\ cc\ -o\ _fourier\ _fourier.c\ -lm\}\]\ ==\ 0)\}\ \{
puts $fp {	fast-transform;}
puts $fp \ \ \ \ \}\ else\ \{
puts $fp {	slow-transform;}
puts $fp \ \ \ \ \}
puts $fp \}
puts $fp {	}
puts $fp #
puts $fp {# start the progress monitor}
puts $fp #
puts $fp proc\ init-progress\ \{n\}\ \{
puts $fp {    global fourier;}
puts $fp {    set fourier(percent) 0;}
puts $fp {    .s configure -from 0 -to [expr $n*$n];}
puts $fp \}
puts $fp {}
puts $fp #
puts $fp {# update the progress monitor}
puts $fp #
puts $fp proc\ incr-progress\ \{\}\ \{
puts $fp {    global fourier;}
puts $fp {    .s configure -state normal;}
puts $fp {    incr fourier(percent);}
puts $fp {    .s configure -state disabled;}
puts $fp \}
puts $fp {}
puts $fp #
puts $fp {# draw pixels to the output image}
puts $fp #
puts $fp proc\ image-pixels\ \{mag\ x\ y\ xn\ yn\}\ \{
puts $fp {    global fourier;}
puts $fp {    set mag [expr int($fourier(scale) * $mag)];}
puts $fp \ \ \ \ if\ \{\$mag\ >\ 255\}\ \{
puts $fp {	set mag ff;}
puts $fp \ \ \ \ \}\ else\ \{
puts $fp {	set mag [format %02x $mag];}
puts $fp \ \ \ \ \}
puts $fp {    $fourier(picture) put "{{\#$mag$mag$mag}}" -to $x $y $xn $yn;}
puts $fp \}
puts $fp {}
puts $fp #
puts $fp {# adjust the brightness}
puts $fp #
puts $fp proc\ set-brightness\ \{\}\ \{
puts $fp {    global fourier;}
puts $fp {    set fourier(scale) [expr $fourier(brightness)*256.0];}
puts $fp \ \ \ \ foreach\ region\ \$fourier(image)\ \{
puts $fp {	eval image-pixels $region;}
puts $fp {	update;}
puts $fp \ \ \ \ \}
puts $fp \}
puts $fp {}
puts $fp #
puts $fp {# add pixels to the output image}
puts $fp #
puts $fp proc\ set-pixels\ \{mag\ x\ y\ xn\ yn\}\ \{
puts $fp {    global fourier;}
puts $fp {    lappend fourier(image) [list $mag $x $y $xn $yn];}
puts $fp {    image-pixels $mag $x $y $xn $yn;}
puts $fp \}
puts $fp {}
puts $fp #
puts $fp {# compute the fourier transform in tcl, slowly}
puts $fp #
puts $fp proc\ slow-transform\ \{\}\ \{
puts $fp {    upvar n n srange srange npoints npoints points points;}
puts $fp {    set pi [expr 4*atan(1)];}
puts $fp \ \ \ \ if\ \{\$npoints\ ==\ 0\}\ \{
puts $fp {	set scale 1;}
puts $fp \ \ \ \ \}\ else\ \{\ 
puts $fp {        set scale [expr 1.0 / $npoints];}
puts $fp \ \ \ \ \}
puts $fp \ \ \ \ for\ \{set\ i\ 0\}\ \{\$i\ <\ \$n\}\ \{incr\ i\}\ \{
puts $fp {	set c($i) [expr 2 * $pi * $srange * (double($i) / ($n-1) - .5)];}
puts $fp \ \ \ \ \}
puts $fp {    init-progress $n;}
puts $fp \ \ \ \ for\ \{set\ w\ \$n\}\ \{\$w\ >=\ 1\}\ \{set\ w\ \[expr\ \$w/2\]\}\ \{
puts $fp {	set wt2 [expr $w*2];}
puts $fp \tfor\ \{set\ i\ 0\}\ \{\$i\ <\ \$n\}\ \{incr\ i\ \$w\}\ \{
puts $fp {	    set y $c($i);}
puts $fp \t\ \ \ \ for\ \{set\ j\ 0\}\ \{\$j\ <\ \$n\}\ \{incr\ j\ \$w\}\ \{
puts $fp \t\tif\ \{(\$i%\$wt2)\ !=\ 0\ ||\ (\$j%\$wt2)\ !=\ 0\ ||\ \$w\ ==\ \$n\}\ \{
puts $fp {		    set x $c($j);}
puts $fp {		    set re 0;}
puts $fp {		    set im 0;}
puts $fp \t\t\ \ \ \ foreach\ p\ \$points\ \{
puts $fp {			set dot $x*[lindex $p 0]+$y*[lindex $p 1];}
puts $fp {			append re +cos($dot);}
puts $fp {			append im +sin($dot);}
puts $fp \t\t\ \ \ \ \}
puts $fp {		    set re [expr $re];}
puts $fp {		    set im [expr $im];}
puts $fp {		    set mag [expr $scale * sqrt($re*$re + $im*$im)];}
puts $fp {		    set-pixels $mag $j $i [expr $j+$w] [expr $i+$w];}
puts $fp {		    incr-progress;}
puts $fp {		    update;}
puts $fp \t\t\}
puts $fp \t\ \ \ \ \}
puts $fp \t\}
puts $fp \ \ \ \ \}
puts $fp \}
puts $fp {}
puts $fp #
puts $fp {# compute the fourier transform with a C program}
puts $fp #
puts $fp proc\ fast-transform\ \{\}\ \{
puts $fp {    global fourier;}
puts $fp {    upvar n n srange srange npoints npoints points points;}
puts $fp {    set input "$n $srange $npoints\n[join $points \n]";}
puts $fp {    set fp [open "|_fourier << {$input}" r];}
puts $fp {    init-progress $n;}
puts $fp {    set fourier(image) {};}
puts $fp \ \ \ \ while\ \{\[gets\ \$fp\ line\]\ >=\ 0\}\ \{
puts $fp {	eval set-pixels $line;}
puts $fp {	incr-progress;}
puts $fp {	update;}
puts $fp \ \ \ \ \}
puts $fp {    close $fp;}
puts $fp \}
puts $fp {}
puts $fp {}
close $fp
set restore [file join subtile lib]
puts "creating directory $restore"
if {[catch {file mkdir $restore} error]} { puts "failed to create directory $restore" } 
set restore [file join subtile lib about.tcl]
puts "restoring file $restore"
if {[catch {open $restore w} fp]} { puts "failed to create file $restore" } 
puts $fp proc\ about-something\ \{title\ information\}\ \{
puts $fp \ \ \ \ if\ \{\[winfo\ exists\ .about\]\}\ \{
puts $fp {	wm deiconify .about;}
puts $fp {	.about.t delete 0.0 end}
puts $fp \ \ \ \ \}\ else\ \{
puts $fp {	toplevel .about;}
puts $fp {	pack [textview .about.t -vscroll 1] -side top -fill both -expand true;}
puts $fp {	pack [button .about.q -text Done -command {destroy .about}] -side top;}
puts $fp \ \ \ \ \}
puts $fp {    wm title .about $title}
puts $fp {    .about.t insert end $information;}
puts $fp \}
puts $fp {}
puts $fp {}
close $fp
set restore [file join subtile lib assign.tcl]
puts "restoring file $restore"
if {[catch {open $restore w} fp]} { puts "failed to create file $restore" } 
puts $fp proc\ pset\ \{args\}\ \{
puts $fp {    set n [llength $args];}
puts $fp {    set vals [lindex $args [incr n -1]];}
puts $fp \ \ \ \ foreach\ name\ \[lrange\ \$args\ 0\ \[incr\ n\ -1\]\]\ \{
puts $fp {	upvar $name var;}
puts $fp {	set var [lindex $vals 0];}
puts $fp {	set vals [lrange $vals 1 end];}
puts $fp \ \ \ \ \}
puts $fp \}
puts $fp {}
close $fp
set restore [file join subtile lib bound-tiles.tcl]
puts "restoring file $restore"
if {[catch {open $restore w} fp]} { puts "failed to create file $restore" } 
puts $fp #
puts $fp {# bound a tile}
puts $fp #
puts $fp proc\ bound-tile\ \{tile\}\ \{
puts $fp {    pset xmin ymin [lindex $tile 1];}
puts $fp {    pset xmax ymax "$xmin $ymin";}
puts $fp \ \ \ \ foreach\ point\ \[lrange\ \$tile\ 2\ end\]\ \{
puts $fp {	pset x y $point;}
puts $fp \tif\ \{\$x\ <\ \$xmin\}\ \{
puts $fp {	    set xmin $x;}
puts $fp \t\}\ elseif\ \{\$x\ >\ \$xmax\}\ \{
puts $fp {	    set xmax $x;}
puts $fp \t\}
puts $fp \tif\ \{\$y\ <\ \$ymin\}\ \{
puts $fp {	    set ymin $y;}
puts $fp \t\}\ elseif\ \{\$y\ >\ \$ymax\}\ \{
puts $fp {	    set ymax $y;}
puts $fp \t\}
puts $fp \ \ \ \ \}
puts $fp {    return "$xmin $ymin $xmax $ymax";}
puts $fp \}
puts $fp {}
puts $fp #
puts $fp {# bound a tiling}
puts $fp #
puts $fp proc\ bound-tiling\ \{tiles\}\ \{
puts $fp {    pset xmin ymin xmax ymax [bound-tile [lindex $tiles 0]];}
puts $fp \ \ \ \ foreach\ tile\ \[lrange\ \$tiles\ 1\ end\]\ \{
puts $fp {	pset x0 y0 x1 y1 [bound-tile $tile];}
puts $fp \tif\ \{\$x0\ <\ \$xmin\}\ \{
puts $fp {	    set xmin $x0;}
puts $fp \t\}
puts $fp \tif\ \{\$x1\ >\ \$xmax\}\ \{
puts $fp {	    set xmax $x1;}
puts $fp \t\}
puts $fp \tif\ \{\$y0\ <\ \$ymin\}\ \{
puts $fp {	    set ymin $y0;}
puts $fp \t\}
puts $fp \tif\ \{\$y1\ >\ \$ymax\}\ \{
puts $fp {	    set ymax $y1;}
puts $fp \t\}
puts $fp \ \ \ \ \}
puts $fp {    return "$xmin $ymin $xmax $ymax";}
puts $fp \}
puts $fp {}
puts $fp #
puts $fp {# bound a tile collection}
puts $fp #
puts $fp proc\ bound-collection\ \{collection\}\ \{
puts $fp {    pset xmin ymin xmax ymax [bound-tiling [lindex [lindex $collection 0] 1]]}
puts $fp \ \ \ \ foreach\ item\ \[lrange\ \$collection\ 1\ end\]\ \{
puts $fp {	pset x0 y0 x1 y1 [bound-tiling [lindex $item 1]];}
puts $fp \tif\ \{\$x0\ <\ \$xmin\}\ \{
puts $fp {	    set xmin $x0;}
puts $fp \t\}
puts $fp \tif\ \{\$x1\ >\ \$xmax\}\ \{
puts $fp {	    set xmax $x1;}
puts $fp \t\}
puts $fp \tif\ \{\$y0\ <\ \$ymin\}\ \{
puts $fp {	    set ymin $y0;}
puts $fp \t\}
puts $fp \tif\ \{\$y1\ >\ \$ymax\}\ \{
puts $fp {	    set ymax $y1;}
puts $fp \t\}
puts $fp \ \ \ \ \}
puts $fp {    return "$xmin $ymin $xmax $ymax";}
puts $fp \}
puts $fp {}
puts $fp {}
close $fp
set restore [file join subtile lib canvasview.tcl]
puts "restoring file $restore"
if {[catch {open $restore w} fp]} { puts "failed to create file $restore" } 
puts $fp namespace\ eval\ canvasview\ \{
puts $fp {    #@}
puts $fp {    #@  procedure "canvasview"}
puts $fp {    #@------------------------------>  the canvasview widget builds a frame which}
puts $fp {    #@                                 containts a canvas, and optionally enables}
puts $fp {    #@                                 horizontal and/or vertical scroll bars.}
puts $fp {    ##}
puts $fp \ \ \ \ proc\ canvasview\ \{w\ args\}\ \{
puts $fp {	#@}
puts $fp {	#@--------------->  establish the widget local state binding.}
puts $fp {	##}
puts $fp {	upvar #0 $w data;}
puts $fp {	#@}
puts $fp {	#@--------------->  establish a Tk frame widget.}
puts $fp {	##}
puts $fp {	frame $w -class Canvasview;}
puts $fp {	rename $w $w.frame;}
puts $fp {	#@}
puts $fp {	#@--------------->  widget method dispatcher.}
puts $fp {	##}
puts $fp \tproc\ ::\$w\ \{method\ args\}\ \\
puts $fp {	    "return \[eval [namespace current]::method::\$method $w \$args\];"}
puts $fp {	#@}
puts $fp {	#@--------------->  instantiate the widget.}
puts $fp {	##}
puts $fp {	pack [canvas $w.c] -expand true -fill both}
puts $fp {	#@}
puts $fp {	#@--------------->  redirect bindings.}
puts $fp {	##}
puts $fp {	bindtags $w.c "Canvas $w [winfo toplevel $w] all"}
puts $fp {	#@}
puts $fp {	#@--------------->  default configuration}
puts $fp {	##}
puts $fp \tset\ data(options)\ \{
puts $fp {	    {-vscroll vScroll VScroll 0}}
puts $fp {	    {-hscroll hScroll HScroll 0}}
puts $fp \t\}
puts $fp \tforeach\ opt\ \$data(options)\ \{
puts $fp {	    set name [lindex $opt 0];}
puts $fp {	    set data($name) [lindex $opt 3];}
puts $fp \t\}
puts $fp {	#@}
puts $fp {	#@--------------->  apply the configuration options.}
puts $fp {	##}
puts $fp {	doconfigure;}
puts $fp {	#@}
puts $fp {	#@--------------->  return the widget name.}
puts $fp {	##}
puts $fp {	return $w;}
puts $fp \ \ \ \ \}
puts $fp \ \ \ \ namespace\ eval\ method\ \{
puts $fp {	#@}
puts $fp {	#@==============================================================================}
puts $fp {	#@}
puts $fp {	#@  procedure "canvasview::method::cget"}
puts $fp {	#@------------------------------>  widget methods}
puts $fp {	##}
puts $fp \tproc\ cget\ \{w\ args\}\ \{
puts $fp \t\ \ \ \ if\ \{\[llength\ \$args\]\ !=\ 1\}\ \{
puts $fp {		error "usage: pathName cget option";}
puts $fp \t\ \ \ \ \}\ else\ \{
puts $fp {		return [lindex [$w configure $args] 4];}
puts $fp \t\ \ \ \ \}
puts $fp \t\}
puts $fp {	#@}
puts $fp {	#@==============================================================================}
puts $fp {	#@}
puts $fp {	#@  procedure "canvasview::method::configure"}
puts $fp {	#@------------------------------>  widget methods}
puts $fp {	##}
puts $fp \tproc\ configure\ \{w\ args\}\ \{
puts $fp {	    upvar #0 $w data;}
puts $fp \t\ \ \ \ if\ \{\[llength\ \$args\]\ ==\ 0\}\ \{
puts $fp {		set options {};}
puts $fp \t\tforeach\ opt\ \$data(options)\ \{
puts $fp {		    set name [lindex $opt 0];}
puts $fp \t\t\ \ \ \ if\ \{\[llength\ \$opt\]\ ==\ 4\}\ \{
puts $fp {			lappend opt $data($name);}
puts $fp \t\t\ \ \ \ \}
puts $fp {		    lappend options $opt;}
puts $fp \t\t\}
puts $fp {		return [concat $options [$w.c configure]];}
puts $fp \t\ \ \ \ \}
puts $fp \t\ \ \ \ if\ \{\[llength\ \$args\]\ ==\ 1\}\ \{
puts $fp \t\tforeach\ opt\ \$data(options)\ \{
puts $fp {		    set name [lindex $opt 0];}
puts $fp \t\t\ \ \ \ if\ \{\"\$name\"\ ==\ \"\$args\"\}\ \{
puts $fp \t\t\tif\ \{\[llength\ \$opt\]\ ==\ 4\}\ \{
puts $fp {			    lappend opt $data($name);}
puts $fp {			    return $opt;}
puts $fp \t\t\t\}\ else\ \{
puts $fp {			    return [$w configure -[lindex $opt 2]];}
puts $fp \t\t\t\}
puts $fp \t\t\ \ \ \ \}
puts $fp \t\t\}
puts $fp {		return [$w.c configure $args];}
puts $fp \t\ \ \ \ \}
puts $fp {	    return [[namespace parent]::doconfigure];}
puts $fp \t\}
puts $fp {	#@}
puts $fp {	#@==============================================================================}
puts $fp {	#@}
puts $fp {	#@--------------->  methods from canvasview exclude cget and configure}
puts $fp {	##}
puts $fp \tforeach\ method\ \{addtag\ bbox\ bind\ canvasx\ canvasy\ coords\ create\ dchars\ \\
puts $fp \t\t\t\ \ \ \ delete\ dtag\ find\ focus\ gettags\ icursor\ index\ insert\ \\
puts $fp \t\t\t\ \ \ \ itemcget\ itemconfigure\ lower\ move\ postscript\ raise\ \\
puts $fp \t\t\t\ \ \ \ scale\ scan\ select\ type\ xview\ yview\}\ \\
puts $fp \t\ \ \ \ \{
puts $fp \t\ \ \ \ proc\ \$method\ \{w\ args\}\ \\
puts $fp {		"return \[eval \$w.c $method \$args]";}
puts $fp \t\}
puts $fp \ \ \ \ \}
puts $fp {    #@}
puts $fp {    #@==============================================================================}
puts $fp {    #@}
puts $fp {    #@  procedure "canvasview::doconfigure"}
puts $fp {    #@------------------------------>  internals}
puts $fp {    ##}
puts $fp \ \ \ \ proc\ doconfigure\ \{\}\ \{
puts $fp {	upvar w w;}
puts $fp {	upvar args args;}
puts $fp {	upvar data data;}
puts $fp {	set cargs {};}
puts $fp \twhile\ \{\[llength\ \$args\]\ >=\ 2\}\ \{
puts $fp {	    set option [lindex $args 0];}
puts $fp {	    set value [lindex $args 1];}
puts $fp {	    set args [lrange $args 2 end];}
puts $fp \t\ \ \ \ switch\ -exact\ --\ \$option\ \{
puts $fp \t\t-hscroll\ \{
puts $fp {		    set data(-hscroll) [merge-boolean $value $data(-hscroll)];}
puts $fp {		    #@}
puts $fp {		    #@                  Repack canvasview}
puts $fp {		    #@--------------------------------------------->  "Lib_tk/canvasview.tcl"}
puts $fp {		    ##}
puts $fp {		    repack;}
puts $fp \t\t\}
puts $fp \t\t-vscroll\ \{
puts $fp {		    set data(-vscroll) [merge-boolean $value $data(-vscroll)];}
puts $fp {		    #@}
puts $fp {		    #@                  Repack canvasview}
puts $fp {		    #@--------------------------------------------->  "Lib_tk/canvasview.tcl"}
puts $fp {		    ##}
puts $fp {		    repack;}
puts $fp \t\t\}
puts $fp \t\tdefault\ \{
puts $fp {		    lappend cargs $option $value;}
puts $fp \t\t\}
puts $fp \t\ \ \ \ \}
puts $fp \t\}
puts $fp \tif\ \{\[llength\ \$args\]\ !=\ 0\}\ \{
puts $fp {	    error "unmatched option argument: $args";}
puts $fp \t\}
puts $fp \tif\ \{\"\$cargs\"\ !=\ \{\}\}\ \{
puts $fp {	    #@}
puts $fp {	    #@--------------->  call dispatched procedure}
puts $fp {	    ##}
puts $fp {	    return [eval $w.c configure $cargs];}
puts $fp \t\}\ else\ \{
puts $fp {	    return {};}
puts $fp \t\}
puts $fp \ \ \ \ \}
puts $fp {    #@}
puts $fp {    #@==============================================================================}
puts $fp {    #@}
puts $fp {    #@  procedure "canvasview::repack"}
puts $fp {    #@------------------------------>  redraw}
puts $fp {    ##}
puts $fp \ \ \ \ proc\ repack\ \{\}\ \{
puts $fp {	upvar w w;}
puts $fp {	upvar data data;}
puts $fp {	$w.c configure -xscrollcommand {} -yscrollcommand {};}
puts $fp {	#@}
puts $fp {	#@--------------->  Destroy widgets}
puts $fp {	##}
puts $fp {	catch {pack forget $w.c};}
puts $fp {	catch {pack forget $w.e};}
puts $fp {	catch {destroy $w.e};}
puts $fp {	catch {pack forget $w.v};}
puts $fp {	catch {destroy $w.v};}
puts $fp {	catch {pack forget $w.h};}
puts $fp {	catch {destroy $w.h};}
puts $fp {	}
puts $fp \tswitch\ \$data(-hscroll)\$data(-vscroll)\ \{
puts $fp \t\ \ \ \ 10\ \{
puts $fp \t\tpack\ \[scrollbar\ \$w.h\ -orient\ horizontal\ -command\ \"\$w.c\ xview\"\]\ \\
puts $fp {		    -side bottom -fill x;}
puts $fp {		pack $w.c -side top -fill both -expand true;}
puts $fp {		$w.c configure -xscrollcommand "$w.h set";}
puts $fp \t\ \ \ \ \}
puts $fp \t\ \ \ \ 01\ \{
puts $fp \t\tpack\ \[scrollbar\ \$w.v\ -orient\ vertical\ -command\ \"\$w.c\ yview\"\]\ \\
puts $fp {		    -side right -fill y;}
puts $fp {		pack $w.c -side left -fill both -expand true;}
puts $fp {		$w.c configure -yscrollcommand "$w.v set";}
puts $fp \t\ \ \ \ \}
puts $fp \t\ \ \ \ 11\ \{
puts $fp {		pack [frame $w.e] -side right -fill y;}
puts $fp {		pack [frame $w.e.s] -side bottom;}
puts $fp \t\tpack\ \[scrollbar\ \$w.v\ -orient\ vertical\ -command\ \"\$w.c\ yview\"\]\ \\
puts $fp {		    -in $w.e -side right -fill y;}
puts $fp \t\tpack\ \[scrollbar\ \$w.h\ -orient\ horizontal\ -command\ \"\$w.c\ xview\"\]\ \\
puts $fp {		    -side bottom -fill x;}
puts $fp {		pack $w.c -side top -fill both -expand true;}
puts $fp {		$w.c configure -xscrollcommand "$w.h set" -yscrollcommand "$w.v set";}
puts $fp {		bind $w.e.s <Configure> "$w.e.s configure -height \[winfo height $w.h]";}
puts $fp \t\ \ \ \ \}
puts $fp \t\}
puts $fp \ \ \ \ \}
puts $fp \}
puts $fp {}
puts $fp proc\ canvasview\ \{w\ args\}\ \{
puts $fp {    return [eval canvasview::canvasview $w $args]}
puts $fp \}
puts $fp {}
puts $fp #@
puts $fp #@==============================================================================
puts $fp {}
close $fp
set restore [file join subtile lib dimension-tiles.tcl]
puts "restoring file $restore"
if {[catch {open $restore w} fp]} { puts "failed to create file $restore" } 
puts $fp #
puts $fp {# dimension of a tile}
puts $fp #
puts $fp proc\ dimension-tile\ \{tile\}\ \{
puts $fp {    pset xmin ymin [lindex $tile 1];}
puts $fp {    pset xmax ymax "$xmin $ymin";}
puts $fp \ \ \ \ foreach\ point\ \[lrange\ \$tile\ 2\ end\]\ \{
puts $fp {	pset x y $point;}
puts $fp \tif\ \{\$x\ <\ \$xmin\}\ \{
puts $fp {	    set xmin $x;}
puts $fp \t\}\ elseif\ \{\$x\ >\ \$xmax\}\ \{
puts $fp {	    set xmax $x;}
puts $fp \t\}
puts $fp \tif\ \{\$y\ <\ \$ymin\}\ \{
puts $fp {	    set ymin $y;}
puts $fp \t\}\ elseif\ \{\$y\ >\ \$ymax\}\ \{
puts $fp {	    set ymax $y;}
puts $fp \t\}
puts $fp \ \ \ \ \}
puts $fp {    return [list [expr $xmax-$xmin] [expr $ymax-$ymin]];}
puts $fp \}
puts $fp {}
puts $fp #
puts $fp {# dimension a tiling}
puts $fp #
puts $fp proc\ dimension-tiling\ \{tiles\}\ \{
puts $fp {    pset x0 y0 x1 y1 [bound-tiling $tiles];}
puts $fp {    return [list [expr $x1-$x0] [expr $y1-$y0]];}
puts $fp \}
puts $fp {}
puts $fp #
puts $fp {# dimension a tile collection}
puts $fp #
puts $fp proc\ dimension-collection\ \{collection\}\ \{
puts $fp {    pset dx dy [dimension-tiling [lindex [lindex $collection 0] 1]]}
puts $fp \ \ \ \ foreach\ item\ \[lrange\ \$collection\ 1\ end\]\ \{
puts $fp {	pset dx1 dy1 [dimension-tiling [lindex $item 1]];}
puts $fp \tif\ \{\$dx\ <\ \$dx1\}\ \{
puts $fp {	    set dx $dx1;}
puts $fp \t\}
puts $fp \tif\ \{\$dy\ <\ \$dy1\}\ \{
puts $fp {	    set dy $dy1;}
puts $fp \t\}
puts $fp \ \ \ \ \}
puts $fp {    return [list $dx $dy];}
puts $fp \}
puts $fp {}
puts $fp {}
close $fp
set restore [file join subtile lib get-boolean.tcl]
puts "restoring file $restore"
if {[catch {open $restore w} fp]} { puts "failed to create file $restore" } 
puts $fp #
puts $fp {# Translate a boolean value to integer}
puts $fp #
puts $fp proc\ get-boolean\ \{val\}\ \{
puts $fp \ \ \ \ switch\ -exact\ --\ \$val\ \{
puts $fp \tt\ -\ true\ -\ 1\ -\ on\ \{
puts $fp {	    return 1;}
puts $fp \t\}
puts $fp \tf\ -\ false\ -\ 0\ -\ off\ \{
puts $fp {	    return 0;}
puts $fp \t\}
puts $fp \tdefault\ \{
puts $fp {	    error "$val is not a boolean value";}
puts $fp \t\}
puts $fp \ \ \ \ \}
puts $fp \}
puts $fp {}
puts $fp #
puts $fp {# Translate an extended boolean value and the current}
puts $fp {# value into an integer.}
puts $fp #
puts $fp proc\ merge-boolean\ \{val\ curval\}\ \{
puts $fp \ \ \ \ if\ \{\"\$val\"\ ==\ \"!\"\}\ \{
puts $fp {	return [expr ! $curval];}
puts $fp \ \ \ \ \}\ else\ \{
puts $fp {	return [get-boolean $val];}
puts $fp \ \ \ \ \}
puts $fp \}
puts $fp {}
close $fp
set restore [file join subtile lib list.tcl]
puts "restoring file $restore"
if {[catch {open $restore w} fp]} { puts "failed to create file $restore" } 
puts $fp ##
puts $fp {## useful routines for lists}
puts $fp ##
puts $fp {}
puts $fp ##
puts $fp {## return the elements of list which are not elements of list2}
puts $fp ##
puts $fp proc\ list-difference\ \{list1\ list2\}\ \{
puts $fp {    set l {};}
puts $fp \ \ \ \ foreach\ e\ \$list1\ \{
puts $fp \tif\ \{\[lsearch\ \$list2\ \$e\]\ <\ 0\}\ \{
puts $fp {	    lappend l $e;}
puts $fp \t\}
puts $fp \ \ \ \ \}
puts $fp {    return $l;}
puts $fp \}
puts $fp {}
puts $fp ##
puts $fp {## return the list generated by repeating c n times.}
puts $fp ##
puts $fp proc\ lrepeat\ \{c\ n\}\ \{
puts $fp {    set l 0;}
puts $fp \ \ \ \ while\ \{\[incr\ n\ -1\]\ >=\ 0\}\ \{
puts $fp {	lappend l $c;}
puts $fp \ \ \ \ \}
puts $fp {    return $l;}
puts $fp \}
puts $fp {}
puts $fp ##
puts $fp {## return the list with the elements in reverse order}
puts $fp ##
puts $fp proc\ lreverse\ \{list\}\ \{
puts $fp {    set nlist {};}
puts $fp \ \ \ \ foreach\ e\ \$list\ \{
puts $fp {	set nlist [linsert $nlist 0 $e];}
puts $fp \ \ \ \ \}
puts $fp {    return $nlist;}
puts $fp \}
puts $fp {}
close $fp
set restore [file join subtile lib new-window-name.tcl]
puts "restoring file $restore"
if {[catch {open $restore w} fp]} { puts "failed to create file $restore" } 
puts $fp #
puts $fp {# invent a toplevel window name}
puts $fp #
puts $fp {set new-window-name-nth 0;}
puts $fp {}
puts $fp proc\ new-window-name\ \{\}\ \{
puts $fp {    upvar \#0 new-window-name-nth nth}
puts $fp {    return .f[incr nth];}
puts $fp \}
puts $fp {}
puts $fp {}
close $fp
set restore [file join subtile lib orient-tiles.tcl]
puts "restoring file $restore"
if {[catch {open $restore w} fp]} { puts "failed to create file $restore" } 
puts $fp #
puts $fp {# force a tile to anti-clockwise vertex order}
puts $fp #
puts $fp proc\ tile-signed-area\ \{tile\}\ \{
puts $fp {    set a 0;}
puts $fp {    set pi [lindex $tile 1];}
puts $fp {    set pj [lindex $tile 2];}
puts $fp {    set vij [vsub $pj $pi];}
puts $fp \ \ \ \ for\ \{set\ i\ 3\}\ \{\$i\ <\ \[llength\ \$tile\]\}\ \{incr\ i\}\ \{
puts $fp {	set pk [lindex $tile $i];}
puts $fp {	set vik [vsub $pk $pi];}
puts $fp {	set a [expr $a + [vcross $vij $vik]];}
puts $fp {	set vij $vik;}
puts $fp \ \ \ \ \}
puts $fp {    return $a;}
puts $fp \}
puts $fp {}
puts $fp proc\ clockwise-tile-p\ \{tile\}\ \{
puts $fp \ \ \ \ if\ \{\[tile-signed-area\ \$tile\]\ <\ 0\}\ \{
puts $fp {	return 1;}
puts $fp \ \ \ \ \}\ else\ \{
puts $fp {	return 0;}
puts $fp \ \ \ \ \}
puts $fp \}
puts $fp {}
puts $fp proc\ anti-clockwise-tile-p\ \{tile\}\ \{
puts $fp \ \ \ \ if\ \{\[tile-signed-area\ \$tile\]\ >\ 0\}\ \{
puts $fp {	return 1;}
puts $fp \ \ \ \ \}\ else\ \{
puts $fp {	return 0;}
puts $fp \ \ \ \ \}
puts $fp \}
puts $fp {}
puts $fp proc\ anti-clockwise-tile\ \{tile\}\ \{
puts $fp \ \ \ \ if\ \{\[anti-clockwise-tile-p\ \$tile\]\}\ \{
puts $fp {	return $tile;}
puts $fp \ \ \ \ \}\ else\ \{
puts $fp {	set newt [lindex $tile 0];}
puts $fp \tfor\ \{set\ i\ \[llength\ \$tile\]\}\ \{\[incr\ i\ -1\]\ >\ 0\}\ \{\}\ \{
puts $fp {	    lappend newt [lindex $tile $i];}
puts $fp \t\}
puts $fp {	return $newt;}
puts $fp \ \ \ \ \}
puts $fp \}
puts $fp {}
puts $fp #
puts $fp {# force a tiling to anti-clockwise vertex order}
puts $fp #
puts $fp proc\ anti-clockwise-tiling\ \{tiles\}\ \{
puts $fp {    set newts {};}
puts $fp \ \ \ \ foreach\ tile\ \$tiles\ \{
puts $fp {	lappend newts [anti-clockwise-tile $tile];}
puts $fp \ \ \ \ \}
puts $fp {    return $newts;}
puts $fp \}
puts $fp {}
puts $fp #
puts $fp {# force a collection to anti-clockwise vertex order}
puts $fp #
puts $fp proc\ anti-clockwise-collection\ \{collection\}\ \{
puts $fp {    set newc {};}
puts $fp \ \ \ \ foreach\ item\ \$collection\ \{
puts $fp {	lappend newc [list [lindex $item 0] [anti-clockwise-tiling [lindex $item 1]]];}
puts $fp \ \ \ \ \}
puts $fp {    return $newc;}
puts $fp \}
puts $fp {}
puts $fp {}
close $fp
set restore [file join subtile lib recenter-tiles.tcl]
puts "restoring file $restore"
if {[catch {open $restore w} fp]} { puts "failed to create file $restore" } 
puts $fp #
puts $fp {# recenter a tile}
puts $fp #
puts $fp proc\ recenter-tile\ \{dx\ dy\ tile\}\ \{
puts $fp {    set newt [lindex $tile 0];}
puts $fp \ \ \ \ foreach\ point\ \[lrange\ \$tile\ 1\ end\]\ \{
puts $fp {	pset x y $point;}
puts $fp {	lappend newt [list [expr $x+$dx] [expr $y+$dy]];}
puts $fp \ \ \ \ \}
puts $fp {    return $newt;}
puts $fp \}
puts $fp {}
puts $fp #
puts $fp {# recenter a tiling}
puts $fp #
puts $fp proc\ recenter-tiling\ \{tiles\}\ \{
puts $fp {    pset xmin ymin xmax ymax [bound-tiling $tiles];}
puts $fp {    set dx [expr -$xmin+(1-($xmax-$xmin))/2];}
puts $fp {    set dy [expr -$ymin+(1-($ymax-$ymin))/2];}
puts $fp {    set newts {};}
puts $fp \ \ \ \ foreach\ tile\ \$tiles\ \{
puts $fp {	lappend newts [recenter-tile $dx $dy $tile];}
puts $fp \ \ \ \ \}
puts $fp {    return $newts;}
puts $fp \}
puts $fp {}
puts $fp #
puts $fp {# recenter a collection of tilings}
puts $fp #
puts $fp proc\ recenter-collection\ \{collection\}\ \{
puts $fp {    set newc {};}
puts $fp \ \ \ \ foreach\ item\ \$collection\ \{
puts $fp {	lappend newc [list [lindex $item 0] [recenter-tiling [lindex $item 1]]];}
puts $fp \ \ \ \ \}
puts $fp {    return $newc;}
puts $fp \}
puts $fp {}
puts $fp {}
close $fp
set restore [file join subtile lib rescale-tiles.tcl]
puts "restoring file $restore"
if {[catch {open $restore w} fp]} { puts "failed to create file $restore" } 
puts $fp #
puts $fp {# rescale a tile}
puts $fp #
puts $fp proc\ rescale-tile\ \{s\ tile\}\ \{
puts $fp {    set newt [lindex $tile 0];}
puts $fp \ \ \ \ foreach\ point\ \[lrange\ \$tile\ 1\ end\]\ \{
puts $fp {	pset x y $point;}
puts $fp {	lappend newt [list [expr $x*$s] [expr $y*$s]];}
puts $fp \ \ \ \ \}
puts $fp {    return $newt;}
puts $fp \}
puts $fp {}
puts $fp #
puts $fp {# rescale a tiling}
puts $fp #
puts $fp proc\ rescale-tiling\ \{s\ tiles\}\ \{
puts $fp {    set newts {}}
puts $fp \ \ \ \ foreach\ tile\ \$tiles\ \{
puts $fp {	lappend newts [rescale-tile $s $tile];}
puts $fp \ \ \ \ \}
puts $fp {    return $newts;}
puts $fp \}
puts $fp {}
puts $fp #
puts $fp {# rescale a tile collection}
puts $fp #
puts $fp proc\ rescale-collection\ \{s\ collection\}\ \{
puts $fp {    set newc {};}
puts $fp \ \ \ \ foreach\ item\ \$collection\ \{
puts $fp {	lappend newc [list [lindex $item 0] [rescale-tiling $s [lindex $item 1]]];}
puts $fp \ \ \ \ \}
puts $fp {    return $newc;}
puts $fp \}
puts $fp {}
puts $fp {}
close $fp
set restore [file join subtile lib scale.tcl]
puts "restoring file $restore"
if {[catch {open $restore w} fp]} { puts "failed to create file $restore" } 
puts $fp #
puts $fp {# implement page scaling by pulling or pushing away from the}
puts $fp {# upper left corner???}
puts $fp #
puts $fp proc\ scale-mark\ \{w\ x\ y\}\ \{
puts $fp {    upvar \#0 $w d;}
puts $fp {    set d(s-m-r2) [expr pow($x,2)+pow($y,2)];}
puts $fp \}
puts $fp {}
puts $fp proc\ scale-dragto\ \{w\ x\ y\}\ \{
puts $fp {    upvar \#0 $w d;}
puts $fp {    set r2 [expr pow($x,2)+pow($y,2)];}
puts $fp {    set s [expr sqrt(double($r2)/$d(s-m-r2))]}
puts $fp {    set d(s-m-r2) $r2;}
puts $fp {    set d(scale) [expr $d(scale)*$s];}
puts $fp {    $w.c scale all 0 0 $s $s;}
puts $fp \}
puts $fp {}
puts $fp {}
close $fp
set restore [file join subtile lib scroll.tcl]
puts "restoring file $restore"
if {[catch {open $restore w} fp]} { puts "failed to create file $restore" } 
puts $fp #
puts $fp {# implement page scrolling by pushing the page}
puts $fp #
puts $fp proc\ scroll-mark\ \{w\ x\ y\}\ \{
puts $fp {    upvar \#0 $w d;}
puts $fp {    set d(s-m-x) $x;}
puts $fp {    set d(s-m-y) $y;}
puts $fp \}
puts $fp {}
puts $fp proc\ scroll-dragto\ \{w\ x\ y\}\ \{
puts $fp {    upvar \#0 $w d;}
puts $fp {    set dx [expr -($x-$d(s-m-x))];}
puts $fp {    set dy [expr -($y-$d(s-m-y))];}
puts $fp {    set d(s-m-x) $x;}
puts $fp {    set d(s-m-y) $y;}
puts $fp {    $w.c xview scroll $dx units;}
puts $fp {    $w.c yview scroll $dy units;}
puts $fp \}
puts $fp {}
puts $fp {}
close $fp
set restore [file join subtile lib tclIndex]
puts "restoring file $restore"
if {[catch {open $restore w} fp]} { puts "failed to create file $restore" } 
puts $fp {# Tcl autoload index file, version 2.0}
puts $fp {# This file is generated by the "auto_mkindex" command}
puts $fp {# and sourced to set up indexing information for one or}
puts $fp {# more commands.  Typically each line is a command that}
puts $fp {# sets an element in the auto_index array, where the}
puts $fp {# element name is the name of a command and the value is}
puts $fp {# a script that loads the command.}
puts $fp {}
puts $fp {set auto_index(about-something) [list source [file join $dir about.tcl]]}
puts $fp {set auto_index(pset) [list source [file join $dir assign.tcl]]}
puts $fp {set auto_index(bound-tile) [list source [file join $dir bound-tiles.tcl]]}
puts $fp {set auto_index(bound-tiling) [list source [file join $dir bound-tiles.tcl]]}
puts $fp {set auto_index(bound-collection) [list source [file join $dir bound-tiles.tcl]]}
puts $fp {set auto_index(canvasview) [list source [file join $dir canvasview.tcl]]}
puts $fp {set auto_index(dimension-tile) [list source [file join $dir dimension-tiles.tcl]]}
puts $fp {set auto_index(dimension-tiling) [list source [file join $dir dimension-tiles.tcl]]}
puts $fp {set auto_index(dimension-collection) [list source [file join $dir dimension-tiles.tcl]]}
puts $fp {set auto_index(get-boolean) [list source [file join $dir get-boolean.tcl]]}
puts $fp {set auto_index(merge-boolean) [list source [file join $dir get-boolean.tcl]]}
puts $fp {set auto_index(list-difference) [list source [file join $dir list.tcl]]}
puts $fp {set auto_index(lrepeat) [list source [file join $dir list.tcl]]}
puts $fp {set auto_index(lreverse) [list source [file join $dir list.tcl]]}
puts $fp {set auto_index(new-window-name) [list source [file join $dir new-window-name.tcl]]}
puts $fp {set auto_index(tile-signed-area) [list source [file join $dir orient-tiles.tcl]]}
puts $fp {set auto_index(clockwise-tile-p) [list source [file join $dir orient-tiles.tcl]]}
puts $fp {set auto_index(anti-clockwise-tile-p) [list source [file join $dir orient-tiles.tcl]]}
puts $fp {set auto_index(anti-clockwise-tile) [list source [file join $dir orient-tiles.tcl]]}
puts $fp {set auto_index(anti-clockwise-tiling) [list source [file join $dir orient-tiles.tcl]]}
puts $fp {set auto_index(anti-clockwise-collection) [list source [file join $dir orient-tiles.tcl]]}
puts $fp {set auto_index(recenter-tile) [list source [file join $dir recenter-tiles.tcl]]}
puts $fp {set auto_index(recenter-tiling) [list source [file join $dir recenter-tiles.tcl]]}
puts $fp {set auto_index(recenter-collection) [list source [file join $dir recenter-tiles.tcl]]}
puts $fp {set auto_index(rescale-tile) [list source [file join $dir rescale-tiles.tcl]]}
puts $fp {set auto_index(rescale-tiling) [list source [file join $dir rescale-tiles.tcl]]}
puts $fp {set auto_index(rescale-collection) [list source [file join $dir rescale-tiles.tcl]]}
puts $fp {set auto_index(scale-mark) [list source [file join $dir scale.tcl]]}
puts $fp {set auto_index(scale-dragto) [list source [file join $dir scale.tcl]]}
puts $fp {set auto_index(scroll-mark) [list source [file join $dir scroll.tcl]]}
puts $fp {set auto_index(scroll-dragto) [list source [file join $dir scroll.tcl]]}
puts $fp {set auto_index(textview) [list source [file join $dir textview.tcl]]}
puts $fp {set auto_index(vunpack) [list source [file join $dir vector.tcl]]}
puts $fp {set auto_index(vmake) [list source [file join $dir vector.tcl]]}
puts $fp {set auto_index(vadd) [list source [file join $dir vector.tcl]]}
puts $fp {set auto_index(vsub) [list source [file join $dir vector.tcl]]}
puts $fp {set auto_index(vscale) [list source [file join $dir vector.tcl]]}
puts $fp {set auto_index(vsum) [list source [file join $dir vector.tcl]]}
puts $fp {set auto_index(vneg) [list source [file join $dir vector.tcl]]}
puts $fp {set auto_index(rmake) [list source [file join $dir vector.tcl]]}
puts $fp {set auto_index(vrotate) [list source [file join $dir vector.tcl]]}
puts $fp {set auto_index(vdot) [list source [file join $dir vector.tcl]]}
puts $fp {set auto_index(vcross) [list source [file join $dir vector.tcl]]}
puts $fp {set auto_index(vangle) [list source [file join $dir vector.tcl]]}
puts $fp {set auto_index(vlength) [list source [file join $dir vector.tcl]]}
puts $fp {set auto_index(vertex-atlas-tiling) [list source [file join $dir vertex-atlas.tcl]]}
puts $fp {set auto_index(vertex-atlas-choose-key) [list source [file join $dir vertex-atlas.tcl]]}
puts $fp {set auto_index(read-file) [list source [file join $dir text-files.tcl]]}
puts $fp {set auto_index(read-file-nonewline) [list source [file join $dir text-files.tcl]]}
puts $fp {set auto_index(maybe-read-file) [list source [file join $dir text-files.tcl]]}
puts $fp {set auto_index(write-file) [list source [file join $dir text-files.tcl]]}
puts $fp {set auto_index(overwrite-file) [list source [file join $dir text-files.tcl]]}
puts $fp {set auto_index(append-file) [list source [file join $dir text-files.tcl]]}
puts $fp {set auto_index(file-line-count) [list source [file join $dir text-files.tcl]]}
puts $fp {set auto_index(file-word-count) [list source [file join $dir text-files.tcl]]}
puts $fp {}
close $fp
set restore [file join subtile lib textview.tcl]
puts "restoring file $restore"
if {[catch {open $restore w} fp]} { puts "failed to create file $restore" } 
puts $fp namespace\ eval\ textview\ \{
puts $fp {    #@}
puts $fp {    #@  procedure "textview"}
puts $fp {    #@------------------------------>  The textview widget builds a frame which}
puts $fp {    #@                                 containts the text of a file, or a stream,}
puts $fp {    #@                                 or a list of strings, and optionally }
puts $fp {    #@                                 enables horizontal and or vertical scroll}
puts $fp {    #@                                 bars.}
puts $fp {    ##}
puts $fp \ \ \ \ proc\ textview\ \{w\ args\}\ \{
puts $fp {	#@}
puts $fp {	#@--------------->  establish the widget local state binding.}
puts $fp {	##}
puts $fp {	upvar #0 $w data;}
puts $fp {	#@}
puts $fp {	#@--------------->  establish a Tk frame widget.}
puts $fp {	##}
puts $fp {	frame $w -class Textview;}
puts $fp {	rename $w $w.frame;}
puts $fp {	#@}
puts $fp {	#@--------------->  widget method dispatcher.}
puts $fp {	##}
puts $fp \tproc\ ::\$w\ \{method\ args\}\ \\
puts $fp {	    "return \[eval [namespace current]::method::\$method $w \$args\];"}
puts $fp {	#@}
puts $fp {	#@--------------->  instantiate the widget.}
puts $fp {	##}
puts $fp {	pack [text $w.t] -expand true -fill both}
puts $fp {	#@}
puts $fp {	#@--------------->  redirect bindings.}
puts $fp {	##}
puts $fp {	bindtags $w.t "Text $w [winfo toplevel $w] all"}
puts $fp {	#@}
puts $fp {	#@--------------->  default configuration}
puts $fp {	##}
puts $fp \tset\ data(options)\ \{
puts $fp {	    {-vscroll vScroll VScroll 0}}
puts $fp {	    {-hscroll hScroll HScroll 0}}
puts $fp \t\}\;
puts $fp \tforeach\ opt\ \$data(options)\ \{
puts $fp {	    set name [lindex $opt 0];}
puts $fp {	    set data($name) [lindex $opt 3];}
puts $fp \t\}
puts $fp {	#@}
puts $fp {	#@--------------->  apply the configuration options.}
puts $fp {	##}
puts $fp {	doconfigure;}
puts $fp {	#@}
puts $fp {	#@--------------->  return the widget name.}
puts $fp {	##}
puts $fp {	return $w;}
puts $fp \ \ \ \ \}
puts $fp \ \ \ \ namespace\ eval\ method\ \{
puts $fp {    #@}
puts $fp {    #@==============================================================================}
puts $fp {    #@}
puts $fp {    #@  procedure "textview::method::cget"}
puts $fp {	#@------------------------------>  widget methods}
puts $fp {	##}
puts $fp \tproc\ cget\ \{w\ args\}\ \{
puts $fp \t\ \ \ \ if\ \{\[llength\ \$args\]\ !=\ 1\}\ \{
puts $fp {		error "usage: pathName cget option";}
puts $fp \t\ \ \ \ \}\ else\ \{
puts $fp {		return [lindex [$w configure $args] 4];}
puts $fp \t\ \ \ \ \}
puts $fp \t\}
puts $fp {	#@}
puts $fp {	#@==============================================================================}
puts $fp {	#@}
puts $fp {	#@  procedure "textview::method::configure"}
puts $fp {	#@------------------------------>  widget methods}
puts $fp {	##}
puts $fp \tproc\ configure\ \{w\ args\}\ \{
puts $fp {	    upvar #0 $w data;}
puts $fp \t\ \ \ \ if\ \{\[llength\ \$args\]\ ==\ 0\}\ \{
puts $fp {		set options {};}
puts $fp \t\tforeach\ opt\ \$data(options)\ \{
puts $fp {		    set name [lindex $opt 0];}
puts $fp \t\t\ \ \ \ if\ \{\[llength\ \$opt\]\ ==\ 4\}\ \{
puts $fp {			lappend opt $data($name);}
puts $fp \t\t\ \ \ \ \}
puts $fp {		    lappend options $opt;}
puts $fp \t\t\}
puts $fp {		return [concat $options [$w.t configure]];}
puts $fp \t\ \ \ \ \}
puts $fp \t\ \ \ \ if\ \{\[llength\ \$args\]\ ==\ 1\}\ \{
puts $fp \t\tforeach\ opt\ \$data(options)\ \{
puts $fp {		    set name [lindex $opt 0];}
puts $fp \t\t\ \ \ \ if\ \{\"\$name\"\ ==\ \"\$args\"\}\ \{
puts $fp \t\t\tif\ \{\[llength\ \$opt\]\ ==\ 4\}\ \{
puts $fp {			    lappend opt $data($name);}
puts $fp {			    return $opt;}
puts $fp \t\t\t\}\ else\ \{
puts $fp {			    return [$w configure -[lindex $opt 2]];}
puts $fp \t\t\t\}
puts $fp \t\t\ \ \ \ \}
puts $fp \t\t\}
puts $fp {		return [$w.t configure $name];}
puts $fp \t\ \ \ \ \}
puts $fp {	    return [[namespace parent]::doconfigure];}
puts $fp \t\}
puts $fp {	#@}
puts $fp {	#@==============================================================================}
puts $fp {	#@}
puts $fp {	#@--------------->  methods from text exclude cget and configure}
puts $fp {	##}
puts $fp \tforeach\ method\ \{bbox\ compare\ debug\ delete\ dlineinfo\ get\ index\ insert\ mark\\
puts $fp \t\t\t\ \ \ \ scan\ search\ see\ tag\ window\ xview\ yview\}\ \\
puts $fp \t\ \ \ \ \{
puts $fp {	    proc $method {w args} "eval \$w.t $method \$args";}
puts $fp \t\}
puts $fp \ \ \ \ \}
puts $fp {    #@}
puts $fp {    #@==============================================================================}
puts $fp {    #@}
puts $fp {    #@  procedure "textview::doconfigure"}
puts $fp {    #@------------------------------>  internals}
puts $fp {    ##}
puts $fp \ \ \ \ proc\ doconfigure\ \{\}\ \{
puts $fp {	upvar w w;}
puts $fp {	upvar args args;}
puts $fp {	upvar data data;}
puts $fp {	set targs {};}
puts $fp \twhile\ \{\[llength\ \$args\]\ >=\ 2\}\ \{
puts $fp {	    set option [lindex $args 0];}
puts $fp {	    set value [lindex $args 1];}
puts $fp {	    set args [lrange $args 2 end];}
puts $fp \t\ \ \ \ switch\ -exact\ --\ \$option\ \{
puts $fp \t\t-hscroll\ \{
puts $fp {		    set data(-hscroll) [merge-boolean $value $data(-hscroll)];}
puts $fp {		    #@}
puts $fp {		    #@                  Repack textview}
puts $fp {		    #@--------------------------------------------->  "Lib_tk/textview.tcl"}
puts $fp {		    ##}
puts $fp {		    repack;}
puts $fp \t\t\}
puts $fp \t\t-vscroll\ \{
puts $fp {		    set data(-vscroll) [merge-boolean $value $data(-vscroll)];}
puts $fp {		    #@}
puts $fp {		    #@                  Repack textview}
puts $fp {		    #@--------------------------------------------->  "Lib_tk/textview.tcl"}
puts $fp {		    ##}
puts $fp {		    repack;}
puts $fp \t\t\}
puts $fp \t\tdefault\ \{
puts $fp {		    lappend targs $option $value;}
puts $fp \t\t\}
puts $fp \t\ \ \ \ \}
puts $fp \t\}
puts $fp \tif\ \{\[llength\ \$args\]\ !=\ 0\}\ \{
puts $fp {	    error "unmatched option argument: $args";}
puts $fp \t\}
puts $fp \tif\ \{\"\$targs\"\ !=\ \{\}\}\ \{
puts $fp {	    #@}
puts $fp {	    #@--------------->  call dispatched procedure}
puts $fp {	    ##}
puts $fp {	    return [eval $w.t configure $targs];}
puts $fp \t\}\ else\ \{
puts $fp {	    return {};}
puts $fp \t\}
puts $fp \ \ \ \ \}
puts $fp {    #@}
puts $fp {    #@==============================================================================}
puts $fp {    #@}
puts $fp {    #@  procedure "textview::repack"}
puts $fp {    #@------------------------------>  redraw}
puts $fp {    ##}
puts $fp \ \ \ \ proc\ repack\ \{\}\ \{
puts $fp {	upvar w w;}
puts $fp {	upvar data data;}
puts $fp {	$w.t configure -xscrollcommand {} -yscrollcommand {};}
puts $fp {	#@}
puts $fp {	#@--------------->  Destroy widgets}
puts $fp {	##}
puts $fp {	catch {pack forget $w.e};}
puts $fp {	catch {destroy $w.e};}
puts $fp {	catch {pack forget $w.v};}
puts $fp {	catch {destroy $w.v};}
puts $fp {	catch {pack forget $w.h};}
puts $fp {	catch {destroy $w.h};}
puts $fp {	}
puts $fp \tswitch\ \$data(-hscroll)\$data(-vscroll)\ \{
puts $fp \t\ \ \ \ 10\ \{
puts $fp \t\tpack\ \[scrollbar\ \$w.h\ -orient\ horizontal\ -command\ \"\$w.t\ xview\"\ \\
puts $fp {			  -takefocus 0] -before $w.t -side bottom -fill x;}
puts $fp {		$w.t configure -xscrollcommand "$w.h set";}
puts $fp \t\ \ \ \ \}
puts $fp \t\ \ \ \ 01\ \{
puts $fp \t\tpack\ \[scrollbar\ \$w.v\ -orient\ vertical\ -command\ \"\$w.t\ yview\"\ \\
puts $fp {			  -takefocus 0] -before $w.t -side right -fill y;}
puts $fp {		$w.t configure -yscrollcommand "$w.v set";}
puts $fp \t\ \ \ \ \}
puts $fp \t\ \ \ \ 11\ \{
puts $fp {		pack [frame $w.e] -before $w.t -side right -fill y;}
puts $fp {		pack [frame $w.e.s] -side bottom;}
puts $fp \t\tpack\ \[scrollbar\ \$w.v\ -orient\ vertical\ -command\ \"\$w.t\ yview\"\ \\
puts $fp {			  -takefocus 0] -in $w.e -side right -fill y;}
puts $fp \t\tpack\ \[scrollbar\ \$w.h\ -orient\ horizontal\ -command\ \"\$w.t\ xview\"\ \\
puts $fp {			  -takefocus 0] -before $w.t -side bottom -fill x;}
puts $fp {		$w.t configure -xscrollcommand "$w.h set" -yscrollcommand "$w.v set";}
puts $fp {		bind $w.e.s <Configure> "$w.e.s configure -height \[winfo height $w.h]";}
puts $fp \t\ \ \ \ \}
puts $fp \t\}
puts $fp \ \ \ \ \}
puts $fp \}
puts $fp {}
puts $fp proc\ textview\ \{w\ args\}\ \{
puts $fp {    return [eval textview::textview $w $args]}
puts $fp \}
puts $fp #@
puts $fp #@==============================================================================
puts $fp {}
close $fp
set restore [file join subtile lib vector.tcl]
puts "restoring file $restore"
if {[catch {open $restore w} fp]} { puts "failed to create file $restore" } 
puts $fp {# unpack a 2d vector into components}
puts $fp proc\ vunpack\ \{args\}\ \{
puts $fp \ \ \ \ foreach\ v\ \$args\ \{
puts $fp {	upvar $v u ${v}0 u0 ${v}1 u1;}
puts $fp {	set u0 [lindex $u 0];}
puts $fp {	set u1 [lindex $u 1];}
puts $fp \ \ \ \ \}
puts $fp \}
puts $fp {# pack two components into a 2d vector}
puts $fp proc\ vmake\ \{u0\ u1\}\ \{
puts $fp {    return [list [uplevel "expr $u0"] [uplevel "expr $u1"]];}
puts $fp \}
puts $fp {# add two 2d vectors}
puts $fp proc\ vadd\ \{u\ v\}\ \{
puts $fp {    vunpack u v;}
puts $fp {    return [vmake $u0+$v0 $u1+$v1];}
puts $fp \}
puts $fp {# subtract two 2d vectors}
puts $fp proc\ vsub\ \{u\ v\}\ \{
puts $fp {    vunpack u v;}
puts $fp {    return [vmake $u0-$v0 $u1-$v1];}
puts $fp \}
puts $fp {# scale a vector by a scalar factor}
puts $fp proc\ vscale\ \{s\ u\}\ \{
puts $fp {    vunpack s u;}
puts $fp {    return [vmake $s0*$u0 $s0*$u1];}
puts $fp \}
puts $fp {# sum a list of 2d vectors}
puts $fp proc\ vsum\ \{u\ args\}\ \{
puts $fp {    vunpack u;}
puts $fp \ \ \ \ foreach\ v\ \$args\ \{
puts $fp {	vunpack v;}
puts $fp {	append u0 +$v0;}
puts $fp {	append u1 +$v1;}
puts $fp \ \ \ \ \}
puts $fp {    return [vmake $u0 $u1];}
puts $fp \}
puts $fp {# negate a vector}
puts $fp proc\ vneg\ \{u\}\ \{
puts $fp {    return [vsub {0 0} $u];}
puts $fp \}
puts $fp {# make a 2d rotation by angle a}
puts $fp proc\ rmake\ \{a\}\ \{
puts $fp {    return [vmake cos($a) sin($a)];}
puts $fp \}
puts $fp {# apply a 2d rotation to a 2d vector}
puts $fp proc\ vrotate\ \{r\ u\}\ \{
puts $fp {    vunpack r u;}
puts $fp {    return [vmake $r0*$u0-$r1*$u1 $r1*$u0+$r0*$u1];}
puts $fp \}
puts $fp {# dot product of two 2d vectors}
puts $fp proc\ vdot\ \{a\ b\}\ \{
puts $fp {    vunpack a b;}
puts $fp {    return [expr $a0*$b0 + $a1*$b1];}
puts $fp \}
puts $fp {# cross product of two 2d vectors}
puts $fp proc\ vcross\ \{a\ b\}\ \{
puts $fp {    vunpack a b;}
puts $fp {    return [expr $a0*$b1-$a1*$b0];}
puts $fp \}
puts $fp {# angle between two vectors measured counter clockwise}
puts $fp proc\ vangle\ \{a\ b\}\ \{
puts $fp {    return [expr atan2([vcross $a $b], [vdot $a $b])];}
puts $fp \}
puts $fp {# length of a vector}
puts $fp proc\ vlength\ \{a\}\ \{
puts $fp {    return [expr sqrt([vdot $a $a])];}
puts $fp \}
puts $fp {}
close $fp
set restore [file join subtile lib vertex-atlas.tcl]
puts "restoring file $restore"
if {[catch {open $restore w} fp]} { puts "failed to create file $restore" } 
puts $fp proc\ vertex-atlas-tiling\ \{tiling\}\ \{
puts $fp {}
puts $fp {    # create a map of tiles incident to each vertex}
puts $fp {    global tcl_precision;}
puts $fp {    set z [vmake 0 0];}
puts $fp \ \ \ \ foreach\ tile\ \$tiling\ \{
puts $fp {	# the tile type}
puts $fp {	set type [lindex $tile 0];}
puts $fp {	# the first vertex}
puts $fp {	set pj [lindex $tile 1];}
puts $fp {	# is this a clockwise tile}
puts $fp {	set cw [clockwise-tile-p $tile];}
puts $fp {	# from the 2nd to the last and on to the first}
puts $fp {	# form the vector from pi to the previous vertex}
puts $fp {	set vis {};}
puts $fp {	set vijs {};}
puts $fp \tforeach\ pi\ \[concat\ \[lrange\ \$tile\ 2\ end\]\ \[list\ \$pj\]\]\ \{
puts $fp {	    # compute the edge vector}
puts $fp {	    set vij [vsub $pi $pj];}
puts $fp {	    # normalize to unit length}
puts $fp {	    set vij [vscale [expr 1/[vlength $vij]] $vij]}
puts $fp {	    # remember the edge vector}
puts $fp {	    lappend vijs $vij;}
puts $fp {	    # remember the vertices at lower precision}
puts $fp {	    set tcl_precision 3;}
puts $fp {	    lappend vis [vadd $z $pi];}
puts $fp {	    set tcl_precision 6;}
puts $fp {	    # step to the next vertex}
puts $fp {	    set pj $pi;}
puts $fp \t\}
puts $fp {	# extend the vij list by the first}
puts $fp {	lappend vijs [lindex $vijs 0];}
puts $fp {	# make the list clockwise}
puts $fp \tif\ \{\ !\ \$cw\ \}\ \{
puts $fp {	    set vijs [lreverse $vijs];}
puts $fp {	    set vis [lreverse $vis];}
puts $fp \t\}
puts $fp {	# now install the vertices}
puts $fp \tfor\ \{set\ i\ 0\}\ \{\$i\ <\ \[llength\ \$vis\]\}\ \{incr\ i\}\ \{
puts $fp {	    lappend vertices([lindex $vis $i]) [list [lindex $vijs $i] [vneg [lindex $vijs [expr $i+1]]] $tile];}
puts $fp {	    #puts "[lindex $vis $i], cw? $cw,  [lindex $vijs $i] [vneg [lindex $vijs [expr $i+1]]]\n\t$tile"}
puts $fp \t\}
puts $fp \ \ \ \ \}
puts $fp {}
puts $fp {    # for each vertex found,}
puts $fp {    # match the tiles incident to the vertex}
puts $fp {    # by their edge vectors}
puts $fp \ \ \ \ foreach\ vertex\ \[array\ names\ vertices\]\ \{
puts $fp {	#puts "vertex $vertex";}
puts $fp \tif\ \{\[llength\ \$vertices(\$vertex)\]\ <\ 3\}\ \{
puts $fp {	    unset vertices($vertex);}
puts $fp {	    continue;}
puts $fp \t\}
puts $fp {	catch {unset edge};}
puts $fp {	catch {unset vcw};}
puts $fp {	catch {unset ang};}
puts $fp {	set t 0;}
puts $fp {	# find the edges radiating from the vertex}
puts $fp \tforeach\ item\ \$vertices(\$vertex)\ \{
puts $fp {	    # get the edges incident to the vertex}
puts $fp {	    pset vij vik tile $item;}
puts $fp {	    #puts "$vertex -> $item"}
puts $fp {	    # remember this tile as containing this edge}
puts $fp {	    lappend edge($vij) $t;}
puts $fp {	    lappend edge($vik) $t;}
puts $fp {	    # remember the more clockwise edge and its angle}
puts $fp {	    set vcw($t) $vik;}
puts $fp {	    set ang($t) [format {%.2f} [expr 180 * [vangle $vij $vik] / 3.14159265359]];}
puts $fp {	    # step to next tile}
puts $fp {	    incr t;}
puts $fp \t\}
puts $fp {	# follow tiles around the vertex clockwise}
puts $fp {	set inds {};}
puts $fp {	set n 0;}
puts $fp \tfor\ \{set\ last\ 0\}\ \{1\}\ \{set\ last\ \$new\}\ \{
puts $fp {	    # accumulate the tile indexes}
puts $fp {	    lappend inds $last;}
puts $fp {}
puts $fp {	    # find the clockwise edge of the tile}
puts $fp {	    set v $vcw($last);}
puts $fp {}
puts $fp {	    #puts "$last $v $edge($v)"}
puts $fp {}
puts $fp {	    # test for incomplete vertex, ie on edge of tiling}
puts $fp \t\ \ \ \ if\ \{\[llength\ \$edge(\$v)\]\ !=\ 2\}\ \{
puts $fp {		unset inds;}
puts $fp {		break;}
puts $fp \t\ \ \ \ \}
puts $fp {}
puts $fp {	    # determine which of the tile indexes is new}
puts $fp \t\ \ \ \ foreach\ new\ \$edge(\$v)\ \{
puts $fp \t\tif\ \{\$new\ !=\ \$last\}\ \{
puts $fp {		    break;}
puts $fp \t\t\}
puts $fp \t\ \ \ \ \}
puts $fp {}
puts $fp {	    # see if we are finished, ie back to the start}
puts $fp \t\ \ \ \ if\ \{\$new\ ==\ \[lindex\ \$inds\ 0\]\}\ \{
puts $fp {		break;}
puts $fp \t\ \ \ \ \}
puts $fp {	    # look out for endless loops}
puts $fp \t\ \ \ \ if\ \{\[incr\ n\]\ >\ 30\}\ \{
puts $fp {		puts "endless loop: $inds\n[join $vertices($vertex) \n]";}
puts $fp {		unset inds;}
puts $fp {		break;}
puts $fp \t\ \ \ \ \}
puts $fp \t\}
puts $fp {	# test for complete vertex}
puts $fp \tif\ \{\ !\ \[info\ exists\ inds\]\}\ \{
puts $fp {	    continue;}
puts $fp \t\}
puts $fp {	# build a descriptor}
puts $fp {	set key {};}
puts $fp {	set tiles {};}
puts $fp \tforeach\ ix\ \$inds\ \{
puts $fp {	    pset vij vik tile [lindex $vertices($vertex) $ix];}
puts $fp {	    lappend key $ang($ix)/[lindex $tile 0];}
puts $fp {	    lappend tiles $tile;}
puts $fp \t\}
puts $fp {	set i [vertex-atlas-choose-key $key]}
puts $fp {	set key [concat [lrange $key $i end] [lrange $key 0 [expr $i-1]]];}
puts $fp {	set tiles [concat [lrange $tiles $i end] [lrange $tiles 0 [expr $i-1]]];}
puts $fp \tif\ \{\ !\ \[info\ exists\ atlas(\$key)\]\}\ \{
puts $fp {	    set atlas($key) {};}
puts $fp {	    lappend tilings [list $key $tiles];}
puts $fp {	    #puts "installed $key [join $tiles \n]"}
puts $fp \t\}
puts $fp \ \ \ \ \}
puts $fp {    return $tilings;}
puts $fp \}
puts $fp {}
puts $fp proc\ vertex-atlas-choose-key\ \{key\}\ \{
puts $fp {    lappend list $key;}
puts $fp \ \ \ \ for\ \{set\ i\ 1\}\ \{\$i\ <\ \[llength\ \$key\]\}\ \{incr\ i\}\ \{
puts $fp {	lappend list [concat [lrange $key $i end] [lrange $key 0 [expr $i-1]]];}
puts $fp \ \ \ \ \}
puts $fp {    set sort [lsort $list];}
puts $fp {    set i1 [lsearch $list [lindex $sort 0]];}
puts $fp {    set i2 0;}
puts $fp \ \ \ \ foreach\ item\ \$list\ \{
puts $fp \tif\ \{\"\$item\"\ ==\ \"\[lindex\ \$sort\ 0\]\"\}\ \{
puts $fp {	    break;}
puts $fp \t\}
puts $fp {	incr i2;}
puts $fp \ \ \ \ \}
puts $fp \ \ \ \ if\ \{\$i2\ !=\ \$i1\}\ \{
puts $fp {	puts "lsearch error";}
puts $fp \ \ \ \ \}
puts $fp {    return $i1;}
puts $fp \}
puts $fp {}
close $fp
set restore [file join subtile lib text-files.tcl]
puts "restoring file $restore"
if {[catch {open $restore w} fp]} { puts "failed to create file $restore" } 
puts $fp #
puts $fp {# read-file - read a text file}
puts $fp {# open a file,}
puts $fp {# read its contents into a string,}
puts $fp {# close the file,}
puts $fp {# and return the string.}
puts $fp #
puts $fp proc\ read-file\ \{filename\}\ \{
puts $fp {    set string {};}
puts $fp {    set fileId [open $filename r];}
puts $fp \ \ \ \ catch\ \{
puts $fp {	set string [read $fileId];}
puts $fp {	close $fileId;}
puts $fp \ \ \ \ \}
puts $fp {    return $string;}
puts $fp \}
puts $fp #
puts $fp {# read-file-nonewline - read a text file with no trailing newline}
puts $fp {# open a file,}
puts $fp {# read its contents into a string,}
puts $fp {# close the file,}
puts $fp {# and return the string.}
puts $fp #
puts $fp proc\ read-file-nonewline\ \{filename\}\ \{
puts $fp {    set string {};}
puts $fp {    set fileId [open $filename r];}
puts $fp \ \ \ \ catch\ \{
puts $fp {	set string [read -nonewline $fileId];}
puts $fp {	close $fileId;}
puts $fp \ \ \ \ \}
puts $fp {    return $string;}
puts $fp \}
puts $fp #
puts $fp {# maybe-read-file - read a text file if it exists}
puts $fp #
puts $fp proc\ maybe-read-file\ \{filename\}\ \{
puts $fp \ \ \ \ if\ \{\[file\ exists\ \$filename\]\}\ \{
puts $fp {	return [read-file $filename];}
puts $fp \ \ \ \ \}\ else\ \{
puts $fp {	return {};}
puts $fp \ \ \ \ \}
puts $fp \}
puts $fp #
puts $fp {# write-file - write a text file}
puts $fp {# create a file,}
puts $fp {# write the string into the file,}
puts $fp {# close the file}
puts $fp {# fail if the file exists.}
puts $fp #
puts $fp proc\ write-file\ \{filename\ string\}\ \{
puts $fp \ \ \ \ if\ \{\[file\ exists\ \$filename\]\}\ \{
puts $fp {	error "write-file: $filename: file already exists";}
puts $fp \ \ \ \ \}\ else\ \{
puts $fp {	set fileId [open $filename w];}
puts $fp {	puts -nonewline $fileId $string;}
puts $fp {	close $fileId;}
puts $fp {	return {};}
puts $fp \ \ \ \ \}
puts $fp \}
puts $fp #
puts $fp {# overwrite-file - write a text file}
puts $fp {# create a file,}
puts $fp {# write the string into the file,}
puts $fp {# close the file}
puts $fp #
puts $fp proc\ overwrite-file\ \{filename\ string\}\ \{
puts $fp {    set fileId [open $filename w];}
puts $fp {    puts -nonewline $fileId $string;}
puts $fp {    close $fileId;}
puts $fp {    return {};}
puts $fp \}
puts $fp #
puts $fp {# append-file - append to a file}
puts $fp {# open a file for update,}
puts $fp {# write the string onto the end of the file,}
puts $fp {# close the file.}
puts $fp #
puts $fp proc\ append-file\ \{filename\ string\}\ \{
puts $fp {    set fileId [open $filename a+];}
puts $fp {    puts -nonewline $fileId $string;}
puts $fp {    close $fileId;}
puts $fp {    return {};}
puts $fp \}
puts $fp #
puts $fp {# file-line-count - count the lines in a file}
puts $fp #
puts $fp proc\ file-line-count\ \{filename\}\ \{
puts $fp {    return [lindex [exec wc [glob $filename]] 0];}
puts $fp \}\ \ \ \ 
puts $fp #
puts $fp {# file-word-count - count the words in a file}
puts $fp #
puts $fp proc\ file-word-count\ \{filename\}\ \{
puts $fp {    return [lindex [exec wc [glob $filename]] 1];}
puts $fp \}
puts $fp {}
close $fp
set restore [file join subtile subtile]
puts "restoring file $restore"
if {[catch {open $restore w} fp]} { puts "failed to create file $restore" } 
puts $fp #!/usr/local/bin/wish8.0
puts $fp {}
puts $fp ########################################################################
puts $fp ##
puts $fp {## If you want to install subtile as a command, then set this}
puts $fp {## variable to point to the source directory so that the library}
puts $fp {## functions and tilings can be loaded.}
puts $fp ##
puts $fp {set subtile(home) [pwd];}
puts $fp {}
puts $fp ########################################################################
puts $fp ##
puts $fp {## load library sources}
puts $fp ##
puts $fp {lappend auto_path [file join $subtile(home) lib];}
puts $fp {}
puts $fp ########################################################################
puts $fp ##
puts $fp {## load tiling definitions.}
puts $fp ##
puts $fp {set tcl_precision 17;}
puts $fp {}
puts $fp {set Pi [expr 4*atan(1)];}
puts $fp {set Tau [expr (1+sqrt(5))/2];}
puts $fp {set Sqrt2 [expr sqrt(2)];}
puts $fp {}
puts $fp foreach\ t\ \{penrose\ ammann\ danzer\ xdanzer\ binary\ pinwheel\ sphinx\ chair\}\ \{
puts $fp {    source [file join $subtile(home) tiling $t.tcl];}
puts $fp \}
puts $fp {}
puts $fp {set tcl_precision 6}
puts $fp {}
puts $fp ########################################################################
puts $fp ##
puts $fp {## default parameter values}
puts $fp ##
puts $fp {set subtile(no-draw) 0;}
puts $fp {set subtile(scale) 80;}
puts $fp {set subtile(edge) 200;}
puts $fp {set subtile(overlay) 1;}
puts $fp {set subtile(watch-tiles) 0;}
puts $fp {set subtile(background) white;}
puts $fp {set subtile(fill) {};}
puts $fp {set subtile(activeFill) grey;}
puts $fp {}
puts $fp ########################################################################
puts $fp ##
puts $fp {## main window.}
puts $fp ##
puts $fp {## the main window has a menu button on top}
puts $fp {## and a scrollable canvas below.  The scrollable}
puts $fp {## canvas is used to present a graphical menu of}
puts $fp {## tilings and start patterns.}
puts $fp ##
puts $fp {pack [frame .m -border 2 -relief raised] -side top -fill x}
puts $fp {pack [frame .c] -fill both -expand true;}
puts $fp {}
puts $fp #
puts $fp {# the menu}
puts $fp #
puts $fp {pack [menubutton .m.o -text Menu -menu .m.o.m] -side left}
puts $fp {menu .m.o.m -tearoff no;}
puts $fp {.m.o.m add command  -label {About Subtile} -command about-subtile}
puts $fp {.m.o.m add separator;}
puts $fp {.m.o.m add command -label Quit -command {destroy .}}
puts $fp {}
puts $fp proc\ about-subtile\ \{\}\ \{
puts $fp {    global subtile;}
puts $fp {    about-something {About Subtile} [read-file [file join $subtile(home) README]];}
puts $fp \}
puts $fp {}
puts $fp ########################################################################
puts $fp ##
puts $fp {## tiling window.}
puts $fp {## when an initial tile or tiling is selected,}
puts $fp {## a tiling window is popped up with a menu and}
puts $fp {## the initial tiling.}
puts $fp ##
puts $fp proc\ new-subtiling\ \{\}\ \{
puts $fp {    global subtile;}
puts $fp {    set w [new-window-name];}
puts $fp {    set start $subtile(start);}
puts $fp {    set tiling $subtile(tiling);}
puts $fp {    set scale $subtile(edge);}
puts $fp {    set background $subtile(background);}
puts $fp {    set fill $subtile(fill);}
puts $fp {    set activeFill $subtile(activeFill);}
puts $fp {}
puts $fp {    upvar \#0 $w subtile;}
puts $fp {    set subtile(scale) $scale;}
puts $fp {    set subtile(overlay) 0;}
puts $fp {    set subtile(watch-tiles) 1;}
puts $fp {    set subtile(no-draw) 0;}
puts $fp {    set subtile(start) $start;}
puts $fp {    set subtile(start-tiling) $tiling;}
puts $fp {    set subtile(tiling) $tiling;}
puts $fp {    set subtile(postscript) tiling.ps;}
puts $fp {    set subtile(landscape) 0;}
puts $fp {    set subtile(colormode) gray;}
puts $fp {    set subtile(background) $background;}
puts $fp {    set subtile(fill) $fill;}
puts $fp {    set subtile(activeFill) $activeFill;}
puts $fp {}
puts $fp {    toplevel $w;}
puts $fp {    wm title $w $subtile(tiling);}
puts $fp {    pack [frame $w.m -border 2 -relief raised] -side top -fill x;}
puts $fp {    pack [menubutton $w.m.o -text Operations -menu $w.m.o.m] -side left -anchor w;}
puts $fp {    update-ops-menu $w;}
puts $fp \ \ \ \ pack\ \[canvas\ \$w.c\ \\
puts $fp \t\ \ \ \ \ \ -bg\ \$subtile(background)\ \\
puts $fp \t\ \ \ \ \ \ -width\ \[expr\ 10+\$subtile(scale)\]\ \\
puts $fp \t\ \ \ \ \ \ -height\ \[expr\ 10+\$subtile(scale)\]\ \\
puts $fp \t\ \ \ \ \ \ -xscrollincrement\ 1\ \\
puts $fp \t\ \ \ \ \ \ -yscrollincrement\ 1\ \\
puts $fp {	     ] -fill both -expand true}
puts $fp {}
puts $fp {    #}
puts $fp {    # the canvas is configured to be larger than the displayed region}
puts $fp {    # mouse button 2 allows you to push the displayed region around}
puts $fp {    # mouse button 3 allows you to rescale the displayed image}
puts $fp {    #}
puts $fp {    $w.c bind tile <Enter> "$w.c itemconfigure current -fill {$subtile(activeFill)}";}
puts $fp {    $w.c bind tile <Leave> "$w.c itemconfigure current -fill {$subtile(fill)}";}
puts $fp {    $w.c bind tile <1> "delete-tile $w";}
puts $fp {    bind $w.c <2> "scroll-mark $w %x %y";}
puts $fp {    bind $w.c <Button2-Motion> "scroll-dragto $w %x %y";}
puts $fp {    bind $w.c <3> "scale-mark $w %x %y";}
puts $fp {    bind $w.c <Button3-Motion> "scale-dragto $w %x %y";}
puts $fp {}
puts $fp {    draw-subtiling $w;}
puts $fp \}
puts $fp {}
puts $fp #
puts $fp {# rewrite the operation menu when the tiling changes}
puts $fp #
puts $fp proc\ update-ops-menu\ \{w\}\ \{
puts $fp {    global subtile;}
puts $fp {    upvar \#0 $w data;}
puts $fp {    set args $subtile($data(tiling)-ops-menu);}
puts $fp {    catch {destroy $w.m.o.m};}
puts $fp {    menu $w.m.o.m -tearoff no;}
puts $fp {    $w.m.o.m add command -label {Subdivide Tiling} -command "draw-subtiling $w";}
puts $fp {    $w.m.o.m add command -label {Reset Tiling} -command "reset-subtiling $w";}
puts $fp {    $w.m.o.m add command -label {Vertex Atlas} -command "vertex-atlas-subtiling $w";}
puts $fp {    $w.m.o.m add command -label {Fourier Map} -command "fourier-subtiling $w";}
puts $fp {    $w.m.o.m add command -label {Save Postscript} -command "save-subtiling $w";}
puts $fp {    $w.m.o.m add separator;}
puts $fp \ \ \ \ if\ \{\[llength\ \$args\]\}\ \{
puts $fp \tforeach\ arg\ \$args\ \{
puts $fp {	    set title [lindex $arg 0];}
puts $fp {	    set command [lindex $arg 1];}
puts $fp {	    $w.m.o.m add command -label $title -command "operate-subtiling $w {$command}";}
puts $fp \t\}
puts $fp {	$w.m.o.m add separator;}
puts $fp \ \ \ \ \}
puts $fp {    $w.m.o.m add checkbutton -label {Watch Tiling} -variable ${w}(watch-tiles);}
puts $fp {    $w.m.o.m add checkbutton -label {Overlay Tiling} -variable ${w}(overlay);}
puts $fp {    $w.m.o.m add separator;}
puts $fp {    $w.m.o.m add command -label Dismiss -command "destroy $w";}
puts $fp \}
puts $fp {}
puts $fp #
puts $fp {# delete or undelete tiles from the current tiling}
puts $fp #
puts $fp proc\ delete-tile\ \{w\}\ \{
puts $fp {    upvar \#0 $w subtile;}
puts $fp \ \ \ \ foreach\ tag\ \[\$w.c\ gettags\ current\]\ \{
puts $fp \tif\ \{\[regexp\ \{^t(\[0-9\]+)\$\}\ \$tag\ all\ index\]\}\ \{
puts $fp \t\ \ \ \ if\ \{\"\[\$w.c\ itemcget\ current\ -outline\]\"\ ==\ \{\}\}\ \{
puts $fp {		# undelete}
puts $fp {		$w.c itemconfigure current -fill $subtile(fill) -outline black;}
puts $fp {		set i [lsearch $subtile(deleted) $index];}
puts $fp {		set subtile(deleted) [lreplace $subtile(deleted) $i $i];}
puts $fp \t\ \ \ \ \}\ else\ \{
puts $fp {		# delete}
puts $fp {		$w.c itemconfigure current -fill {} -outline {};}
puts $fp {		lappend subtile(deleted) $index;}
puts $fp \t\ \ \ \ \}
puts $fp \t\}
puts $fp \ \ \ \ \}
puts $fp \}
puts $fp {}
puts $fp #
puts $fp {# start a new drawing}
puts $fp #
puts $fp proc\ start-tile-drawing\ \{w\}\ \{
puts $fp {    upvar \#0 $w subtile}
puts $fp \ \ \ \ if\ \{\ !\ \$subtile(no-draw)\}\ \{
puts $fp \tif\ \{\ !\ \$subtile(overlay)\}\ \{
puts $fp {	    $w.c delete all;}
puts $fp \t\}
puts $fp \ \ \ \ \}
puts $fp \}
puts $fp {}
puts $fp #
puts $fp {# draw one tile}
puts $fp #
puts $fp proc\ draw-tile\ \{w\ tags\ tile\}\ \{
puts $fp {    upvar \#0 $w subtile}
puts $fp {    set id [eval $w.c create polygon [join [lrange $tile 1 end] { }]];}
puts $fp {    $w.c itemconfigure $id -tags $tags -fill $subtile(fill) -outline black;}
puts $fp {    $w.c scale $id 0 0 $subtile(scale) $subtile(scale);}
puts $fp \ \ \ \ if\ \{\$subtile(watch-tiles)\}\ \{
puts $fp {	update;}
puts $fp \ \ \ \ \}
puts $fp \}
puts $fp {}
puts $fp #
puts $fp {# draw all the tiles in a tiling}
puts $fp #
puts $fp proc\ draw-tiling\ \{w\ tags\ tiles\}\ \{
puts $fp {    upvar \#0 $w subtile;}
puts $fp \ \ \ \ if\ \{\$subtile(no-draw)\ !=\ 1\}\ \{
puts $fp {	start-tile-drawing $w;}
puts $fp {	set n -1;}
puts $fp \tforeach\ tile\ \$tiles\ \{
puts $fp {	    draw-tile $w "$tags t[incr n]" $tile;}
puts $fp \t\}
puts $fp \ \ \ \ \}
puts $fp \}
puts $fp {}
puts $fp #
puts $fp {# evaluate without any drawing}
puts $fp #
puts $fp proc\ with-no-drawing\ \{w\ cmd\}\ \{
puts $fp {    upvar \#0 $w subtile}
puts $fp {    set save $subtile(no-draw);}
puts $fp {    set subtile(no-draw) 1;}
puts $fp \ \ \ \ if\ \{\[catch\ \{uplevel\ \$cmd\}\ result\]\}\ \{
puts $fp {	set subtile(no-draw) $save;}
puts $fp {	global errorInfo;}
puts $fp {	error $result $errorInfo;}
puts $fp \ \ \ \ \}\ else\ \{
puts $fp {	set subtile(no-draw) $save;}
puts $fp {	return $result;}
puts $fp \ \ \ \ \}
puts $fp \}
puts $fp {}
puts $fp ########################################################################
puts $fp ##
puts $fp {## user interface commands}
puts $fp ##
puts $fp proc\ reset-subtiling\ \{w\}\ \{
puts $fp {    upvar \#0 $w subtile}
puts $fp {    set subtile(tiling) $subtile(start-tiling);}
puts $fp {    wm title $w $subtile(tiling);}
puts $fp {    update-ops-menu $w;}
puts $fp {    unset subtile(current-tiling);}
puts $fp {    draw-subtiling $w;}
puts $fp \}
puts $fp {}
puts $fp proc\ draw-subtiling\ \{w\}\ \{
puts $fp {    upvar \#0 $w subtile}
puts $fp \ \ \ \ if\ \{\[info\ exists\ subtile(current-tiling)\]\}\ \{
puts $fp {	update-subtiling $w [$subtile(tiling)-make [current-subtiling $w] 1];}
puts $fp \ \ \ \ \}\ else\ \{
puts $fp {	update-subtiling $w [$subtile(tiling)-make $subtile(start) 0];}
puts $fp \ \ \ \ \}
puts $fp \ \ \ \ if\ \{\$subtile(no-draw)\ !=\ 1\ &&\ \"\$subtile(current-tiling)\"\ !=\ \{\}\}\ \{
puts $fp {	draw-tiling $w tile $subtile(current-tiling);}
puts $fp \ \ \ \ \}
puts $fp \}
puts $fp {}
puts $fp proc\ fourier-subtiling\ \{w\}\ \{
puts $fp {    upvar \#0 $w subtile}
puts $fp \ \ \ \ foreach\ tile\ \$subtile(current-tiling)\ \{
puts $fp \tforeach\ p\ \[lrange\ \$tile\ 1\ end\]\ \{
puts $fp {	    set xy($p) {};}
puts $fp \t\}
puts $fp \ \ \ \ \}
puts $fp {    exec fourier << [join [array names xy] \n] &;}
puts $fp \}
puts $fp {}
puts $fp proc\ operate-subtiling\ \{w\ command\}\ \{
puts $fp {    upvar \#0 $w subtile}
puts $fp \ \ \ \ if\ \{\[string\ match\ *-about*\ \$command\]\}\ \{
puts $fp {	$command {};}
puts $fp \ \ \ \ \}\ elseif\ \{\[info\ exists\ subtile(current-tiling)\]\}\ \{
puts $fp \twith-no-drawing\ \$w\ \{
puts $fp {	    update-subtiling $w [$command [current-subtiling $w]];}
puts $fp \t\}
puts $fp {	draw-tiling $w tile $subtile(current-tiling);}
puts $fp \ \ \ \ \}
puts $fp \}
puts $fp {}
puts $fp proc\ current-subtiling\ \{w\}\ \{
puts $fp {    upvar \#0 $w subtile}
puts $fp \ \ \ \ if\ \{\[info\ exists\ subtile(deleted)\]\}\ \{
puts $fp {	set newts {}}
puts $fp {	set i 0;}
puts $fp \tforeach\ tile\ \$subtile(current-tiling)\ \{
puts $fp \t\ \ \ \ if\ \{\[lsearch\ \$subtile(deleted)\ \$i\]\ <\ 0\}\ \{
puts $fp {		lappend newts $tile;}
puts $fp \t\ \ \ \ \}
puts $fp {	    incr i;}
puts $fp \t\}
puts $fp {	unset subtile(deleted);}
puts $fp {	return $newts;}
puts $fp \ \ \ \ \}\ else\ \{
puts $fp {	return $subtile(current-tiling);}
puts $fp \ \ \ \ \}
puts $fp \}
puts $fp {}
puts $fp proc\ update-subtiling\ \{w\ tt\}\ \{
puts $fp {    upvar \#0 $w subtile}
puts $fp {    set tiling [lindex $tt 0];}
puts $fp {    set subtile(current-tiling) [lindex $tt 1];}
puts $fp \ \ \ \ if\ \{\"\$tiling\"\ !=\ \"\$subtile(tiling)\"\}\ \{
puts $fp {	set subtile(tiling) $tiling;}
puts $fp {	wm title $w $tiling;}
puts $fp {	update-ops-menu $w;}
puts $fp \ \ \ \ \}
puts $fp \}
puts $fp {}
puts $fp proc\ save-subtiling\ \{w\}\ \{
puts $fp {    upvar \#0 $w subtile}
puts $fp {    set wp ${w}ps}
puts $fp \ \ \ \ if\ \{\[winfo\ exists\ \$wp\]\}\ \{
puts $fp {	wm deiconify $wp;}
puts $fp {	wm raise $wp;}
puts $fp \ \ \ \ \}\ else\ \{
puts $fp {	toplevel $wp;}
puts $fp {	wm title $wp "Save $subtile(tiling)";}
puts $fp {	pack [frame $wp.f0] -side top;}
puts $fp {	pack [label $wp.f0.l -text {File:}] -side left;}
puts $fp {	pack [entry $wp.f0.e -textvariable ${w}(postscript)] -side left -expand true -fill x;}
puts $fp {	pack [checkbutton $wp.landscape -text {Landscape} -variable ${w}(landscape)] -side top -anchor w;}
puts $fp {	pack [radiobutton $wp.color -text {Color} -variable ${w}(colormode) -value color] -side top -anchor w;}
puts $fp {	pack [radiobutton $wp.gray -text {Gray}  -variable ${w}(colormode) -value gray] -side top -anchor w;}
puts $fp {	pack [radiobutton $wp.mono -text {Monochrome}  -variable ${w}(colormode) -value mono] -side top -anchor w;}
puts $fp {	pack [button $wp.save -text {Save} -command "do-save-subtiling $w"] -side top;}
puts $fp \ \ \ \ \}
puts $fp \}
puts $fp {}
puts $fp proc\ do-save-subtiling\ \{w\}\ \{
puts $fp {    upvar \#0 $w subtile}
puts $fp {    $w.c postscript -file $subtile(postscript) -rotate $subtile(landscape) -colormode $subtile(colormode);}
puts $fp \}
puts $fp {}
puts $fp proc\ vertex-atlas-subtiling\ \{w\}\ \{
puts $fp {    upvar \#0 $w subtile}
puts $fp {    set tilings [vertex-atlas-tiling $subtile(current-tiling)];}
puts $fp {    #puts "reviewed vertices";}
puts $fp {    set w [new-window-name];}
puts $fp {    toplevel $w;}
puts $fp {    catalog-tilings $w "Vertex atlas of $subtile(tiling)" $subtile(tiling) $tilings;}
puts $fp \}
puts $fp {}
puts $fp ########################################################################
puts $fp #
puts $fp {# tiling catalogs.}
puts $fp {# }
puts $fp #
puts $fp {}
puts $fp #
puts $fp {# normalize a tiling collection.}
puts $fp {# the tilings are rescaled by a common factor such that the largest member}
puts $fp {# fills the unit square, and all are centered in the unit square.}
puts $fp #
puts $fp proc\ normalize-collection\ \{collection\}\ \{
puts $fp {    pset dx dy [dimension-collection $collection];}
puts $fp \ \ \ \ if\ \{\$dx\ >\ \$dy\}\ \{
puts $fp {	set s [expr 0.9/$dx]}
puts $fp \ \ \ \ \}\ else\ \{
puts $fp {	set s [expr 0.9/$dy]}
puts $fp \ \ \ \ \}
puts $fp {    return [recenter-collection [rescale-collection $s $collection]];}
puts $fp \}
puts $fp {}
puts $fp proc\ catalog-tilings\ \{w\ title\ value\ tilings\}\ \{
puts $fp \ \ \ \ if\ \{\ !\ \[winfo\ exists\ \$w.c\]\}\ \{
puts $fp {	global subtile $w;}
puts $fp {}
puts $fp \tforeach\ name\ \{no-draw\ scale\ overlay\ watch-tiles\ background\ fill\ activeFill\}\ \{
puts $fp {	    set ${w}($name) $subtile($name);}
puts $fp \t\}
puts $fp {	set ${w}(fill) white;}
puts $fp {	set ${w}(x) 5;}
puts $fp {	set ${w}(y) 5;}
puts $fp {	set ${w}(dx) [expr $subtile(scale)+10];}
puts $fp {	set ${w}(dy) [expr $subtile(scale)+10];}
puts $fp {}
puts $fp \tpack\ \[canvasview\ \$w.c\ \\
puts $fp \t\ \ -bg\ \$subtile(background)\ \\
puts $fp \t\ \ -vscroll\ 1\ \\
puts $fp \t\ \ -xscrollincrement\ 1\ \\
puts $fp \t\ \ -yscrollincrement\ 1\ \\
puts $fp {	 ] -fill both -expand true}
puts $fp {}
puts $fp {	bind $w.c <2> "scroll-mark $w %x %y";}
puts $fp {	bind $w.c <Button2-Motion> "scroll-dragto $w %x %y";}
puts $fp {	bind $w.c <3> "scale-mark $w %x %y";}
puts $fp {	bind $w.c <Button3-Motion> "scale-dragto $w %x %y";}
puts $fp \ \ \ \ \}
puts $fp {}
puts $fp {    upvar \#0 $w subtile;}
puts $fp {}
puts $fp {    # write the title for this tiling}
puts $fp {    $w.c create text $subtile(x) $subtile(y) -text $title -anchor nw -tag at$subtile(y);}
puts $fp {    set subtile(y) [expr 5+[lindex [$w.c bbox at$subtile(y)] 3]];}
puts $fp {}
puts $fp {    # draw the initial tiles for this tiling}
puts $fp {    set n [llength $tilings];}
puts $fp {    #puts "display $n tilings\n[join $tilings \n]";}
puts $fp \ \ \ \ foreach\ arg\ \[normalize-collection\ \$tilings\]\ \{
puts $fp \tif\ \{(\$n\ ==\ 4\ &&\ \$subtile(x)\ >\ 2*\$subtile(dx))\ ||\ \$subtile(x)\ >\ 3*\$subtile(dx)\}\ \{
puts $fp {	    set subtile(x) 5;}
puts $fp {	    incr subtile(y) $subtile(dy);}
puts $fp \t\}
puts $fp {	set tag "$title [lindex $arg 0]";}
puts $fp {	regsub -all { } $tag - tag;}
puts $fp {	draw-tiling $w $tag [lindex $arg 1];}
puts $fp {	$w.c move $tag $subtile(x) $subtile(y);}
puts $fp {	$w.c bind $tag <Enter> "$w.c itemconfigure current -fill {$subtile(activeFill)}";}
puts $fp {	$w.c bind $tag <Leave> "$w.c itemconfigure current -fill {$subtile(fill)}";}
puts $fp {	$w.c bind $tag <1> "set subtile(tiling) $value; set subtile(start) {[lindex $arg 1]}; new-subtiling";}
puts $fp {	incr subtile(x) $subtile(dx);}
puts $fp \ \ \ \ \}
puts $fp {    set subtile(x) 5;}
puts $fp {    incr subtile(y) $subtile(dy);}
puts $fp {    $w.c configure -scrollregion "0 0 [expr 3*$subtile(dx)+10] $subtile(y)" -width [expr 3*$subtile(dx)+10];}
puts $fp \}
puts $fp {}
puts $fp ########################################################################
puts $fp ##
puts $fp {## build the initial tiling catalog.}
puts $fp ##
puts $fp foreach\ tiling\ \$subtile(tilings)\ \{
puts $fp {    set title [lindex $tiling 0];}
puts $fp {    set value [lindex $tiling 1];}
puts $fp {    set tiles $subtile($value-start-menu);}
puts $fp {    catalog-tilings .c $title $value $tiles;}
puts $fp \}
puts $fp {}
close $fp
set restore [file join subtile tiling]
puts "creating directory $restore"
if {[catch {file mkdir $restore} error]} { puts "failed to create directory $restore" } 
set restore [file join subtile tiling ammann.tcl]
puts "restoring file $restore"
if {[catch {open $restore w} fp]} { puts "failed to create file $restore" } 
puts $fp ########################################################################
puts $fp ##
puts $fp {## Ammann tilings}
puts $fp ##
puts $fp lappend\ subtile(tilings)\ \\
puts $fp \ \ \ \ \{\{Ammann\ A2\}\ ammann-A2\}\ \\
puts $fp \ \ \ \ \{\{Ammann\ A3\}\ ammann-A3\}\ \\
puts $fp \ \ \ \ \{\{Ammann\ A4\}\ ammann-A4\}\ \\
puts $fp \ \ \ \ \{\{Ammann\ A5\ -\ square\ and\ rhomb\}\ ammann-A5\}\ \\
puts $fp {    {{Ammann A5 - triangles and rhomb } ammann-A5T};}
puts $fp {}
puts $fp {set ammann(ammann-g) [expr sqrt(2)/(1+sqrt(2))];}
puts $fp {set ammann(ammann-h) [expr 2*sin(3*$Pi/8)/(4*sin(3*$Pi/8)+2*cos(3*$Pi/8))];}
puts $fp {set ammann(ammann-i) [expr 1/(2+sqrt(2))];}
puts $fp {}
puts $fp {}
puts $fp proc\ ammann-about\ \{tiles\}\ \{
puts $fp \ \ \ \ about-something\ \{About\ Ammann\ Tilings\}\ \{
puts $fp {	The Ammann tilings are described in Gruenbaum and Shephard (1987) in}
puts $fp {	section 10.4.  The Ammann octagonal tiling, A5, is also discussed in}
puts $fp {	Senechal (1995) section 7.3.}
puts $fp {}
puts $fp {	The A3 tiling composition rule is not yet implemented.}
puts $fp {}
puts $fp {	There's an error in the	description of the A4 tiling - the tiling has}
puts $fp {	a self-similar composition rule when p/q = sqrt(2)/2, not sqrt(2).}
puts $fp {}
puts $fp {	The A5/octagonal tiling has a composition rule which requires half}
puts $fp {	squares.}
puts $fp \ \ \ \ \}
puts $fp {    return $tiles;}
puts $fp \}
puts $fp {}
puts $fp ########################################################################
puts $fp #
puts $fp {# the golden^2 A2 where p/q = r/s = Tau and r/p = sqrt(Tau)}
puts $fp #
puts $fp {set p $Tau;}
puts $fp {set q 1;}
puts $fp {set r [expr $Tau*sqrt($Tau)];}
puts $fp {set s [expr sqrt($Tau)];}
puts $fp set\ S\ \[list\ \[list\ ammann-A2-s\\
puts $fp \t\t\ \[vmake\ 0\ 0\]\\
puts $fp \t\t\ \[vmake\ \$p\ 0\]\\
puts $fp \t\t\ \[vmake\ \$p\ \$s\]\\
puts $fp \t\t\ \[vmake\ \$p+\$q\ \$s\]\\
puts $fp \t\t\ \[vmake\ \$p+\$q\ \$r+\$s\]\\
puts $fp \t\t\ \[vmake\ 0\ \$r+\$s\]\\
puts $fp {		]];}
puts $fp set\ L\ \[list\ \[list\ ammann-A2-l\\
puts $fp \t\t\ \[vmake\ 0\ 0\]\\
puts $fp \t\t\ \[vmake\ \$p+\$q\ 0\]\\
puts $fp \t\t\ \[vmake\ \$p+\$q\ \$s\]\\
puts $fp \t\t\ \[vmake\ \$p+\$q+\$p\ \$s\]\\
puts $fp \t\t\ \[vmake\ \$p+\$q+\$p\ \$r+\$s\]\\
puts $fp \t\t\ \[vmake\ 0\ \$r+\$s\]\\
puts $fp {		]];}
puts $fp set\ subtile(ammann-A2-ops-menu)\ \\
puts $fp \ \ \ \ \[list\ \\
puts $fp \t\ \{\{About\ Amman\ Tilings\}\ ammann-about\}\ \\
puts $fp {	];}
puts $fp set\ subtile(ammann-A2-start-menu)\ \\
puts $fp \ \ \ \ \[list\ \\
puts $fp \t\ \[list\ Small\ \$S\]\ \\
puts $fp \t\ \[list\ Large\ \$L\]\ \\
puts $fp {	];}
puts $fp {}
puts $fp proc\ ammann-A2-make\ \{tiles\ divide\}\ \{
puts $fp \ \ \ \ if\ \{\$divide\ ==\ 0\}\ \{
puts $fp {	return [list ammann-A2 $tiles];}
puts $fp \ \ \ \ \}\ else\ \{
puts $fp {	return [list ammann-A2 [ammann-A2-dissect $tiles]];}
puts $fp \ \ \ \ \}
puts $fp \}
puts $fp proc\ ammann-A2-dissect\ \{tiles\}\ \{
puts $fp {    global Tau;}
puts $fp {    set newt {};}
puts $fp \ \ \ \ foreach\ t1\ \$tiles\ \{
puts $fp {	set type [lindex $t1 0];}
puts $fp {	set a [lindex $t1 1];}
puts $fp {	set b [lindex $t1 2];}
puts $fp {	set c [lindex $t1 3];}
puts $fp {	set d [lindex $t1 4];}
puts $fp {	set e [lindex $t1 5];}
puts $fp {	set f [lindex $t1 6];}
puts $fp \tswitch\ -exact\ \$type\ \{
puts $fp \t\ \ \ \ ammann-A2-s\ \{
puts $fp {		set p [vadd $c [vscale 1/$Tau [vsub $c $d]]];}
puts $fp {		set q [vadd $a [vscale 1/$Tau [vsub $f $a]]];}
puts $fp {		set r [vadd $p [vscale 1/$Tau [vsub $c $b]]];}
puts $fp \t\tlappend\ newt\\
puts $fp \t\t\ \ \ \ \[list\ ammann-A2-s\ \$q\ \$r\ \$p\ \$c\ \$b\ \$a\]\\
puts $fp {		    [list ammann-A2-l $d $p $r $q $f $e];}
puts $fp \t\ \ \ \ \}
puts $fp \t\ \ \ \ ammann-A2-l\ \{
puts $fp {		set q [vadd $f [vscale 1/$Tau [vsub $a $f]]];}
puts $fp {		set p [vadd $q [vscale 1/$Tau [vsub $d $c]]];}
puts $fp {		set r [vadd $p [vscale 1/$Tau [vsub $c $b]]];}
puts $fp {		set s [vadd $r [vsub [vsub $d $c] [vsub $p $q]]];}
puts $fp {		set t [vadd $b [vsub $f $q]];}
puts $fp {		set u [vadd $f [vsub $d $c]];}
puts $fp \t\tlappend\ newt\\
puts $fp \t\t\ \ \ \ \[list\ ammann-A2-s\ \$q\ \$p\ \$r\ \$s\ \$u\ \$f\]\\
puts $fp \t\t\ \ \ \ \[list\ ammann-A2-l\ \$d\ \$c\ \$t\ \$s\ \$u\ \$e\]\\
puts $fp {		    [list ammann-A2-l $t $r $p $q $a $b];}
puts $fp \t\ \ \ \ \}
puts $fp \t\ \ \ \ default\ \{
puts $fp {		error "unknown tile type $type";}
puts $fp \t\ \ \ \ \}
puts $fp \t\}
puts $fp \ \ \ \ \}
puts $fp {    return $newt;}
puts $fp \}
puts $fp ########################################################################
puts $fp #
puts $fp {# The A3 tiling from G&S.}
puts $fp {# the dissection is not done yet.}
puts $fp #
puts $fp {set Tau2 [expr $Tau*$Tau];}
puts $fp {set Tau3 [expr $Tau2*$Tau];}
puts $fp set\ A\ \[list\ \[list\ ammann-A3-a\\
puts $fp \t\t\ \[vmake\ 0\ 1+\$Tau\]\\
puts $fp \t\t\ \[vmake\ 0\ 1\]\\
puts $fp \t\t\ \[vmake\ \$Tau\ 1\]\\
puts $fp \t\t\ \[vmake\ \$Tau\ 0\]\\
puts $fp \t\t\ \[vmake\ \$Tau3\ 0\]\\
puts $fp {		 [vmake $Tau3 $Tau2]]];}
puts $fp set\ B\ \[list\ \[list\ ammann-A3-b\\
puts $fp \t\t\ \[vmake\ 0\ \$Tau3\]\\
puts $fp \t\t\ \[vmake\ 0\ \$Tau\]\\
puts $fp \t\t\ \[vmake\ \$Tau2\ \$Tau\]\\
puts $fp \t\t\ \[vmake\ \$Tau2\ 0\]\\
puts $fp \t\t\ \[vmake\ \$Tau3\ 0\]\\
puts $fp \t\t\ \[vmake\ \$Tau3\ \$Tau2\]\\
puts $fp \t\t\ \[vmake\ 2*\$Tau2\ \$Tau2\]\\
puts $fp {		 [vmake 2*$Tau2 $Tau3]]];}
puts $fp set\ C\ \[list\ \[list\ ammann-A3-c\\
puts $fp \t\t\ \[vmake\ \$Tau-1\ \$Tau3\]\\
puts $fp \t\t\ \[vmake\ \$Tau-1\ \$Tau2\]\\
puts $fp \t\t\ \[vmake\ 0\ \$Tau2\]\\
puts $fp \t\t\ \[vmake\ 0\ \$Tau\]\\
puts $fp \t\t\ \[vmake\ \$Tau\ \$Tau\]\\
puts $fp \t\t\ \[vmake\ \$Tau\ 0\]\\
puts $fp \t\t\ \[vmake\ 2*\$Tau\ 0\]\\
puts $fp \t\t\ \[vmake\ 2*\$Tau\ \$Tau2\]\\
puts $fp \t\t\ \[vmake\ 2*\$Tau+1\ \$Tau2\]\\
puts $fp {		 [vmake 2*$Tau+1 $Tau3]]];}
puts $fp set\ subtile(ammann-A3-ops-menu)\ \\
puts $fp \ \ \ \ \[list\ \\
puts $fp \t\ \{\{About\ Amman\ Tilings\}\ ammann-about\}\ \\
puts $fp {	];}
puts $fp {}
puts $fp set\ subtile(ammann-A3-start-menu)\ \\
puts $fp \ \ \ \ \[list\ \\
puts $fp \t\ \[list\ Small\ \$A\]\ \\
puts $fp \t\ \[list\ Medium\ \$C\]\ \\
puts $fp \t\ \[list\ Large\ \$B\]\ \\
puts $fp {	];}
puts $fp {}
puts $fp proc\ ammann-A3-make\ \{tiles\ divide\}\ \{
puts $fp \ \ \ \ if\ \{\$divide\ ==\ 0\}\ \{
puts $fp {	return [list ammann-A3 $tiles];}
puts $fp \ \ \ \ \}\ else\ \{
puts $fp {	return [list ammann-A3 [ammann-A3-dissect $tiles]];}
puts $fp \ \ \ \ \}
puts $fp \}
puts $fp {}
puts $fp {# this isn't done, yet}
puts $fp proc\ ammann-A3-dissect\ \{tiles\}\ \{
puts $fp {    global Tau;}
puts $fp {    set newt {};}
puts $fp \ \ \ \ foreach\ t1\ \$tiles\ \{
puts $fp {	set type [lindex $t1 0];}
puts $fp {	set a [lindex $t1 1];}
puts $fp {	set b [lindex $t1 2];}
puts $fp {	set c [lindex $t1 3];}
puts $fp {	set d [lindex $t1 4];}
puts $fp {	set e [lindex $t1 5];}
puts $fp {	set f [lindex $t1 6];}
puts $fp \tswitch\ -exact\ \$type\ \{
puts $fp \t\ \ \ \ ammann-A3-a\ \{
puts $fp {		set g [vadd $e [vsub $b $c]];}
puts $fp {		set h [vadd $f [vsub $d $g]];}
puts $fp {		set j [vadd $g [vsub $a $b]];}
puts $fp {		set i [vadd $h [vsub $d $c]];}
puts $fp {		lappend newt [list ammann-A3-b $a $b $c $d $g $j $i $h];}
puts $fp {		lappend newt [list ammann-A3-a $f $h $i $j $g $e];}
puts $fp \t\ \ \ \ \}
puts $fp \t\ \ \ \ ammann-A3-b\ \{
puts $fp {		# remaining input vertices}
puts $fp {		set g [lindex $t1 7];}
puts $fp {		set h [lindex $t1 8];}
puts $fp {		# new vertices}
puts $fp {		set i [vadd $c [vsub $d $e]];}
puts $fp {		set k [vadd $a [vsub $e $d]];}
puts $fp {		set m [vadd $k [vsub $d $c]];}
puts $fp {		set j [vadd $k [vsub $i $b]];}
puts $fp {		set o [vadd $f [vsub $k $j]];}
puts $fp {		set l [vsum $i [vsub $a $b] [vsub $m $k]];}
puts $fp {		set p [vsum $j [vsub $b $a] [vsub $k $m]];}
puts $fp {		set n [vsum $o [vsub $e $f] [vsub $c $d]];}
puts $fp {		set r [vadd $p [vsub $j $k]];}
puts $fp {		set q [vsum $r [vsub $j $p] [vsub $g $h]];}
puts $fp {		lappend newt [list ammann-A3-a $b $i $l $m $k $a];}
puts $fp {		lappend newt [list ammann-A3-c $n $o $q $r $p $j $k $m $l $i];}
puts $fp {		lappend newt [list ammann-A3-a $f $o $n $c $d $e];}
puts $fp {		lappend newt [list ammann-A3-a $j $p $r $q $g $h];}
puts $fp \t\ \ \ \ \}
puts $fp \t\ \ \ \ ammann-A3-c\ \{
puts $fp {		# remaining input vertices}
puts $fp {		set g [lindex $t1 7];}
puts $fp {		set h [lindex $t1 8];}
puts $fp {		set i [lindex $t1 9];}
puts $fp {		set j [lindex $t1 10];}
puts $fp {		# new vertices}
puts $fp {		set k [vadd $a [vscale 0.5 [vadd [vsub $j $a] [vsub $f $g]]]];}
puts $fp {		set l [vadd $k [vsub $d $c]];}
puts $fp {		set m [vsum $l [vsub $k $a]];}
puts $fp {		set n [vsum $m [vsub $i $j] [vsub $k $l]];}
puts $fp {		set o [vadd $h [vsub $a $k]];}
puts $fp {		set p [vsum $e [vsub $g $f] [vsub $o $h]];}
puts $fp {		lappend newt [list ammann-A3-c $p $o $n $m $l $k $a $b $c $d];}
puts $fp {		lappend newt [list ammann-A3-a $h $o $p $e $f $g];}
puts $fp {		lappend newt [list ammann-A3-a $k $l $m $n $i $j];}
puts $fp \t\ \ \ \ \}
puts $fp \t\ \ \ \ default\ \{
puts $fp {		error "unknown tile type $type";}
puts $fp \t\ \ \ \ \}
puts $fp \t\}
puts $fp \ \ \ \ \}
puts $fp {    return $newt;}
puts $fp \}
puts $fp {	    }
puts $fp ########################################################################
puts $fp #
puts $fp {# the block and key (?) tiling}
puts $fp #
puts $fp {# there appears to be a repeated error in Gruenbaum and Shephard}
puts $fp {# that claims this tiling has a self similar composition when p/q = sqrt(2),}
puts $fp {# but it really should be p/q = sqrt(2)/2.}
puts $fp #
puts $fp {set p $Sqrt2/2;}
puts $fp {set q 1;}
puts $fp set\ S\ \[list\ \[list\ ammann-A4-s\\
puts $fp \t\t\ \[vmake\ 0\ \$p+\$q+\$p\]\\
puts $fp \t\t\ \[vmake\ 0\ \$p\]\\
puts $fp \t\t\ \[vmake\ \$q\ \$p\]\\
puts $fp \t\t\ \[vmake\ \$q\ 0\]\\
puts $fp \t\t\ \[vmake\ \$q+\$p\ 0\]\\
puts $fp {		 [vmake $q+$p $p+$q+$p]]];}
puts $fp set\ L\ \[list\ \[list\ ammann-A4-l\\
puts $fp \t\t\ \[vmake\ 0\ \$p+\$q+\$p\]\\
puts $fp \t\t\ \[vmake\ 0\ \$p\]\\
puts $fp \t\t\ \[vmake\ \$p\ \$p\]\\
puts $fp \t\t\ \[vmake\ \$p\ 0\]\\
puts $fp \t\t\ \[vmake\ \$p+\$q+\$p\ 0\]\\
puts $fp \t\t\ \[vmake\ \$p+\$q+\$p\ \$p+\$q\]\\
puts $fp \t\t\ \[vmake\ \$p+\$q\ \$p+\$q\]\\
puts $fp {		 [vmake $p+$q $p+$q+$p]]];}
puts $fp set\ subtile(ammann-A4-ops-menu)\ \\
puts $fp \ \ \ \ \[list\ \\
puts $fp \t\ \{\{About\ Amman\ Tilings\}\ ammann-about\}\ \\
puts $fp {	];}
puts $fp set\ subtile(ammann-A4-start-menu)\ \\
puts $fp \ \ \ \ \[list\ \\
puts $fp \t\ \[list\ Small\ \$S\]\ \\
puts $fp \t\ \[list\ Large\ \$L\]\ \\
puts $fp {	];}
puts $fp {}
puts $fp proc\ ammann-A4-make\ \{tiles\ divide\}\ \{
puts $fp \ \ \ \ if\ \{\$divide\ ==\ 0\}\ \{
puts $fp {	return [list ammann-A4 $tiles];}
puts $fp \ \ \ \ \}\ else\ \{
puts $fp {	return [list ammann-A4 [ammann-A4-dissect $tiles]];}
puts $fp \ \ \ \ \}
puts $fp \}
puts $fp {}
puts $fp proc\ ammann-A4-dissect\ \{tiles\}\ \{
puts $fp {    global Sqrt2;}
puts $fp {    set newt {};}
puts $fp \ \ \ \ foreach\ t1\ \$tiles\ \{
puts $fp {	set type [lindex $t1 0];}
puts $fp {	set a [lindex $t1 1];}
puts $fp {	set b [lindex $t1 2];}
puts $fp {	set c [lindex $t1 3];}
puts $fp {	set d [lindex $t1 4];}
puts $fp {	set e [lindex $t1 5];}
puts $fp {	set f [lindex $t1 6];}
puts $fp \tswitch\ -exact\ \$type\ \{
puts $fp \t\ \ \ \ ammann-A4-s\ \{
puts $fp {		# basic edges in subdivided tile}
puts $fp {		set pqh [vsub $e $d];}
puts $fp {		set pqv [vsub $d $c];}
puts $fp {		set ph [vsub [vsub $f $a] [vscale 2 $pqh]];}
puts $fp {		set pv [vsub [vsub $b $a] [vscale 2 $pqv]];}
puts $fp {		# clockwise from a around the edge}
puts $fp {		set p [vadd $a $pqv];}
puts $fp {		set q [vadd $b $pqh];}
puts $fp {		set s [vadd $f $pqv];}
puts $fp {		set r [vadd $s $pqv];}
puts $fp {		set t [vadd $a $pqh];}
puts $fp {		# jogs in}
puts $fp {		set p1 [vadd $p $ph];}
puts $fp {		set p11 [vadd $p1 $pv];}
puts $fp {		set q1 [vsub $q $pqv];}
puts $fp {		set q2 [vadd $q $pqh]}
puts $fp {		set r1 [vsub $r $ph];}
puts $fp {		set s1 [vsub $s $pqh];}
puts $fp {		set t1 [vadd $t $pv];}
puts $fp {		set t11 [vadd $t1 $ph];}
puts $fp {		lappend newt [list ammann-A4-s $q $q1 $p11 $p1 $p $b];}
puts $fp {		lappend newt [list ammann-A4-s $d $c $q2 $r1 $r $e];}
puts $fp {		lappend newt [list ammann-A4-s $s $s1 $t11 $t1 $t $f];}
puts $fp {		lappend newt [list ammann-A4-l $a $p $p1 $p11 [vadd $p11 $pqh] $t11 $t1 $t];}
puts $fp {		lappend newt [list ammann-A4-l $q $q2 $r1 $r $s $s1 [vadd $p11 $pqh] $q1];}
puts $fp \t\ \ \ \ \}
puts $fp \t\ \ \ \ ammann-A4-l\ \{
puts $fp {		# remaining input vertices}
puts $fp {		set g [lindex $t1 7];}
puts $fp {		set h [lindex $t1 8];}
puts $fp {		# basic edges in subdivided tiles}
puts $fp {		set pqh [vsub $c $b];}
puts $fp {		set pqv [vsub $d $c];}
puts $fp {		set ph [vsub [vsub $e $d] [vscale 2 $pqh]];}
puts $fp {		set pv [vsub [vsub $b $a] [vscale 2 $pqv]];}
puts $fp {		# clockwise from a around the edge}
puts $fp {		set p [vadd $a $pqv];}
puts $fp {		set q [vsub $e $pqh];}
puts $fp {		set r [vsub $e $pqv];}
puts $fp {		set s [vadd $a $pqh];}
puts $fp {		# jogs in from from edge}
puts $fp {		set p1 [vadd $p $ph];}
puts $fp {		set p11 [vadd $p1 $pv];}
puts $fp {		set c1 [vsub $c $pqv];}
puts $fp {		set c2 [vadd $c $pqh];}
puts $fp {		set q1 [vsub $q $pv];}
puts $fp {		set q11 [vsub $q1 $ph];}
puts $fp {		set r1 [vsub $r $ph];}
puts $fp {		set r11 [vsub $r1 $pv];}
puts $fp {		set g1 [vadd $g $pqv];}
puts $fp {		set g2 [vsub $g $pqh];}
puts $fp {		set s1 [vadd $s $pv];}
puts $fp {		set s11 [vadd $s1 $ph];}
puts $fp {		lappend newt [list ammann-A4-s $c $c1 $p11 $p1 $p $b];}
puts $fp {		lappend newt [list ammann-A4-s $c $c2 $q11 $q1 $q $d];}
puts $fp {		lappend newt [list ammann-A4-s $g $g2 $s11 $s1 $s $h];}
puts $fp {		lappend newt [list ammann-A4-s $g $g1 $r11 $r1 $r $f];}
puts $fp {		lappend newt [list ammann-A4-l $a $p $p1 $p11 [vadd $p11 $pqh] $s11 $s1 $s];}
puts $fp {		lappend newt [list ammann-A4-l $e $r $r1 $r11 [vsub $r11 $pqh] $q11 $q1 $q];}
puts $fp {		lappend newt [list ammann-A4-l $c $c2 [vsub $r11 $pqh] $g1 $g $g2 [vadd $p11 $pqh] $c1];}
puts $fp \t\ \ \ \ \}
puts $fp \t\ \ \ \ default\ \{
puts $fp {		error "unknown tile type $type";}
puts $fp \t\ \ \ \ \}
puts $fp \t\}
puts $fp \ \ \ \ \}
puts $fp {    return $newt;}
puts $fp \}
puts $fp {}
puts $fp ########################################################################
puts $fp #
puts $fp {# the octagonal tiling}
puts $fp #
puts $fp set\ r\ \[list\ \[list\ ammann-A5-r\\
puts $fp \t\t\ \[vmake\ 0\ sin(3*\$Pi/8)\]\\
puts $fp \t\t\ \[vmake\ cos(3*\$Pi/8)\ 0\]\\
puts $fp \t\t\ \[vmake\ 2*cos(3*\$Pi/8)\ sin(3*\$Pi/8)\]\\
puts $fp {		 [vmake cos(3*$Pi/8) 2*sin(3*$Pi/8)]]];}
puts $fp set\ s\ \[list\ \[list\ ammann-A5-s\\
puts $fp \t\t\ \[vmake\ 0\ \$Sqrt2/2\]\\
puts $fp \t\t\ \[vmake\ \$Sqrt2/2\ \$Sqrt2\]\\
puts $fp \t\t\ \[vmake\ \$Sqrt2\ \$Sqrt2/2\]\\
puts $fp \t\t\ \[vmake\ \$Sqrt2/2\ 0\]\\
puts $fp {		]];}
puts $fp set\ subtile(ammann-A5-ops-menu)\ \\
puts $fp \ \ \ \ \[list\ \\
puts $fp \t\ \{\{About\ Amman\ Tilings\}\ ammann-about\}\ \\
puts $fp \t\ \{\{Convert\ to\ triangles\ and\ rhomb\}\ ammann-do-A5-dissect-to-A5T\}\ \\
puts $fp {	];}
puts $fp set\ subtile(ammann-A5-start-menu)\ \\
puts $fp \ \ \ \ \[list\ \\
puts $fp \t\ \[list\ Rhomb\ \$r\]\ \\
puts $fp \t\ \[list\ Square\ \$s\]\ \\
puts $fp {	];}
puts $fp {}
puts $fp proc\ ammann-do-A5-dissect-to-A5T\ \{tiles\}\ \{
puts $fp {    return [list ammann-A5T [ammann-A5-dissect-to-A5T $tiles]];}
puts $fp \}
puts $fp proc\ ammann-A5-make\ \{tiles\ divide\}\ \{
puts $fp \ \ \ \ if\ \{\$divide\ ==\ 0\}\ \{
puts $fp {	return [list ammann-A5 $tiles];}
puts $fp \ \ \ \ \}\ else\ \{
puts $fp {	return [list ammann-A5 [ammann-A5T-anneal-to-A5 [ammann-A5T-dissect [ammann-A5-dissect-to-A5T $tiles]]]];}
puts $fp \ \ \ \ \}
puts $fp \}
puts $fp proc\ ammann-A5-dissect-to-A5T\ \{tiles\}\ \{
puts $fp {    set newt {};}
puts $fp \ \ \ \ foreach\ t1\ \$tiles\ \{
puts $fp {	set type [lindex $t1 0];}
puts $fp \tswitch\ -exact\ \$type\ \{
puts $fp \t\ \ \ \ ammann-A5-r\ \{
puts $fp {		lappend newt $t1;}
puts $fp \t\ \ \ \ \}
puts $fp \t\ \ \ \ ammann-A5-s\ \{
puts $fp {		set a [lindex $t1 1];}
puts $fp {		set b [lindex $t1 2];}
puts $fp {		set c [lindex $t1 3];}
puts $fp {		set d [lindex $t1 4];}
puts $fp \t\tlappend\ newt\\
puts $fp \t\t\ \ \ \ \[list\ ammann-A5T-tL\ \$a\ \$b\ \$d\]\\
puts $fp {		    [list ammann-A5T-tR $c $b $d];}
puts $fp \t\ \ \ \ \}
puts $fp \t\}
puts $fp \ \ \ \ \}
puts $fp {    return $newt;}
puts $fp \}
puts $fp {}
puts $fp set\ r\ \[list\ \[list\ ammann-A5-r\\
puts $fp \t\t\ \[vmake\ 0\ sin(3*\$Pi/8)\]\\
puts $fp \t\t\ \[vmake\ cos(3*\$Pi/8)\ 0\]\\
puts $fp \t\t\ \[vmake\ 2*cos(3*\$Pi/8)\ sin(3*\$Pi/8)\]\\
puts $fp {		 [vmake cos(3*$Pi/8) 2*sin(3*$Pi/8)]]];}
puts $fp set\ tL\ \[list\ \[list\ ammann-A5T-tL\\
puts $fp \t\t\ \ \[vmake\ 0\ \$Sqrt2/2\]\\
puts $fp \t\t\ \ \[vmake\ \$Sqrt2/2\ \$Sqrt2\]\\
puts $fp \t\t\ \ \[vmake\ \$Sqrt2/2\ 0\]\\
puts $fp {		 ]];}
puts $fp set\ tR\ \[list\ \[list\ ammann-A5T-tR\\
puts $fp \t\t\ \ \[vmake\ \$Sqrt2\ \$Sqrt2/2\]\\
puts $fp \t\t\ \ \[vmake\ \$Sqrt2/2\ \$Sqrt2\]\\
puts $fp \t\t\ \ \[vmake\ \$Sqrt2/2\ 0\]\\
puts $fp {		 ]];}
puts $fp set\ subtile(ammann-A5T-ops-menu)\ \\
puts $fp \ \ \ \ \[list\ \\
puts $fp \t\ \{\{About\ Amman\ Tilings\}\ ammann-about\}\ \\
puts $fp \t\ \{\{Anneal\ to\ A5\ square\ and\ rhomb\}\ ammann-do-A5T-anneal-to-A5\}\ \\
puts $fp {	];}
puts $fp set\ subtile(ammann-A5T-start-menu)\ \\
puts $fp \ \ \ \ \[list\ \\
puts $fp \t\ \[list\ Rhomb\ \$r\]\ \\
puts $fp \t\ \[list\ \{Left\ half-square\}\ \$tL\]\ \\
puts $fp \t\ \[list\ \{Right\ half-square\}\ \$tR\]\ \\
puts $fp {	];}
puts $fp {}
puts $fp proc\ ammann-do-A5T-anneal-to-A5\ \{tiles\}\ \{
puts $fp {    return [list ammann-A5 [ammann-A5T-anneal-to-A5 $tiles]];}
puts $fp \}
puts $fp proc\ ammann-A5T-make\ \{tiles\ divide\}\ \{
puts $fp \ \ \ \ if\ \{\$divide\ ==\ 0\}\ \{
puts $fp {	return [list ammann-A5T $tiles];}
puts $fp \ \ \ \ \}\ else\ \{
puts $fp {	return [list ammann-A5T [ammann-A5T-dissect $tiles]];}
puts $fp \ \ \ \ \}
puts $fp \}
puts $fp proc\ ammann-A5T-dissect\ \{tiles\}\ \{
puts $fp {    set newt {};}
puts $fp \ \ \ \ foreach\ t1\ \$tiles\ \{
puts $fp {	set type [lindex $t1 0];}
puts $fp {	set a [lindex $t1 1];}
puts $fp {	set b [lindex $t1 2];}
puts $fp {	set c [lindex $t1 3];}
puts $fp \tswitch\ -exact\ \$type\ \{
puts $fp \t\ \ \ \ ammann-A5-r\ \{
puts $fp {		set d [lindex $t1 4];}
puts $fp {		upvar \#0 ammann(ammann-g) g;}
puts $fp {		upvar \#0 ammann(ammann-h) h;}
puts $fp {		set p [vadd $a [vscale $g [vsub $b $a]]];}
puts $fp {		set q [vadd $c [vscale $g [vsub $b $c]]];}
puts $fp {		set r [vadd $c [vscale $g [vsub $d $c]]];}
puts $fp {		set s [vadd $a [vscale $g [vsub $d $a]]];}
puts $fp {		set t [vadd $b [vscale $h [vsub $d $b]]];}
puts $fp {		set u [vadd $d [vscale $h [vsub $b $d]]];}
puts $fp \t\tlappend\ newt\\
puts $fp \t\t\ \ \ \ \[list\ ammann-A5-r\ \$p\ \$b\ \$q\ \$t\]\\
puts $fp \t\t\ \ \ \ \[list\ ammann-A5-r\ \$t\ \$c\ \$u\ \$a\]\\
puts $fp \t\t\ \ \ \ \[list\ ammann-A5-r\ \$s\ \$u\ \$r\ \$d\]\\
puts $fp \t\t\ \ \ \ \[list\ ammann-A5T-tR\ \$t\ \$p\ \$a\]\\
puts $fp \t\t\ \ \ \ \[list\ ammann-A5T-tL\ \$u\ \$s\ \$a\]\\
puts $fp \t\t\ \ \ \ \[list\ ammann-A5T-tL\ \$t\ \$q\ \$c\]\\
puts $fp {		    [list ammann-A5T-tR $u $r $c];}
puts $fp \t\ \ \ \ \}
puts $fp {	    ammann-A5T-tL -}
puts $fp \t\ \ \ \ ammann-A5T-tR\ \{
puts $fp \t\tif\ \{\"\$type\"\ ==\ \{ammann-A5T-tL\}\}\ \{
puts $fp {		    set othertype ammann-A5T-tR;}
puts $fp \t\t\}\ else\ \{
puts $fp {		    set othertype ammann-A5T-tL;}
puts $fp \t\t\}
puts $fp {		upvar \#0 ammann(ammann-g) g;}
puts $fp {		upvar \#0 ammann(ammann-h) h;}
puts $fp {		upvar \#0 ammann(ammann-i) i;}
puts $fp {		set p [vadd $b [vscale $g [vsub $a $b]]];}
puts $fp {		set q [vadd $b [vscale $i [vsub $c $b]]];}
puts $fp {		set r [vadd $c [vscale $i [vsub $b $c]]];}
puts $fp {		set s [vadd $a [vscale $g [vsub $c $a]]];}
puts $fp {		set t [vadd $r [vsub $s $c]];}
puts $fp \t\tlappend\ newt\\
puts $fp \t\t\ \ \ \ \[list\ ammann-A5-r\ \$p\ \$a\ \$t\ \$q\]\\
puts $fp \t\t\ \ \ \ \[list\ ammann-A5-r\ \$r\ \$t\ \$s\ \$c\]\\
puts $fp \t\t\ \ \ \ \[list\ \$type\ \$t\ \$r\ \$q\]\\
puts $fp \t\t\ \ \ \ \[list\ \$othertype\ \$q\ \$p\ \$b\]\\
puts $fp {		    [list $othertype $t $s $a];}
puts $fp \t\ \ \ \ \}
puts $fp \t\ \ \ \ default\ \{
puts $fp {		error "unknown tile type $type";}
puts $fp \t\ \ \ \ \}
puts $fp \t\}
puts $fp \ \ \ \ \}
puts $fp {    return $newt;}
puts $fp \}
puts $fp proc\ ammann-A5T-anneal-to-A5\ \{tiles\}\ \{
puts $fp {    set newt {};}
puts $fp \ \ \ \ foreach\ t1\ \$tiles\ \{
puts $fp \tswitch\ \[lindex\ \$t1\ 0\]\ \{
puts $fp \t\ \ \ \ ammann-A5-r\ \{
puts $fp {		lappend newt $t1;}
puts $fp \t\ \ \ \ \}
puts $fp \t\ \ \ \ ammann-A5T-tL\ \{
puts $fp {		set point [lindex $t1 2],[lindex $t1 3];}
puts $fp \t\tif\ \{\[info\ exists\ t(\$point)\]\}\ \{
puts $fp {		    set t2 [lindex $t($point) 0];}
puts $fp {		    lappend newt [list ammann-A5-s [lindex $t1 1] [lindex $t1 2] [lindex $t2 1] [lindex $t2 3]];}
puts $fp {		    unset t($point);}
puts $fp \t\t\}\ else\ \{
puts $fp {		    lappend t($point) $t1;}
puts $fp \t\t\}
puts $fp \t\ \ \ \ \}
puts $fp \t\ \ \ \ ammann-A5T-tR\ \{
puts $fp {		set point [lindex $t1 2],[lindex $t1 3];}
puts $fp \t\tif\ \{\[info\ exists\ t(\$point)\]\}\ \{
puts $fp {		    set t2 [lindex $t($point) 0];}
puts $fp {		    lappend newt [list ammann-A5-s [lindex $t2 1] [lindex $t2 2] [lindex $t1 1] [lindex $t1 3]];}
puts $fp {		    unset t($point);}
puts $fp \t\t\}\ else\ \{
puts $fp {		    lappend t($point) $t1;}
puts $fp \t\t\}
puts $fp \t\ \ \ \ \}
puts $fp \t\}
puts $fp \ \ \ \ \}
puts $fp {    return $newt;}
puts $fp \}
puts $fp {}
puts $fp {}
close $fp
set restore [file join subtile tiling binary.tcl]
puts "restoring file $restore"
if {[catch {open $restore w} fp]} { puts "failed to create file $restore" } 
puts $fp ########################################################################
puts $fp ##
puts $fp {## binary prototiles}
puts $fp ##
puts $fp {lappend subtile(tilings) {Binary binary};}
puts $fp {}
puts $fp {set binary(binary-d1) [vmake sqrt(2+$Tau) 0];}
puts $fp {set binary(binary-a1) [rmake $Pi/10];}
puts $fp {set binary(binary-a2) [rmake -$Pi/10];}
puts $fp {}
puts $fp {set c [vmake cos($Pi/5) sin($Pi/5)];}
puts $fp {set e [vmake cos(2*$Pi/5) sin(2*$Pi/5)];}
puts $fp {set t [list [list binary-t {0 0} {1.5 0} [vscale 1.5 [vadd 1 $c]] [vscale 1.5 $c]]];}
puts $fp {set T [list [list binary-T {0 0} {1.5 0} [vscale 1.5 [vadd 1 $e]] [vscale 1.5 $e]]];}
puts $fp {set subtile(binary-ops-menu) {};}
puts $fp set\ subtile(binary-start-menu)\ \\
puts $fp \ \ \ \ \[list\ \\
puts $fp \t\ \[list\ \{Thick\ rhomb\}\ \$T\]\ \\
puts $fp \t\ \[list\ \{Thin\ rhomb\}\ \$t\]\ \\
puts $fp {	];}
puts $fp {}
puts $fp proc\ binary-make\ \{tiles\ divide\}\ \{
puts $fp \ \ \ \ if\ \{\$divide\ ==\ 0\}\ \{
puts $fp {	return [list binary $tiles];}
puts $fp \ \ \ \ \}\ else\ \{
puts $fp {	set newt {};}
puts $fp \tforeach\ t1\ \$tiles\ \{
puts $fp {	    eval lappend newt [eval binary-dissect $t1];}
puts $fp \t\}
puts $fp {	return [list binary $newt];}
puts $fp \ \ \ \ \}
puts $fp \}
puts $fp {}
puts $fp proc\ binary-dissect\ \{type\ a\ b\ c\ d\}\ \{
puts $fp \ \ \ \ switch\ -exact\ \$type\ \{
puts $fp \tbinary-t\ \{
puts $fp {	    upvar \#0 binary(binary-d1) d1;}
puts $fp {	    upvar \#0 binary(binary-a1) a1}
puts $fp {	    upvar \#0 binary(binary-a2) a2}
puts $fp {	    set w [vadd $a [vrotate $a2 [vscale 1/$d1 [vsub $b $a]]]];}
puts $fp {	    set y [vadd $a [vrotate $a1 [vscale 1/$d1 [vsub $d $a]]]];}
puts $fp {	    set z [vsub [vadd $w $y] $a];}
puts $fp {	    set u [vsub [vadd $z $d] $y];}
puts $fp \t\ \ \ \ return\ \[list\\
puts $fp \t\t\t\[list\ binary-T\ \$z\ \$y\ \$a\ \$w\]\\
puts $fp \t\t\t\[list\ binary-t\ \ \$w\ \$b\ \$u\ \$z\]\\
puts $fp \t\t\t\[list\ binary-t\ \ \$u\ \$d\ \$y\ \$z\]\\
puts $fp {		       ];}
puts $fp \t\}
puts $fp \tbinary-T\ \{
puts $fp {	    upvar \#0 binary(binary-d1) d1;}
puts $fp {	    upvar \#0 binary(binary-a1) a1}
puts $fp {	    upvar \#0 binary(binary-a2) a2}
puts $fp {	    set w [vadd $a [vrotate $a2 [vscale 1/$d1 [vsub $b $a]]]];}
puts $fp {	    set y [vadd $a [vrotate $a2 [vscale 1/$d1 [vsub $d $a]]]];}
puts $fp {	    set z [vsub [vadd $w $y] $a];}
puts $fp {	    set u [vsub [vadd $z $d] $y];}
puts $fp {	    set v [vsub [vadd $b $z] $w];}
puts $fp \t\ \ \ \ return\ \[list\\
puts $fp \t\t\t\[list\ binary-T\ \$z\ \$y\ \$a\ \$w\]\\
puts $fp \t\t\t\[list\ binary-T\ \$z\ \$u\ \$d\ \$y\]\\
puts $fp \t\t\t\[list\ binary-T\ \$z\ \$v\ \$c\ \$u\]\\
puts $fp \t\t\t\[list\ binary-t\ \ \$w\ \$b\ \$v\ \$z\]\\
puts $fp {		       ];}
puts $fp \t\}
puts $fp \tdefault\ \{
puts $fp {	    error "unknown tile type $type";}
puts $fp \t\}
puts $fp \ \ \ \ \}
puts $fp \}
puts $fp {}
puts $fp {}
close $fp
set restore [file join subtile tiling chair.tcl]
puts "restoring file $restore"
if {[catch {open $restore w} fp]} { puts "failed to create file $restore" } 
puts $fp ########################################################################
puts $fp ##
puts $fp {## Chair tiling}
puts $fp ##
puts $fp {lappend subtile(tilings) {Chair chair};}
puts $fp {}
puts $fp {set subtile(chair-ops-menu) {};}
puts $fp {}
puts $fp set\ subtile(chair-start-menu)\ \\
puts $fp \ \ \ \ \[list\ \\
puts $fp \t\ \[list\ Chair\ \{\{chair\ \{1\ 1\}\ \{1\ 2\}\ \{0\ 2\}\ \{0\ 0\}\ \{2\ 0\}\ \{2\ 1\}\}\}\]\ \\
puts $fp {	];}
puts $fp {}
puts $fp proc\ chair-make\ \{tiles\ divide\}\ \{
puts $fp \ \ \ \ if\ \{\$divide\ ==\ 0\}\ \{
puts $fp {	return [list chair $tiles];}
puts $fp \ \ \ \ \}\ else\ \{
puts $fp {	set newt {};}
puts $fp \tforeach\ t1\ \$tiles\ \{
puts $fp {	    eval lappend newt [eval chair-dissect $t1];}
puts $fp \t\}
puts $fp {	return [list chair $newt];}
puts $fp \ \ \ \ \}
puts $fp \}
puts $fp {}
puts $fp proc\ chair-dissect\ \{type\ a\ b\ c\ d\ e\ f\}\ \{
puts $fp {    set r [vscale 1/2.0 [vadd $a $b]];}
puts $fp {    set s [vscale 1/2.0 [vadd $d $c]];}
puts $fp {    set t [vscale 1/2.0 [vadd $d $e]];}
puts $fp {    set u [vscale 1/2.0 [vadd $a $f]];}
puts $fp {    set v [vscale 1/8.0 [vsum [vscale 3 $c] $d [vscale 2 [vadd $a $b]]]];}
puts $fp {    set w [vscale 1/8.0 [vsum [vscale 2 $a] [vscale 4 $d] $c $e]];}
puts $fp {    set x [vscale 1/8.0 [vsum [vscale 2 [vadd $a $f]] $d [vscale 3 $e]]];}
puts $fp {    set y [vscale 1/4.0 [vsum [vscale 2 $a] $c $d]];}
puts $fp {    set z [vscale 1/4.0 [vsum [vscale 2 $a] $d $e]];}
puts $fp \ \ \ \ return\ \[list\\
puts $fp \t\t\[list\ chair\ \$a\ \$r\ \$v\ \$w\ \$x\ \$u\]\\
puts $fp \t\t\[list\ chair\ \$v\ \$r\ \$b\ \$c\ \$s\ \$y\]\\
puts $fp \t\t\[list\ chair\ \$w\ \$y\ \$s\ \$d\ \$t\ \$z\]\\
puts $fp \t\t\[list\ chair\ \$x\ \$z\ \$t\ \$e\ \$f\ \$u\]\\
puts $fp {	       ];}
puts $fp \}
puts $fp {}
puts $fp {}
close $fp
set restore [file join subtile tiling danzer.tcl]
puts "restoring file $restore"
if {[catch {open $restore w} fp]} { puts "failed to create file $restore" } 
puts $fp ########################################################################
puts $fp ##
puts $fp {## Danzer's triangular prototiles with 7-fold symmetry}
puts $fp {## triangle A - isoceles with sides b-a-a}
puts $fp {## triangle B - scalene with sides a-c-b (in left and right handed versions)}
puts $fp {## triangle C - isoceles with sides a-c-c}
puts $fp {## edge b = 0.445041867913 * a}
puts $fp {## edge c = 0.801937735804 * a}
puts $fp {## }
puts $fp {## The edges scale by 0.356895867892 when dissecting}
puts $fp ##
puts $fp {lappend subtile(tilings) {{Danzer triangular 7-fold} danzer};}
puts $fp {}
puts $fp {set danzer(danzer-a) 1.0;}
puts $fp {set danzer(danzer-b) [expr 0.445041867913 * $danzer(danzer-a)];}
puts $fp {set danzer(danzer-c) [expr 0.801937735804 * $danzer(danzer-a)];}
puts $fp {set danzer(danzer-x) [expr (1+pow($danzer(danzer-b),2)-pow($danzer(danzer-c),2))*$danzer(danzer-a)/2.0];}
puts $fp {set danzer(danzer-y) [expr sqrt(pow($danzer(danzer-b),2)-pow($danzer(danzer-x),2))];}
puts $fp {set danzer(danzer-g) 0.356895867892;}
puts $fp {}
puts $fp proc\ danzer-about\ \{tiles\}\ \{
puts $fp \ \ \ \ about-something\ \{About\ Danzer's\ 7-fold\ Tiling\}\ \{
puts $fp {	Danzer's 7-fold tiling is described in section 7.4.1 of}
puts $fp {	Senechal (1995).}
puts $fp {	}
puts $fp {	It is remarkable because it is the first}
puts $fp {	tiling to display 7-fold symmetry.}
puts $fp \ \ \ \ \}
puts $fp {    return $tiles;}
puts $fp \}
puts $fp {}
puts $fp set\ AL\ \[list\ \[list\ danzer-A\\
puts $fp \t\t\ \ \{0\ 0\}\\
puts $fp \t\t\ \ \[vmake\ \$danzer(danzer-b)\ 0\]\\
puts $fp \t\t\ \ \[vmake\ \$danzer(danzer-b)/2.0\ sqrt(1-pow(\$danzer(danzer-b)/2.0,2))\]\\
puts $fp {		 ]];}
puts $fp set\ AR\ \[list\ \[list\ danzer-A\\
puts $fp \t\t\ \ \[vmake\ \$danzer(danzer-b)\ 0\]\\
puts $fp \t\t\ \ \{0\ 0\}\\
puts $fp \t\t\ \ \[vmake\ \$danzer(danzer-b)/2.0\ sqrt(1-pow(\$danzer(danzer-b)/2.0,2))\]\\
puts $fp {		 ]];}
puts $fp set\ BL\ \[list\ \[list\ danzer-BL\\
puts $fp \t\t\ \ \{0\ 0\}\\
puts $fp \t\t\ \ \[vmake\ \$danzer(danzer-a)\ 0\]\\
puts $fp \t\t\ \ \[vmake\ \$danzer(danzer-x)\ \$danzer(danzer-y)\]\\
puts $fp {		 ]];}
puts $fp set\ BR\ \[list\ \[list\ danzer-BR\\
puts $fp \t\t\ \ \[vmake\ \$danzer(danzer-a)\ 0\]\\
puts $fp \t\t\ \ \{0\ 0\}\\
puts $fp \t\t\ \ \[vmake\ \$danzer(danzer-a)-\$danzer(danzer-x)\ \$danzer(danzer-y)\]\\
puts $fp {		 ]];}
puts $fp set\ CL\ \[list\ \[list\ danzer-C\\
puts $fp \t\t\ \ \{0\ 0\}\\
puts $fp \t\t\ \ \[vmake\ \$danzer(danzer-a)\ 0\]\\
puts $fp \t\t\ \ \[vmake\ \$danzer(danzer-a)/2.0\ sqrt(pow(\$danzer(danzer-c),2)-pow(\$danzer(danzer-a)/2.0,2))\]\\
puts $fp {		 ]];}
puts $fp set\ CR\ \[list\ \[list\ danzer-C\\
puts $fp \t\t\ \ \[vmake\ \$danzer(danzer-a)\ 0\]\\
puts $fp \t\t\ \ \{0\ 0\}\\
puts $fp \t\t\ \ \[vmake\ \$danzer(danzer-a)/2.0\ sqrt(pow(\$danzer(danzer-c),2)-pow(\$danzer(danzer-a)/2.0,2))\]\\
puts $fp {		 ]];}
puts $fp set\ subtile(danzer-ops-menu)\ \\
puts $fp \ \ \ \ \[list\ \\
puts $fp \t\ \{\{About\ Danzer\ Tiles\}\ danzer-about\}\ \\
puts $fp {	];}
puts $fp set\ subtile(danzer-start-menu)\ \\
puts $fp \ \ \ \ \[list\ \\
puts $fp \t\ \[list\ \{Small\ isosceles\}\ \$AL\]\ \\
puts $fp \t\ \[list\ \{Mirrored\ small\ isoceles\}\ \$AR\]\ \\
puts $fp \t\ \[list\ \{Scalene\}\ \$BL\]\ \\
puts $fp \t\ \[list\ \{Mirrored\ scalene\}\ \$BR\]\ \\
puts $fp \t\ \[list\ \{Large\ isosceles\ triangle\}\ \$CL\]\ \\
puts $fp \t\ \[list\ \{Mirrored\ large\ isosceles\}\ \$CR\]\ \\
puts $fp {	];}
puts $fp {}
puts $fp proc\ danzer-make\ \{tiles\ divide\}\ \{
puts $fp \ \ \ \ if\ \{\$divide\ ==\ 0\}\ \{
puts $fp {	return [list danzer $tiles];}
puts $fp \ \ \ \ \}\ else\ \{
puts $fp {	return [list danzer [danzer-dissect $tiles]];}
puts $fp \ \ \ \ \}
puts $fp \}
puts $fp {}
puts $fp proc\ danzer-dissect\ \{tiles\}\ \{
puts $fp {    set newt {};}
puts $fp \ \ \ \ foreach\ t1\ \$tiles\ \{
puts $fp {	set type [lindex $t1 0];}
puts $fp {	set a [lindex $t1 1];}
puts $fp {	set b [lindex $t1 2];}
puts $fp {	set c [lindex $t1 3];}
puts $fp \tswitch\ -exact\ \$type\ \{
puts $fp \t\ \ \ \ danzer-A\ \{
puts $fp {		upvar \#0 danzer(danzer-g) g;}
puts $fp {		set p [vadd $c [vscale $g [vsub $a $c]]];}
puts $fp {		set r [vadd $a [vscale $g [vsub $c $a]]];}
puts $fp {		set q [vadd $c [vscale $g [vsub $b $c]]];}
puts $fp {		set s [vadd $b [vscale $g [vsub $c $b]]];}
puts $fp {		set t [vadd $p [vsub $q $c]];}
puts $fp {		set u [vadd $a [vscale $g [vsub $b $a]]];}
puts $fp \t\tlappend\ newt\\
puts $fp \t\t\ \ \ \ \[list\ danzer-A\ \$q\ \$p\ \$c\]\\
puts $fp \t\t\ \ \ \ \[list\ danzer-A\ \$q\ \$p\ \$t\]\\
puts $fp \t\t\ \ \ \ \[list\ danzer-A\ \$t\ \$s\ \$b\]\\
puts $fp \t\t\ \ \ \ \[list\ danzer-A\ \$t\ \$r\ \$a\]\\
puts $fp \t\t\ \ \ \ \[list\ danzer-BR\ \$t\ \$q\ \$s\]\\
puts $fp \t\t\ \ \ \ \[list\ danzer-BR\ \$a\ \$t\ \$u\]\\
puts $fp \t\t\ \ \ \ \[list\ danzer-BL\ \$t\ \$p\ \$r\]\\
puts $fp {		    [list danzer-C $b $t $u];}
puts $fp \t\ \ \ \ \}
puts $fp {	    danzer-BL -}
puts $fp \t\ \ \ \ danzer-BR\ \{
puts $fp {		upvar \#0 danzer(danzer-g) g;}
puts $fp {		upvar \#0 danzer(danzer-a) ka;}
puts $fp {		upvar \#0 danzer(danzer-b) kb;}
puts $fp {		upvar \#0 danzer(danzer-c) kc;}
puts $fp {		set p [vadd $a [vscale $g [vsub $c $a]]];}
puts $fp {		set q [vadd $c [vscale $g*$kb/$kc [vsub $b $c]]];}
puts $fp {		set r [vadd $a [vscale $g [vsub $b $a]]];}
puts $fp {		set s [vadd $b [vscale $g*$ka/$kc [vsub $c $b]]];}
puts $fp {		set t [vadd $b [vscale $g [vsub $a $b]]];}
puts $fp \t\tlappend\ newt\\
puts $fp \t\t\ \ \ \ \[list\ danzer-A\ \$s\ \$t\ \$b\]\\
puts $fp \t\t\ \ \ \ \[list\ \$type\ \$a\ \$r\ \$p\]\\
puts $fp \t\t\ \ \ \ \[list\ \$type\ \$c\ \$r\ \$q\]\\
puts $fp \t\t\ \ \ \ \[list\ \$type\ \$s\ \$r\ \$t\]\\
puts $fp \t\t\ \ \ \ \[list\ danzer-C\ \$c\ \$r\ \$p\]\\
puts $fp {		    [list danzer-C $s $r $q];}
puts $fp \t\ \ \ \ \}
puts $fp \t\ \ \ \ danzer-C\ \{
puts $fp {		upvar \#0 danzer(danzer-g) g;}
puts $fp {		upvar \#0 danzer(danzer-a) ka;}
puts $fp {		upvar \#0 danzer(danzer-b) kb;}
puts $fp {		upvar \#0 danzer(danzer-c) kc;}
puts $fp {		set p [vadd $a [vscale $g*$kb/$kc [vsub $c $a]]];}
puts $fp {		set q [vadd $c [vscale $g*$ka/$kc [vsub $a $c]]];}
puts $fp {		set r [vadd $c [vscale $g*$kb/$kc [vsub $b $c]]];}
puts $fp {		set s [vadd $b [vscale $g*$ka/$kc [vsub $c $b]]];}
puts $fp {		set t [vadd $b [vscale $g [vsub $a $b]]];}
puts $fp {		set u [vadd $a [vscale $g [vsub $b $a]]];}
puts $fp {		set v [vadd $q [vscale $g*$kb/$kc [vsub $b $q]]];}
puts $fp {		set w [vadd $b [vscale $g*$ka/$kc [vsub $q $b]]];}
puts $fp \t\tlappend\ newt\\
puts $fp \t\t\ \ \ \ \[list\ danzer-A\ \$q\ \$v\ \$c\]\\
puts $fp \t\t\ \ \ \ \[list\ danzer-A\ \$s\ \$w\ \$b\]\\
puts $fp \t\t\ \ \ \ \[list\ danzer-A\ \$w\ \$t\ \$b\]\\
puts $fp \t\t\ \ \ \ \[list\ danzer-BL\ \$a\ \$u\ \$p\]\\
puts $fp \t\t\ \ \ \ \[list\ danzer-BL\ \$q\ \$u\ \$v\]\\
puts $fp \t\t\ \ \ \ \[list\ danzer-BL\ \$c\ \$v\ \$r\]\\
puts $fp \t\t\ \ \ \ \[list\ danzer-BL\ \$s\ \$v\ \$w\]\\
puts $fp \t\t\ \ \ \ \[list\ danzer-BL\ \$w\ \$u\ \$t\]\\
puts $fp \t\t\ \ \ \ \[list\ danzer-C\ \$q\ \$u\ \$p\]\\
puts $fp \t\t\ \ \ \ \[list\ danzer-C\ \$s\ \$v\ \$r\]\\
puts $fp {		    [list danzer-C $w $u $v];}
puts $fp \t\ \ \ \ \}
puts $fp \t\ \ \ \ default\ \{
puts $fp {		error "unknown tile type $type";}
puts $fp \t\ \ \ \ \}
puts $fp \t\}
puts $fp \ \ \ \ \}
puts $fp {    return $newt;}
puts $fp \}
puts $fp {}
puts $fp {}
close $fp
set restore [file join subtile tiling penrose.tcl]
puts "restoring file $restore"
if {[catch {open $restore w} fp]} { puts "failed to create file $restore" } 
puts $fp ########################################################################
puts $fp ##
puts $fp {## Penrose tilings.}
puts $fp ##
puts $fp {## The penrose kite-and-dart tiling is dissected into the A}
puts $fp {## triangulation by dividing kites along their long diagonals and darts}
puts $fp {## along their short diagonals.}
puts $fp {## The penrose rhomb tiling is dissected into the B triangulation by}
puts $fp {## dividing the large rhombs along their long diagonals and the small}
puts $fp {## rhomb along their short diagonals.}
puts $fp {## The penrose A trianguluation is dissected into the B triangulation}
puts $fp {## by renaming the small A triangles into large B triangles and}
puts $fp {## dividing the large A triangles into large B and small B}
puts $fp {## triangles.}
puts $fp {## The penrose B triangulation is dissected into the A triangulation}
puts $fp {## by renaming the small B triangles into large A triangles and}
puts $fp {## dividing the large B triangles into large A and small A triangles.}
puts $fp ##
puts $fp {## The reverse annealing steps are also supported.}
puts $fp ##
puts $fp {## There are further complicating details necessary to preserve the}
puts $fp {## vertex colorings which distinguish left and right handed forms of}
puts $fp {## each triangle.}
puts $fp ##
puts $fp {## Each triangle is represented as a name and three vertices.  The}
puts $fp {## vertices are listed in counter clockwise order starting from the}
puts $fp {## lower left corner when the triangle is sitting on its base with the}
puts $fp {## two equal edges pointing up.  (Life would be simpler if I ordered}
puts $fp {## the mirror image vertices as clockwise).}
puts $fp ##
puts $fp {##         +}
puts $fp ##\ \ \ \ \ \ \ \ /\ \\
puts $fp ##\ \ \ \ \ \ \ /\ \ \ \\
puts $fp ##\ \ \ \ \ \ /\ \ \ \ \ \\
puts $fp ##\ \ \ \ \ /\ \ \ \ \ \ \ \\
puts $fp ##\ \ \ \ /\ \ \ \ \ \ \ \ \ \\
puts $fp ##\ \ \ /\ \ \ \ \ \ \ \ \ \ \ \\
puts $fp ##\ \ /\ \ \ \ \ \ \ \ \ \ \ \ \ \\
puts $fp {## o---------------+}
puts $fp ##
puts $fp {}
puts $fp lappend\ subtile(tilings)\ \\
puts $fp \ \ \ \ \{\{Penrose\ kite\ and\ dart\}\ penrose-KD\}\ \\
puts $fp \ \ \ \ \{\{Penrose\ rhomb\}\ penrose-R\}\ \\
puts $fp \ \ \ \ \{\{Penrose\ B\ triangles\}\ penrose-B\}\\
puts $fp {    {{Penrose A triangles} penrose-A};}
puts $fp {}
puts $fp {set penrose(pt) [expr (1/$Tau)/(1+1/$Tau)];}
puts $fp {set penrose(pT) [expr 1/(1+$Tau)];}
puts $fp {set penrose(pT2) [expr 1/($Tau*$Tau)];}
puts $fp {}
puts $fp #
puts $fp #
puts $fp #
puts $fp proc\ penrose-about\ \{tiles\}\ \{
puts $fp \ \ \ \ about-something\ \{About\ Penrose\ Tilings\}\ \{
puts $fp {	The Penrose tilings are discussed at length in Senechal (1995) and in}
puts $fp {	Gruenbaum and Shephard (1987).}
puts $fp {}
puts $fp {	Subtile implements the kite and dart tiling, the rhomb tiling, and the}
puts $fp {	two triangulations generated by slicing kites, darts, and rhombs into}
puts $fp {	halves.}
puts $fp {}
puts $fp {	The A triangulation is generated by slicing kites along their long}
puts $fp {	diagonals and darts along their short diagonals.}
puts $fp {}
puts $fp {	The B triangulation is generated by slicing large rhombs along their}
puts $fp {	long diagonals and small rhombs along their short diagonals.}
puts $fp {}
puts $fp {	The A and B triangulations can be converted into each other by}
puts $fp {	dissection or annealing. }
puts $fp \ \ \ \ \}
puts $fp {    return $tiles;}
puts $fp \}
puts $fp #
puts $fp {# kite and dart tilings}
puts $fp #
puts $fp {set a [vmake 0 $Tau*sin($Pi/5)];}
puts $fp {set b [vmake ($Tau+1)/2 0];}
puts $fp {set c [vmake $Tau+1 $Tau*sin($Pi/5)];}
puts $fp {set d [vmake ($Tau+1)/2 2*$Tau*sin($Pi/5)];}
puts $fp {set e [vadd $a [vscale $Tau/($Tau+1) [vsub $c $a]]];}
puts $fp {}
puts $fp {set K [list [list penrose-KD-K $d $e $b $a]];}
puts $fp {set D [list [list penrose-KD-D $d $c $b $e]];}
puts $fp {}
puts $fp set\ subtile(penrose-KD-ops-menu)\ \\
puts $fp \ \ \ \ \[list\ \\
puts $fp \t\ \{\{About\ Penrose\ Tilings\}\ penrose-about\}\ \\
puts $fp \t\ \{\{Dissect\ to\ A\ triangles\}\ penrose-do-KD-dissect-to-A\}\ \\
puts $fp {	];}
puts $fp set\ subtile(penrose-KD-start-menu)\ \\
puts $fp \ \ \ \ \[list\ \\
puts $fp \t\ \[list\ Kite\ \$K\]\\
puts $fp \t\ \[list\ Dart\ \$D\]\ \\
puts $fp {	];}
puts $fp {}
puts $fp proc\ penrose-do-KD-dissect-to-A\ \{tiles\}\ \{
puts $fp {    return [list penrose-A [penrose-KD-dissect-to-A $tiles]];}
puts $fp \}
puts $fp {}
puts $fp proc\ penrose-KD-make\ \{tiles\ divide\}\ \{
puts $fp \ \ \ \ if\ \{\$divide\ ==\ 0\}\ \{
puts $fp {	return [list penrose-KD $tiles];}
puts $fp \ \ \ \ \}\ else\ \{
puts $fp \treturn\ \[list\ penrose-KD\ \\
puts $fp \t\t\ \ \ \ \[penrose-A-anneal-to-KD\ \\
puts $fp \t\t\t\ \[penrose-B-dissect-to-A\ \\
puts $fp \t\t\t\ \ \ \ \ \ \[penrose-A-dissect-to-B\ \\
puts $fp {				   [penrose-KD-dissect-to-A $tiles]]]]];}
puts $fp \ \ \ \ \}
puts $fp \}
puts $fp {}
puts $fp #
puts $fp {# A triangle tilings - dissection of kite and dart}
puts $fp #
puts $fp set\ TL\ \[list\ \[list\ penrose-A-TL\\
puts $fp \t\t\ \ \[vmake\ 0\ \$Tau*sin(2*\$Pi/5)\]\\
puts $fp \t\t\ \ \[vmake\ 1\ \$Tau*sin(2*\$Pi/5)\]\\
puts $fp {		  [vmake 0.5 0]]];}
puts $fp set\ TR\ \[list\ \[list\ penrose-A-TR\\
puts $fp \t\t\ \ \[vmake\ 1\ \$Tau*sin(2*\$Pi/5)\]\\
puts $fp \t\t\ \ \[vmake\ 0\ \$Tau*sin(2*\$Pi/5)\]\\
puts $fp {		  [vmake 0.5 2*$Tau*sin(2*$Pi/5)]]];}
puts $fp set\ tL\ \[list\ \[list\ penrose-A-tL\\
puts $fp \t\t\ \ \[vmake\ 0\ sin(\$Pi/5)\]\\
puts $fp \t\t\ \ \[vmake\ \$Tau\ sin(\$Pi/5)\]\\
puts $fp {		  [vmake $Tau/2 0]]];}
puts $fp set\ tR\ \[list\ \[list\ penrose-A-tR\\
puts $fp \t\t\ \ \[vmake\ \$Tau\ sin(\$Pi/5)\]\\
puts $fp \t\t\ \ \[vmake\ 0\ sin(\$Pi/5)\]\\
puts $fp {		  [vmake $Tau/2 2*sin($Pi/5)]]];}
puts $fp set\ subtile(penrose-A-ops-menu)\ \\
puts $fp \ \ \ \ \[list\ \\
puts $fp \t\ \{\{About\ Penrose\ Tilings\}\ penrose-about\}\ \\
puts $fp \t\ \{\{Anneal\ to\ kites\ and\ darts\}\ penrose-do-A-anneal-to-KD\}\ \\
puts $fp \t\ \{\{Dissect\ to\ B\ triangles\}\ penrose-do-A-dissect-to-B\}\ \\
puts $fp \t\ \{\{Anneal\ to\ B\ triangles\}\ penrose-do-A-anneal-to-B\}\ \\
puts $fp {	];}
puts $fp set\ subtile(penrose-A-start-menu)\ \\
puts $fp \ \ \ \ \[list\ \\
puts $fp \t\ \[list\ \{Small\ A\ Left\}\ \$tL\]\ \\
puts $fp \t\ \[list\ \{Small\ A\ Right\}\ \$tR\]\ \\
puts $fp \t\ \[list\ \{Large\ A\ Left\}\ \$TL\]\ \\
puts $fp \t\ \[list\ \{Large\ A\ Right\}\ \$TR\]\ \\
puts $fp {	];}
puts $fp {}
puts $fp proc\ penrose-do-A-anneal-to-KD\ \{tiles\}\ \{
puts $fp {    return [list penrose-KD [penrose-A-anneal-to-KD $tiles]];}
puts $fp \}
puts $fp {}
puts $fp proc\ penrose-do-A-dissect-to-B\ \{tiles\}\ \{
puts $fp {    return [list penrose-B [penrose-A-dissect-to-B $tiles]];}
puts $fp \}
puts $fp proc\ penrose-do-A-anneal-to-B\ \{tiles\}\ \{
puts $fp {    return [list penrose-B [penrose-A-anneal-to-B $tiles]];}
puts $fp \}
puts $fp proc\ penrose-A-make\ \{tiles\ divide\}\ \{
puts $fp \ \ \ \ if\ \{\$divide\ ==\ 0\}\ \{
puts $fp {	return [list penrose-A $tiles];}
puts $fp \ \ \ \ \}\ else\ \{
puts $fp {	return [list penrose-A [penrose-B-dissect-to-A [penrose-A-dissect-to-B $tiles]]];}
puts $fp \ \ \ \ \}
puts $fp \}
puts $fp {}
puts $fp #
puts $fp {# B triangle tilings - dissection of rhombs, dissection or annealing of A triangles.}
puts $fp #
puts $fp set\ tL\ \[list\ \[list\ penrose-B-tL\\
puts $fp \t\t\ \ \[vmake\ 0\ \$Tau*sin(2*\$Pi/5)\]\\
puts $fp \t\t\ \ \[vmake\ 1\ \$Tau*sin(2*\$Pi/5)\]\\
puts $fp {		  [vmake 0.5 0]]];}
puts $fp set\ tR\ \[list\ \[list\ penrose-B-tR\\
puts $fp \t\t\ \ \[vmake\ 1\ \$Tau*sin(2*\$Pi/5)\]\\
puts $fp \t\t\ \ \[vmake\ 0\ \$Tau*sin(2*\$Pi/5)\]\\
puts $fp {		  [vmake 0.5 2*$Tau*sin(2*$Pi/5)]]];}
puts $fp set\ TL\ \[list\ \[list\ penrose-B-TL\\
puts $fp \t\t\ \ \[vmake\ 0\ \$Tau*sin(\$Pi/5)\]\\
puts $fp \t\t\ \ \[vmake\ \$Tau+1\ \$Tau*sin(\$Pi/5)\]\\
puts $fp {		  [vmake ($Tau+1)/2 0]]];}
puts $fp set\ TR\ \[list\ \[list\ penrose-B-TR\\
puts $fp \t\t\ \ \[vmake\ \$Tau+1\ \$Tau*sin(\$Pi/5)\]\\
puts $fp \t\t\ \ \[vmake\ 0\ \$Tau*sin(\$Pi/5)\]\\
puts $fp {		  [vmake ($Tau+1)/2 2*$Tau*sin($Pi/5)]]];}
puts $fp set\ subtile(penrose-B-ops-menu)\ \\
puts $fp \ \ \ \ \[list\ \\
puts $fp \t\ \{\{About\ Penrose\ Tilings\}\ penrose-about\}\ \\
puts $fp \t\ \{\{Anneal\ to\ rhombs\}\ penrose-do-B-anneal-to-R\}\ \\
puts $fp \t\ \{\{Dissect\ to\ A\ triangles\}\ penrose-do-B-dissect-to-A\}\ \\
puts $fp \t\ \{\{Anneal\ to\ A\ triangles\}\ penrose-do-B-anneal-to-A\}\ \\
puts $fp {	];}
puts $fp set\ subtile(penrose-B-start-menu)\ \\
puts $fp \ \ \ \ \[list\ \\
puts $fp \t\ \[list\ \{Small\ B\ Left\}\ \$tL\]\ \\
puts $fp \t\ \[list\ \{Small\ B\ Right\}\ \$tR\]\ \\
puts $fp \t\ \[list\ \{Large\ B\ Left\}\ \$TL\]\ \\
puts $fp \t\ \[list\ \{Large\ B\ Right\}\ \$TR\]\ \\
puts $fp {	];}
puts $fp {}
puts $fp proc\ penrose-do-B-anneal-to-R\ \{tiles\}\ \{
puts $fp {    return [list penrose-R [penrose-B-anneal-to-R $tiles]];}
puts $fp \}
puts $fp proc\ penrose-do-B-dissect-to-A\ \{tiles\}\ \{
puts $fp {    return [list penrose-A [penrose-B-dissect-to-A $tiles]];}
puts $fp \}
puts $fp proc\ penrose-do-B-anneal-to-A\ \{tiles\}\ \{
puts $fp {    return [list penrose-A [penrose-B-anneal-to-A $tiles]];}
puts $fp \}
puts $fp proc\ penrose-B-make\ \{tiles\ divide\}\ \{
puts $fp \ \ \ \ if\ \{\$divide\ ==\ 0\}\ \{
puts $fp {	return [list penrose-B $tiles];}
puts $fp \ \ \ \ \}\ else\ \{
puts $fp {	return [list penrose-B [penrose-A-dissect-to-B [penrose-B-dissect-to-A $tiles]]];}
puts $fp \ \ \ \ \}
puts $fp \}
puts $fp {    }
puts $fp #
puts $fp {# rhomb tilings}
puts $fp #
puts $fp set\ r\ \[list\ \[list\ penrose-R-r\\
puts $fp \t\t\ \[vmake\ 0\ \$Tau*sin(2*\$Pi/5)\]\\
puts $fp \t\t\ \[vmake\ 0.5\ 0\]\\
puts $fp \t\t\ \[vmake\ 1\ \$Tau*sin(2*\$Pi/5)\]\\
puts $fp {		 [vmake 0.5 2*$Tau*sin(2*$Pi/5)]]];}
puts $fp set\ R\ \[list\ \[list\ penrose-R-R\\
puts $fp \t\t\ \[vmake\ 0\ \$Tau*sin(\$Pi/5)\]\\
puts $fp \t\t\ \[vmake\ (\$Tau+1)/2\ 0\]\\
puts $fp \t\t\ \[vmake\ \$Tau+1\ \$Tau*sin(\$Pi/5)\]\\
puts $fp {		 [vmake ($Tau+1)/2 2*$Tau*sin($Pi/5)]]];}
puts $fp set\ subtile(penrose-R-ops-menu)\ \\
puts $fp \ \ \ \ \[list\ \\
puts $fp \t\ \{\{About\ Penrose\ Tilings\}\ penrose-about\}\ \\
puts $fp \t\ \{\{Dissect\ to\ B\ triangles\}\ penrose-do-R-dissect-to-B\}\ \\
puts $fp {	];}
puts $fp set\ subtile(penrose-R-start-menu)\ \\
puts $fp \ \ \ \ \[list\ \\
puts $fp \t\ \[list\ \{Large\ rhomb\}\ \$R\]\ \\
puts $fp \t\ \[list\ \{Small\ rhomb\}\ \$r\]\ \\
puts $fp {	];}
puts $fp {}
puts $fp proc\ penrose-do-R-dissect-to-B\ \{tiles\}\ \{
puts $fp {    return [list penrose-B [penrose-R-dissect-to-B $tiles]];}
puts $fp \}
puts $fp proc\ penrose-R-make\ \{tiles\ divide\}\ \{
puts $fp \ \ \ \ if\ \{\$divide\ ==\ 0\}\ \{
puts $fp {	return [list penrose-R $tiles];}
puts $fp \ \ \ \ \}\ else\ \{
puts $fp \treturn\ \[list\ penrose-R\ \\
puts $fp \t\t\ \ \ \ \[penrose-B-anneal-to-R\ \\
puts $fp \t\t\t\ \[penrose-A-dissect-to-B\ \\
puts $fp \t\t\t\ \ \ \ \ \ \[penrose-B-dissect-to-A\ \\
puts $fp {				   [penrose-R-dissect-to-B $tiles]]]]];}
puts $fp \ \ \ \ \}
puts $fp \}
puts $fp {}
puts $fp #
puts $fp {# annealing utility}
puts $fp #
puts $fp proc\ penrose-tile-match\ \{type\ listname\ tilename\}\ \{
puts $fp {    upvar $listname list;}
puts $fp {    upvar $tilename tile;}
puts $fp \ \ \ \ if\ \{\ !\ \[info\ exists\ list\]\}\ \{
puts $fp {	return 0;}
puts $fp \ \ \ \ \}
puts $fp \ \ \ \ for\ \{set\ i\ 0\}\ \{\$i\ <\ \[llength\ \$list\]\}\ \{incr\ i\}\ \{
puts $fp {	set t1 [lindex $list $i];}
puts $fp \tif\ \{\"\[lindex\ \$t1\ 0\]\"\ ==\ \"\$type\"\}\ \{
puts $fp {	    set list [lreplace $list $i $i];}
puts $fp \t\ \ \ \ if\ \{\"\$list\"\ ==\ \{\}\}\ \{
puts $fp {		unset list;}
puts $fp \t\ \ \ \ \}
puts $fp {	    set tile $t1;}
puts $fp {	    return 1;}
puts $fp \t\}
puts $fp \ \ \ \ \}
puts $fp {    return 0;}
puts $fp \}
puts $fp {}
puts $fp {    }
puts $fp #
puts $fp {# dissect a list of penrose-R tiles to a list of penrose-B tiles}
puts $fp #
puts $fp proc\ penrose-R-dissect-to-B\ \{tiles\}\ \{
puts $fp {    set newt {};}
puts $fp \ \ \ \ foreach\ tile\ \$tiles\ \{
puts $fp {	set type [lindex $tile 0];}
puts $fp {	set a [lindex $tile 1];}
puts $fp {	set b [lindex $tile 2];}
puts $fp {	set c [lindex $tile 3];}
puts $fp {	set d [lindex $tile 4];}
puts $fp \tswitch\ -exact\ \$type\ \{
puts $fp \t\ \ \ \ penrose-R-R\ \{
puts $fp {		lappend newt [list penrose-B-TL $a $c $b] [list penrose-B-TR $c $a $d];}
puts $fp \t\ \ \ \ \}
puts $fp \t\ \ \ \ penrose-R-r\ \{
puts $fp {		lappend newt [list penrose-B-tL $a $c $b] [list penrose-B-tR $c $a $d];}
puts $fp \t\ \ \ \ \}
puts $fp \t\ \ \ \ default\ \{
puts $fp {		error "found tile of type $type";}
puts $fp \t\ \ \ \ \}
puts $fp \t\}
puts $fp \ \ \ \ \}
puts $fp {    return $newt;}
puts $fp \}
puts $fp {}
puts $fp #
puts $fp {# anneal a list of penrose-B tiles to a list of penrose-R tiles}
puts $fp #
puts $fp proc\ penrose-B-anneal-to-R\ \{tiles\}\ \{
puts $fp {    set newt {};}
puts $fp \ \ \ \ foreach\ t1\ \$tiles\ \{
puts $fp {	set type [lindex $t1 0];}
puts $fp {	set a [lindex $t1 1];}
puts $fp {	set b [lindex $t1 2];}
puts $fp {	set c [lindex $t1 3];}
puts $fp \tswitch\ -exact\ \$type\ \{
puts $fp \t\ \ \ \ penrose-B-tL\ \{
puts $fp {		set point $a,$b;}
puts $fp \t\tif\ \{\[penrose-tile-match\ penrose-B-tR\ t(\$point)\ t2\]\}\ \{
puts $fp {		    lappend newt [list penrose-R-r $a $c [lindex $t2 1] [lindex $t2 3]];}
puts $fp \t\t\}\ else\ \{
puts $fp {		    lappend t($point) $t1;}
puts $fp \t\t\}
puts $fp \t\ \ \ \ \}
puts $fp \t\ \ \ \ penrose-B-tR\ \{
puts $fp {		set point $b,$a;}
puts $fp \t\tif\ \{\[penrose-tile-match\ penrose-B-tL\ t(\$point)\ t2\]\}\ \{
puts $fp {		    lappend newt [list penrose-R-r [lindex $t2 1] [lindex $t2 3] $a $c];}
puts $fp \t\t\}\ else\ \{
puts $fp {		    lappend t($point) $t1;}
puts $fp \t\t\}
puts $fp \t\ \ \ \ \}
puts $fp \t\ \ \ \ penrose-B-TL\ \{
puts $fp {		set point $a,$b;}
puts $fp \t\tif\ \{\[penrose-tile-match\ penrose-B-TR\ t(\$point)\ t2\]\}\ \{
puts $fp {		    lappend newt [list penrose-R-R $a $c [lindex $t2 1] [lindex $t2 3]];}
puts $fp \t\t\}\ else\ \{
puts $fp {		    lappend t($point) $t1;}
puts $fp \t\t\}
puts $fp \t\ \ \ \ \}
puts $fp \t\ \ \ \ penrose-B-TR\ \{
puts $fp {		set point $b,$a;}
puts $fp \t\tif\ \{\[penrose-tile-match\ penrose-B-TL\ t(\$point)\ t2\]\}\ \{
puts $fp {		    lappend newt [list penrose-R-R [lindex $t2 1] [lindex $t2 3] $a $c];}
puts $fp \t\t\}\ else\ \{
puts $fp {		    lappend t($point) $t1;}
puts $fp \t\t\}
puts $fp \t\ \ \ \ \}
puts $fp \t\ \ \ \ default\ \{
puts $fp {		error "found tile of type $type";}
puts $fp \t\ \ \ \ \}
puts $fp \t\}
puts $fp \ \ \ \ \}
puts $fp {    return $newt;}
puts $fp \}
puts $fp {}
puts $fp #
puts $fp {# dissect a list of penrose-B tiles to a list of penrose-A tiles}
puts $fp #
puts $fp proc\ penrose-B-dissect-to-A\ \{tiles\}\ \{
puts $fp {    upvar \#0 penrose(pT) pT;}
puts $fp {    set newt {};}
puts $fp \ \ \ \ foreach\ tile\ \$tiles\ \{
puts $fp {	set type [lindex $tile 0];}
puts $fp {	set a [lindex $tile 1];}
puts $fp {	set b [lindex $tile 2];}
puts $fp {	set c [lindex $tile 3];}
puts $fp \tswitch\ -exact\ \$type\ \{
puts $fp \t\ \ \ \ penrose-B-tL\ \{
puts $fp {		lappend newt [list penrose-A-TL $a $b $c];}
puts $fp \t\ \ \ \ \}
puts $fp \t\ \ \ \ penrose-B-tR\ \{
puts $fp {		lappend newt [list penrose-A-TR $a $b $c];}
puts $fp \t\ \ \ \ \}
puts $fp \t\ \ \ \ penrose-B-TL\ \{
puts $fp {		set d [vadd $b [vscale $pT [vsub $a $b]]];}
puts $fp {		lappend newt [list penrose-A-TR $d $c $a] [list penrose-A-tL $b $c $d];}
puts $fp \t\ \ \ \ \}
puts $fp \t\ \ \ \ penrose-B-TR\ \{
puts $fp {		set d [vadd $a [vscale $pT [vsub $b $a]]];}
puts $fp {		lappend newt [list penrose-A-TL $c $d $b] [list penrose-A-tR $c $a $d];}
puts $fp \t\ \ \ \ \}
puts $fp \t\ \ \ \ default\ \{
puts $fp {		error "found tile of type $type";}
puts $fp \t\ \ \ \ \}
puts $fp \t\}
puts $fp \ \ \ \ \}
puts $fp {    return $newt;}
puts $fp \}
puts $fp {}
puts $fp #
puts $fp {# anneal a list of penrose-A tiles to a list of penrose-B tiles}
puts $fp #
puts $fp proc\ penrose-A-anneal-to-B\ \{tiles\}\ \{
puts $fp {    set newt {};}
puts $fp \ \ \ \ foreach\ t1\ \$tiles\ \{
puts $fp {	set type [lindex $t1 0];}
puts $fp {	set a [lindex $t1 1];}
puts $fp {	set b [lindex $t1 2];}
puts $fp {	set c [lindex $t1 3];}
puts $fp \tswitch\ -exact\ \$type\ \{
puts $fp \t\ \ \ \ penrose-A-tL\ \{
puts $fp {		set point $b,$c;}
puts $fp \t\tif\ \{\[penrose-tile-match\ penrose-A-TR\ t(\$point)\ t2\]\}\ \{
puts $fp {		    lappend newt [list penrose-B-TL [lindex $t2 3] $a $b];}
puts $fp \t\t\}\ else\ \{
puts $fp {		    lappend t($point) $t1;}
puts $fp \t\t\}
puts $fp \t\ \ \ \ \}
puts $fp \t\ \ \ \ penrose-A-TR\ \{
puts $fp {		set point $b,$a;}
puts $fp \t\tif\ \{\[penrose-tile-match\ penrose-A-tL\ t(\$point)\ t2\]\}\ \{
puts $fp {		    lappend newt [list penrose-B-TL $c [lindex $t2 1] [lindex $t2 2]];}
puts $fp \t\t\}\ else\ \{
puts $fp {		    lappend t($point) $t1;}
puts $fp \t\t\}
puts $fp \t\ \ \ \ \}
puts $fp \t\ \ \ \ penrose-A-TL\ \{
puts $fp {		set point $a,$b;}
puts $fp \t\tif\ \{\[penrose-tile-match\ penrose-A-tR\ t(\$point)\ t2\]\}\ \{
puts $fp {		    lappend newt [list penrose-B-TR [lindex $t2 2] $c $a];}
puts $fp \t\t\}\ else\ \{
puts $fp {		    lappend t($point) $t1;}
puts $fp \t\t\}
puts $fp \t\ \ \ \ \}
puts $fp \t\ \ \ \ penrose-A-tR\ \{
puts $fp {		set point $a,$c;}
puts $fp \t\tif\ \{\[penrose-tile-match\ penrose-A-TL\ t(\$point)\ t2\]\}\ \{
puts $fp {		    lappend newt [list penrose-B-TR $b [lindex $t2 3] [lindex $t2 1]];}
puts $fp \t\t\}\ else\ \{
puts $fp {		    lappend t($point) $t1;}
puts $fp \t\t\}
puts $fp \t\ \ \ \ \}
puts $fp \t\ \ \ \ default\ \{
puts $fp {		error "found tile of type $type";}
puts $fp \t\ \ \ \ \}
puts $fp \t\}
puts $fp \ \ \ \ \}
puts $fp \ \ \ \ foreach\ point\ \[array\ names\ t\]\ \{
puts $fp \tforeach\ t1\ \$t(\$point)\ \{
puts $fp {	    set type [lindex $t1 0];}
puts $fp {	    set a [lindex $t1 1];}
puts $fp {	    set b [lindex $t1 2];}
puts $fp {	    set c [lindex $t1 3];}
puts $fp \t\ \ \ \ switch\ -exact\ \$type\ \{
puts $fp \t\tpenrose-A-TR\ \{
puts $fp {		    lappend newt [list penrose-B-tR $a $b $c];}
puts $fp \t\t\}
puts $fp \t\tpenrose-A-TL\ \{
puts $fp {		    lappend newt [list penrose-B-tL $a $b $c];}
puts $fp \t\t\}
puts $fp \t\tdefault\ \{
puts $fp {		    puts stderr "leftover tile: $t1";}
puts $fp \t\t\}
puts $fp \t\ \ \ \ \}
puts $fp \t\}
puts $fp \ \ \ \ \}
puts $fp {    return $newt;}
puts $fp \}
puts $fp #
puts $fp {# dissect a list of penrose-A tiles into a list of penrose-B tiles}
puts $fp #
puts $fp proc\ penrose-A-dissect-to-B\ \{tiles\}\ \{
puts $fp {    upvar \#0 penrose(pT2) pT2;}
puts $fp {    set newt {};}
puts $fp \ \ \ \ foreach\ tile\ \$tiles\ \{
puts $fp {	set type [lindex $tile 0];}
puts $fp {	set a [lindex $tile 1];}
puts $fp {	set b [lindex $tile 2];}
puts $fp {	set c [lindex $tile 3];}
puts $fp \tswitch\ -exact\ \$type\ \{
puts $fp \t\ \ \ \ penrose-A-tL\ \{
puts $fp {		lappend newt [list penrose-B-TL $a $b $c];}
puts $fp \t\ \ \ \ \}
puts $fp \t\ \ \ \ penrose-A-tR\ \{
puts $fp {		lappend newt [list penrose-B-TR $a $b $c];}
puts $fp \t\ \ \ \ \}
puts $fp \t\ \ \ \ penrose-A-TL\ \{
puts $fp {		set d [vadd $a [vscale $pT2 [vsub $c $a]]];}
puts $fp {		lappend newt [list penrose-B-TL $b $c $d] [list penrose-B-tL $d $a $b];}
puts $fp \t\ \ \ \ \}
puts $fp \t\ \ \ \ penrose-A-TR\ \{
puts $fp {		set d [vadd $b [vscale $pT2 [vsub $c $b]]];}
puts $fp {		lappend newt [list penrose-B-TR $c $a $d] [list penrose-B-tR $b $d $a];}
puts $fp \t\ \ \ \ \}
puts $fp \t\ \ \ \ default\ \{
puts $fp {		error "found tile of type $type";}
puts $fp \t\ \ \ \ \}
puts $fp \t\}
puts $fp \ \ \ \ \}
puts $fp {    return $newt;}
puts $fp \}
puts $fp #
puts $fp {# anneal a list of penrose-B tiles into a list of penrose-A tiles}
puts $fp #
puts $fp proc\ penrose-B-anneal-to-A\ \{tiles\}\ \{
puts $fp {    set newt {};}
puts $fp \ \ \ \ foreach\ t1\ \$tiles\ \{
puts $fp {	set type [lindex $t1 0];}
puts $fp {	set a [lindex $t1 1];}
puts $fp {	set b [lindex $t1 2];}
puts $fp {	set c [lindex $t1 3];}
puts $fp \tswitch\ -exact\ \$type\ \{
puts $fp \t\ \ \ \ penrose-B-tL\ \{
puts $fp {		set point $a,$c;}
puts $fp \t\tif\ \{\[penrose-tile-match\ penrose-B-TL\ t(\$point)\ t2\]\}\ \{
puts $fp {		    lappend newt [list penrose-A-TL $b $c [lindex $t2 2]];}
puts $fp \t\t\}\ else\ \{
puts $fp {		    lappend t($point) $t1;}
puts $fp \t\t\}
puts $fp \t\ \ \ \ \}
puts $fp \t\ \ \ \ penrose-B-TL\ \{
puts $fp {		set point $c,$a;}
puts $fp \t\tif\ \{\[penrose-tile-match\ penrose-B-tL\ t(\$point)\ t2\]\}\ \{
puts $fp {		    lappend newt [list penrose-A-TL [lindex $t2 2] [lindex $t2 3] $b];}
puts $fp \t\t\}\ else\ \{
puts $fp {		    lappend t($point) $t1;}
puts $fp \t\t\}
puts $fp \t\ \ \ \ \}
puts $fp \t\ \ \ \ penrose-B-tR\ \{
puts $fp {		set point $b,$c;}
puts $fp \t\tif\ \{\[penrose-tile-match\ penrose-B-TR\ t(\$point)\ t2\]\}\ \{
puts $fp {		    lappend newt [list penrose-A-TR $c $a [lindex $t2 1]];}
puts $fp \t\t\}\ else\ \{
puts $fp {		    lappend t($point) $t1;}
puts $fp \t\t\}
puts $fp \t\ \ \ \ \}
puts $fp \t\ \ \ \ penrose-B-TR\ \{
puts $fp {		set point $c,$b;}
puts $fp \t\tif\ \{\[penrose-tile-match\ penrose-B-tR\ t(\$point)\ t2\]\}\ \{
puts $fp {		    lappend newt [list penrose-A-TR [lindex $t2 3] [lindex $t2 1] $a];}
puts $fp \t\t\}\ else\ \{
puts $fp {		    lappend t($point) $t1;}
puts $fp \t\t\}
puts $fp \t\ \ \ \ \}
puts $fp \t\ \ \ \ default\ \{
puts $fp {		error "found tile of type $type";}
puts $fp \t\ \ \ \ \}
puts $fp \t\}
puts $fp \ \ \ \ \}
puts $fp \ \ \ \ foreach\ point\ \[array\ names\ t\]\ \{
puts $fp \tforeach\ t1\ \$t(\$point)\ \{
puts $fp {	    set type [lindex $t1 0];}
puts $fp {	    set a [lindex $t1 1];}
puts $fp {	    set b [lindex $t1 2];}
puts $fp {	    set c [lindex $t1 3];}
puts $fp \t\ \ \ \ switch\ -exact\ \$type\ \{
puts $fp \t\tpenrose-B-TR\ \{
puts $fp {		    lappend newt [list penrose-A-tR $a $b $c];}
puts $fp \t\t\}
puts $fp \t\tpenrose-B-TL\ \{
puts $fp {		    lappend newt [list penrose-A-tL $a $b $c];}
puts $fp \t\t\}
puts $fp \t\tdefault\ \{
puts $fp {		    puts stderr "leftover tile: $t1";}
puts $fp \t\t\}
puts $fp \t\ \ \ \ \}
puts $fp \t\}
puts $fp \ \ \ \ \}
puts $fp {    return $newt;}
puts $fp \}
puts $fp #
puts $fp {# dissect a list of penrose-KD tiles into a list of penrose-A tiles}
puts $fp #
puts $fp proc\ penrose-KD-dissect-to-A\ \{tiles\}\ \{
puts $fp {    set newt {};}
puts $fp \ \ \ \ foreach\ tile\ \$tiles\ \{
puts $fp {	set type [lindex $tile 0];}
puts $fp {	set a [lindex $tile 1];}
puts $fp {	set b [lindex $tile 2];}
puts $fp {	set c [lindex $tile 3];}
puts $fp {	set d [lindex $tile 4];}
puts $fp \tswitch\ -exact\ \$type\ \{
puts $fp \t\ \ \ \ penrose-KD-K\ \{
puts $fp {		lappend newt [list penrose-A-TL $b $c $d] [list penrose-A-TR $a $b $d];}
puts $fp \t\ \ \ \ \}
puts $fp \t\ \ \ \ penrose-KD-D\ \{
puts $fp {		lappend newt [list penrose-A-tL $b $c $d] [list penrose-A-tR $a $b $d];}
puts $fp \t\ \ \ \ \}
puts $fp \t\ \ \ \ default\ \{
puts $fp {		error "found tile of type $type";}
puts $fp \t\ \ \ \ \}
puts $fp \t\}
puts $fp \ \ \ \ \}
puts $fp {    return $newt;}
puts $fp \}
puts $fp #
puts $fp {# anneal a list of penrose-A tiles into a list of penrose-A tiles}
puts $fp #
puts $fp proc\ penrose-A-anneal-to-KD\ \{tiles\}\ \{
puts $fp {    set newt {};}
puts $fp \ \ \ \ foreach\ t1\ \$tiles\ \{
puts $fp {	set type [lindex $t1 0];}
puts $fp {	set a [lindex $t1 1];}
puts $fp {	set b [lindex $t1 2];}
puts $fp {	set c [lindex $t1 3];}
puts $fp \tswitch\ -exact\ \$type\ \{
puts $fp \t\ \ \ \ penrose-A-tL\ \{
puts $fp {		set point $a,$c;}
puts $fp \t\tif\ \{\[info\ exists\ t(\$point)\]\}\ \{
puts $fp {		    set t2 [lindex $t($point) 0];}
puts $fp {		    lappend newt [list penrose-KD-D [lindex $t2 1] [lindex $t2 2] $b $c];}
puts $fp {		    unset t($point);}
puts $fp \t\t\}\ else\ \{
puts $fp {		    lappend t($point) $t1;}
puts $fp \t\t\}
puts $fp \t\ \ \ \ \}
puts $fp \t\ \ \ \ penrose-A-tR\ \{
puts $fp {		set point $b,$c;}
puts $fp \t\tif\ \{\[info\ exists\ t(\$point)\]\}\ \{
puts $fp {		    set t2 [lindex $t($point) 0];}
puts $fp {		    lappend newt [list penrose-KD-D $a $b [lindex $t2 2] [lindex $t2 3]];}
puts $fp {		    unset t($point);}
puts $fp \t\t\}\ else\ \{
puts $fp {		    lappend t($point) $t1;}
puts $fp \t\t\}
puts $fp \t\ \ \ \ \}
puts $fp \t\ \ \ \ penrose-A-TL\ \{
puts $fp {		set point $a,$c;}
puts $fp \t\tif\ \{\[info\ exists\ t(\$point)\]\}\ \{
puts $fp {		    set t2 [lindex $t($point) 0];}
puts $fp {		    lappend newt [list penrose-KD-K [lindex $t2 1] [lindex $t2 2] $b $c];}
puts $fp {		    unset t($point);}
puts $fp \t\t\}\ else\ \{
puts $fp {		    lappend t($point) $t1;}
puts $fp \t\t\}
puts $fp \t\ \ \ \ \}
puts $fp \t\ \ \ \ penrose-A-TR\ \{
puts $fp {		set point $b,$c;}
puts $fp \t\tif\ \{\[info\ exists\ t(\$point)\]\}\ \{
puts $fp {		    set t2 [lindex $t($point) 0];}
puts $fp {		    lappend newt [list penrose-KD-K $a $b [lindex $t2 2] [lindex $t2 3]];}
puts $fp {		    unset t($point);}
puts $fp \t\t\}\ else\ \{
puts $fp {		    lappend t($point) $t1;}
puts $fp \t\t\}
puts $fp \t\ \ \ \ \}
puts $fp \t\ \ \ \ default\ \{
puts $fp {		error "found tile of type $type";}
puts $fp \t\ \ \ \ \}
puts $fp \t\}
puts $fp \ \ \ \ \}
puts $fp {    return $newt;}
puts $fp \}
puts $fp {}
puts $fp {}
close $fp
set restore [file join subtile tiling pinwheel.tcl]
puts "restoring file $restore"
if {[catch {open $restore w} fp]} { puts "failed to create file $restore" } 
puts $fp ########################################################################
puts $fp ##
puts $fp {## Pinwheel tiling}
puts $fp ##
puts $fp {lappend subtile(tilings) {Pinwheel pinwheel}}
puts $fp {}
puts $fp {set pinwheel {{pinwheel {0 0} {3 0} {0 1.5}}};}
puts $fp {}
puts $fp {set subtile(pinwheel-ops-menu) {};}
puts $fp set\ subtile(pinwheel-start-menu)\ \\
puts $fp \ \ \ \ \[list\ \\
puts $fp \t\ \[list\ Pinwheel\ \$pinwheel\]\ \\
puts $fp {	];}
puts $fp {}
puts $fp proc\ pinwheel-make\ \{tiles\ divide\}\ \{
puts $fp \ \ \ \ if\ \{\$divide\ ==\ 0\}\ \{
puts $fp {	return [list pinwheel $tiles];}
puts $fp \ \ \ \ \}\ else\ \{
puts $fp {	set newt {};}
puts $fp \tforeach\ t1\ \$tiles\ \{
puts $fp {	    eval lappend newt [eval pinwheel-dissect $t1];}
puts $fp \t\}
puts $fp {	return [list pinwheel $newt];}
puts $fp \ \ \ \ \}
puts $fp \}
puts $fp {}
puts $fp proc\ pinwheel-dissect\ \{type\ a\ b\ c\}\ \{
puts $fp {    set w [vscale 1/2.0 [vadd $a $b]];}
puts $fp {    set x [vscale 1/5.0 [vadd [vscale 3 $b] [vscale 2 $c]]];}
puts $fp {    set y [vscale 1/5.0 [vadd $b [vscale 4 $c]]];}
puts $fp {    set z [vscale 1/2.0 [vadd $a $y]];}
puts $fp \ \ \ \ return\ \[list\\
puts $fp \t\t\[list\ pinwheel\ \$y\ \$a\ \$c\]\\
puts $fp \t\t\[list\ pinwheel\ \$z\ \$w\ \$a\]\\
puts $fp \t\t\[list\ pinwheel\ \$x\ \$y\ \$w\]\\
puts $fp \t\t\[list\ pinwheel\ \$x\ \$b\ \$w\]\\
puts $fp \t\t\[list\ pinwheel\ \$z\ \$w\ \$y\]\\
puts $fp {	       ];}
puts $fp \}
puts $fp {}
puts $fp {}
close $fp
set restore [file join subtile tiling sphinx.tcl]
puts "restoring file $restore"
if {[catch {open $restore w} fp]} { puts "failed to create file $restore" } 
puts $fp ########################################################################
puts $fp ##
puts $fp {## Sphinx tiling}
puts $fp ##
puts $fp {lappend subtile(tilings) {Sphinx sphinx}}
puts $fp {}
puts $fp {set subtile(sphinx-ops-menu) {};}
puts $fp {}
puts $fp {set q [expr sqrt(3)];}
puts $fp {}
puts $fp {set sphinx [list [list sphinx [vmake 2.0 $q] [vmake 1.5  $q/2.0] [vmake 0.5 $q/2.0] {0 0} {3 0}]];}
puts $fp {}
puts $fp set\ subtile(sphinx-start-menu)\ \\
puts $fp \ \ \ \ \[list\ \\
puts $fp \t\ \[list\ Sphinx\ \$sphinx\]\ \\
puts $fp {	];}
puts $fp {}
puts $fp {}
puts $fp proc\ sphinx-make\ \{tiles\ divide\}\ \{
puts $fp \ \ \ \ if\ \{\$divide\ ==\ 0\}\ \{
puts $fp {	return [list sphinx $tiles];}
puts $fp \ \ \ \ \}\ else\ \{
puts $fp {	set newt {};}
puts $fp \tforeach\ t1\ \$tiles\ \{
puts $fp {	    eval lappend newt [eval sphinx-dissect $t1];}
puts $fp \t\}
puts $fp {	return [list sphinx $newt];}
puts $fp \ \ \ \ \}
puts $fp \}
puts $fp {}
puts $fp proc\ sphinx-dissect\ \{type\ a\ b\ c\ d\ e\}\ \{
puts $fp {    set x1 [vscale 1/2.0 [vadd $d $b]]; }
puts $fp {    set x2 [vscale 1/6.0 [vsum [vscale 2 $d] $e [vscale 3 $b]]]; }
puts $fp {    set x3 [vscale 1/12.0 [vsum [vscale 2 $d] [vscale 4 $e] [vscale 3 $a] [vscale 3 $e]]];}
puts $fp {    set x4 [vscale 1/4.0 [vadd [vscale 3 $e] $a]]; }
puts $fp {    set x5 [vscale 1/4.0 [vsum [vscale 2 $b] $a $e]];}
puts $fp {    set x6 [vscale 1/2.0 [vadd $d $e]]; }
puts $fp \ \ \ \ return\ \[list\\
puts $fp \t\t\[list\ sphinx\ \ \$c\ \$x1\ \$x2\ \$x6\ \ \$d\]\\
puts $fp \t\t\[list\ sphinx\ \$x6\ \$x2\ \$x1\ \ \$c\ \$x5\]\\
puts $fp \t\t\[list\ sphinx\ \ \$b\ \$x5\ \$x3\ \$x4\ \ \$a\]\\
puts $fp \t\t\[list\ sphinx\ \$x5\ \$x3\ \$x4\ \ \$e\ \$x6\]\\
puts $fp {	       ];}
puts $fp \}
puts $fp {}
puts $fp {}
close $fp
set restore [file join subtile tiling xdanzer.tcl]
puts "restoring file $restore"
if {[catch {open $restore w} fp]} { puts "failed to create file $restore" } 
puts $fp ########################################################################
puts $fp ##
puts $fp {## Definitely not Danzer's triangular prototiles with 7-fold symmetry.}
puts $fp ##
puts $fp {## This is an erroneous dissection rule for Danzer's tiling.}
puts $fp {## In short, it isn't an aperiodic tiling at all, it's just}
puts $fp {## a recursive subdivision of the plane, of which there are}
puts $fp {## many.}
puts $fp {## The error is in failing to see that the large and small}
puts $fp {## isosceles triangles appear in left and right handed forms}
puts $fp {## in the substitution atlas.  The rule reproduced here always}
puts $fp {## uses the same handed form of the A and C triangles.}
puts $fp ##
puts $fp {lappend subtile(tilings) {{Danzer triangular 7-fold - NOT} xdanzer};}
puts $fp {}
puts $fp {set xdanzer(danzer-a) 1.0;}
puts $fp {set xdanzer(danzer-b) [expr 0.445041867913 * $xdanzer(danzer-a)];}
puts $fp {set xdanzer(danzer-c) [expr 0.801937735804 * $xdanzer(danzer-a)];}
puts $fp {set xdanzer(danzer-x) [expr (1+pow($xdanzer(danzer-b),2)-pow($xdanzer(danzer-c),2))*$xdanzer(danzer-a)/2.0];}
puts $fp {set xdanzer(danzer-y) [expr sqrt(pow($xdanzer(danzer-b),2)-pow($xdanzer(danzer-x),2))];}
puts $fp {set xdanzer(danzer-g) 0.356895867892;}
puts $fp {}
puts $fp proc\ xdanzer-about\ \{tiles\}\ \{
puts $fp \ \ \ \ about-something\ \{About\ Danzer\ NOT\}\ \{
puts $fp {	This tiling isn't even a tiling.  It's a mistake that I made}
puts $fp {	when transcribing the Danzer 7-fold tiling from Senechal's}
puts $fp {	book.  It was an instructive mistake because I hadn't yet}
puts $fp {	recognized that aperiodic substitution tilings are a very}
puts $fp {	small subset of	the set recursive planar subdivisions.}
puts $fp {	}
puts $fp {	It's interesting, too, because you can't distinguish this}
puts $fp {	substitution rule from the true Danzer 7-fold rule without the}
puts $fp {	edge markings.}
puts $fp {}
puts $fp {	It's also interesting because it's fourier transform is very}
puts $fp {	different from the others.}
puts $fp \ \ \ \ \}
puts $fp {    return $tiles;}
puts $fp \}
puts $fp {}
puts $fp set\ subtile(xdanzer-ops-menu)\ \\
puts $fp \ \ \ \ \[list\ \\
puts $fp \t\ \{\{About\ Danzer\ NOT\}\ xdanzer-about\}\ \\
puts $fp {	];}
puts $fp {}
puts $fp set\ A\ \[list\ \[list\ danzer-A\\
puts $fp \t\t\ \{0\ 0\}\\
puts $fp \t\t\ \[vmake\ \$xdanzer(danzer-b)\ 0\]\\
puts $fp \t\t\ \[vmake\ \$xdanzer(danzer-b)/2.0\ sqrt(1-pow(\$xdanzer(danzer-b)/2.0,2))\]\\
puts $fp {		]];}
puts $fp set\ BL\ \[list\ \[list\ danzer-BL\\
puts $fp \t\t\ \ \{0\ 0\}\\
puts $fp \t\t\ \ \[vmake\ \$xdanzer(danzer-a)\ 0\]\\
puts $fp \t\t\ \ \[vmake\ \$xdanzer(danzer-x)\ \$xdanzer(danzer-y)\]\\
puts $fp {		 ]];}
puts $fp set\ BR\ \[list\ \[list\ danzer-BR\\
puts $fp \t\t\ \ \[vmake\ \$xdanzer(danzer-a)\ 0\]\\
puts $fp \t\t\ \ \{0\ 0\}\\
puts $fp \t\t\ \ \[vmake\ \$xdanzer(danzer-a)-\$xdanzer(danzer-x)\ \$xdanzer(danzer-y)\]\\
puts $fp {		 ]];}
puts $fp set\ C\ \[list\ \[list\ danzer-C\\
puts $fp \t\t\ \{0\ 0\}\\
puts $fp \t\t\ \[vmake\ \$xdanzer(danzer-a)\ 0\]\\
puts $fp \t\t\ \[vmake\ \$xdanzer(danzer-a)/2.0\ sqrt(pow(\$xdanzer(danzer-c),2)-pow(\$xdanzer(danzer-a)/2.0,2))\]\\
puts $fp {		]];}
puts $fp {}
puts $fp set\ subtile(xdanzer-start-menu)\ \\
puts $fp \ \ \ \ \[list\ \\
puts $fp \t\ \[list\ \{Small\ isosceles\ triangle\}\ \$A\]\\
puts $fp \t\ \[list\ \{Scalene\ triangle\ 1\}\ \$BL\]\\
puts $fp \t\ \[list\ \{Scalene\ triangle\ 2\}\ \$BR\]\\
puts $fp \t\ \[list\ \{Large\ isosceles\ triangle\}\ \$C\]\\
puts $fp {	];}
puts $fp {}
puts $fp {}
puts $fp proc\ xdanzer-make\ \{tiles\ divide\}\ \{
puts $fp \ \ \ \ if\ \{\$divide\ ==\ 0\}\ \{
puts $fp {	return [list xdanzer $tiles];}
puts $fp \ \ \ \ \}\ else\ \{
puts $fp {	return [list xdanzer [xdanzer-dissect $tiles]];}
puts $fp \ \ \ \ \}
puts $fp \}
puts $fp {}
puts $fp proc\ xdanzer-dissect\ \{tiles\}\ \{
puts $fp {    set newt {};}
puts $fp \ \ \ \ foreach\ t1\ \$tiles\ \{
puts $fp {	set type [lindex $t1 0];}
puts $fp {	set a [lindex $t1 1];}
puts $fp {	set b [lindex $t1 2];}
puts $fp {	set c [lindex $t1 3];}
puts $fp \tswitch\ -exact\ \$type\ \{
puts $fp \t\ \ \ \ danzer-A\ \{
puts $fp {		upvar \#0 xdanzer(danzer-g) g;}
puts $fp {		set p [vadd $c [vscale $g [vsub $a $c]]];}
puts $fp {		set r [vadd $a [vscale $g [vsub $c $a]]];}
puts $fp {		set q [vadd $c [vscale $g [vsub $b $c]]];}
puts $fp {		set s [vadd $b [vscale $g [vsub $c $b]]];}
puts $fp {		set t [vadd $p [vsub $q $c]];}
puts $fp {		set u [vadd $a [vscale $g [vsub $b $a]]];}
puts $fp \t\tlappend\ newt\\
puts $fp \t\t\ \ \ \ \[list\ danzer-A\ \$p\ \$q\ \$c\]\\
puts $fp \t\t\ \ \ \ \[list\ danzer-A\ \$q\ \$p\ \$t\]\\
puts $fp \t\t\ \ \ \ \[list\ danzer-A\ \$s\ \$t\ \$b\]\\
puts $fp \t\t\ \ \ \ \[list\ danzer-A\ \$t\ \$r\ \$a\]\\
puts $fp \t\t\ \ \ \ \[list\ danzer-BR\ \$t\ \$q\ \$s\]\\
puts $fp \t\t\ \ \ \ \[list\ danzer-BR\ \$a\ \$t\ \$u\]\\
puts $fp \t\t\ \ \ \ \[list\ danzer-BL\ \$t\ \$p\ \$r\]\\
puts $fp {		    [list danzer-C $b $t $u];}
puts $fp \t\ \ \ \ \}
puts $fp {	    danzer-BL -}
puts $fp \t\ \ \ \ danzer-BR\ \{
puts $fp {		upvar \#0 xdanzer(danzer-g) g;}
puts $fp {		upvar \#0 xdanzer(danzer-a) ka;}
puts $fp {		upvar \#0 xdanzer(danzer-b) kb;}
puts $fp {		upvar \#0 xdanzer(danzer-c) kc;}
puts $fp {		set p [vadd $a [vscale $g [vsub $c $a]]];}
puts $fp {		set q [vadd $c [vscale $g*$kb/$kc [vsub $b $c]]];}
puts $fp {		set r [vadd $a [vscale $g [vsub $b $a]]];}
puts $fp {		set s [vadd $b [vscale $g*$ka/$kc [vsub $c $b]]];}
puts $fp {		set t [vadd $b [vscale $g [vsub $a $b]]];}
puts $fp \t\tlappend\ newt\\
puts $fp \t\t\ \ \ \ \[list\ danzer-A\ \$s\ \$t\ \$b\]\\
puts $fp \t\t\ \ \ \ \[list\ \$type\ \$a\ \$r\ \$p\]\\
puts $fp \t\t\ \ \ \ \[list\ \$type\ \$c\ \$r\ \$q\]\\
puts $fp \t\t\ \ \ \ \[list\ \$type\ \$s\ \$r\ \$t\]\\
puts $fp \t\t\ \ \ \ \[list\ danzer-C\ \$r\ \$c\ \$p\]\\
puts $fp {		    [list danzer-C $r $s $q];}
puts $fp \t\ \ \ \ \}
puts $fp \t\ \ \ \ danzer-C\ \{
puts $fp {		upvar \#0 xdanzer(danzer-g) g;}
puts $fp {		upvar \#0 xdanzer(danzer-a) ka;}
puts $fp {		upvar \#0 xdanzer(danzer-b) kb;}
puts $fp {		upvar \#0 xdanzer(danzer-c) kc;}
puts $fp {		set p [vadd $a [vscale $g*$kb/$kc [vsub $c $a]]];}
puts $fp {		set q [vadd $c [vscale $g*$ka/$kc [vsub $a $c]]];}
puts $fp {		set r [vadd $c [vscale $g*$kb/$kc [vsub $b $c]]];}
puts $fp {		set s [vadd $b [vscale $g*$ka/$kc [vsub $c $b]]];}
puts $fp {		set t [vadd $b [vscale $g [vsub $a $b]]];}
puts $fp {		set u [vadd $a [vscale $g [vsub $b $a]]];}
puts $fp {		set v [vadd $q [vscale $g*$kb/$kc [vsub $b $q]]];}
puts $fp {		set w [vadd $b [vscale $g*$ka/$kc [vsub $q $b]]];}
puts $fp \t\tlappend\ newt\\
puts $fp \t\t\ \ \ \ \[list\ danzer-A\ \$q\ \$v\ \$c\]\\
puts $fp \t\t\ \ \ \ \[list\ danzer-A\ \$s\ \$w\ \$b\]\\
puts $fp \t\t\ \ \ \ \[list\ danzer-A\ \$w\ \$t\ \$b\]\\
puts $fp \t\t\ \ \ \ \[list\ danzer-BL\ \$a\ \$u\ \$p\]\\
puts $fp \t\t\ \ \ \ \[list\ danzer-BL\ \$q\ \$u\ \$v\]\\
puts $fp \t\t\ \ \ \ \[list\ danzer-BL\ \$c\ \$v\ \$r\]\\
puts $fp \t\t\ \ \ \ \[list\ danzer-BL\ \$s\ \$v\ \$w\]\\
puts $fp \t\t\ \ \ \ \[list\ danzer-BL\ \$w\ \$u\ \$t\]\\
puts $fp \t\t\ \ \ \ \[list\ danzer-C\ \$u\ \$q\ \$p\]\\
puts $fp \t\t\ \ \ \ \[list\ danzer-C\ \$v\ \$s\ \$r\]\\
puts $fp {		    [list danzer-C $u $w $v];}
puts $fp \t\ \ \ \ \}
puts $fp \t\ \ \ \ default\ \{
puts $fp {		error "unknown tile type $type";}
puts $fp \t\ \ \ \ \}
puts $fp \t\}
puts $fp \ \ \ \ \}
puts $fp {    return $newt;}
puts $fp \}
puts $fp {}
puts $fp {}
close $fp
