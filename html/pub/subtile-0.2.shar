#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of shell archive."
# Contents:  subtile subtile/Makefile subtile/README subtile/ToDo
#   subtile/_fourier.c subtile/fourier subtile/lib subtile/subtile
#   subtile/tiling subtile/lib/about.tcl subtile/lib/assign.tcl
#   subtile/lib/bound-tiles.tcl subtile/lib/canvasview.tcl
#   subtile/lib/dimension-tiles.tcl subtile/lib/get-boolean.tcl
#   subtile/lib/list.tcl subtile/lib/new-window-name.tcl
#   subtile/lib/orient-tiles.tcl subtile/lib/recenter-tiles.tcl
#   subtile/lib/rescale-tiles.tcl subtile/lib/scale.tcl
#   subtile/lib/scroll.tcl subtile/lib/tclIndex
#   subtile/lib/textview.tcl subtile/lib/vector.tcl
#   subtile/lib/vertex-atlas.tcl subtile/tiling/ammann.tcl
#   subtile/tiling/binary.tcl subtile/tiling/chair.tcl
#   subtile/tiling/danzer.tcl subtile/tiling/penrose.tcl
#   subtile/tiling/pinwheel.tcl subtile/tiling/sphinx.tcl
#   subtile/tiling/xdanzer.tcl
# Wrapped by rec@elf115.elf.org on Tue Sep 26 22:10:32 1995
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test ! -d 'subtile' ; then
    echo shar: Creating directory \"'subtile'\"
    mkdir 'subtile'
fi
if test -f 'subtile/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'subtile/Makefile'\"
else
echo shar: Extracting \"'subtile/Makefile'\" \(273 characters\)
sed "s/^X//" >'subtile/Makefile' <<'END_OF_FILE'
XVERSION=0.2
Xall: _fourier
X	cd lib; echo  'auto_mkindex . *.tcl' | tclsh
X
X_fourier: _fourier.c
X	$(CC) -O -o _fourier _fourier.c -lm
X
Xclean:
X	rm -f _fourier *~ tiling.ps */*~ */\#* */core
X
Xshar: clean
X	cd ..;	shar subtile subtile/* subtile/*/* > /tmp/subtile-$(VERSION).shar
END_OF_FILE
if test 273 -ne `wc -c <'subtile/Makefile'`; then
    echo shar: \"'subtile/Makefile'\" unpacked with wrong size!
fi
# end of 'subtile/Makefile'
fi
if test -f 'subtile/README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'subtile/README'\"
else
echo shar: Extracting \"'subtile/README'\" \(6091 characters\)
sed "s/^X//" >'subtile/README' <<'END_OF_FILE'
X------------------------------------------------------------------------
Xsubtile - a program for generating and drawing aperiodic tilings which
Xare generated by substitution, or composition, rules and examining the
Xfourier transforms of their vertex sets.
X
XCopyright 1995 by Roger Evans Critchlow Jr, San Francisco, California.
XAll rights reserved, fair use permitted, no warranty.
X
Xrec@elf.org, August 17, 1995
X
X------------------------------------------------------------------------
X
XThis program was inspired by Marjorie Senechal (Quasicrystals and
XGeometry, Cambridge UP, Cambridge, 1995), with contributing
Xinspirations from Branko Gruenbaum and G. C. Shephard (Tilings and
XPatterns, WH Freeman, New York, 1987).
X
XThese programs were developed with the aid of materials which Marjorie
XSenechal made available at ftp://minkowski.smith.edu, namely
XMathematica programs for computing some tilings and a C program,
Xwritten by Stuart Levy, for computing the fourier transform of a set
Xof points in the plane.
X
X------------------------------------------------------------------------
X    
XThere are three programs in this package:
X
Xsubtile - a program written in the Tcl language using the Tk GUI
X    toolkit to compute and display substitution tilings.  subtile
X    consists of the main source file, subtile, several library sources
X    in the directory ./lib, and tiling implementation files in the
X    directory ./tiling.
X
Xfourier - a program written in the Tcl language using the Tk GUI
X    toolkit to compute and display fourier transforms of point sets in
X    the plane.  fourier consists solely of its main source file,
X    fourier.  If possible, it compiles and uses the C program
X    _fourier.c to actually compute the fourier transform.
X
X_fourier.c - a program written in C to compute fourier transforms of
X    points in the plane.  It is based on Stuart Levy's program with
X    the computation somewhat rearranged.
X
X------------------------------------------------------------------------    
X
XAcquisition and installation.
X
XThe sources are available from:
X
X	ftp://ftp.bdt.com/home/elf/pub/subtile-0.2.shar 
X
XThey require the Tcl-7.4/Tk-4.0 distribution, specifically the wish4.0
Xinterpreter and its associated libraries.  The first lines of subtile
Xand fourier may need to be modified if your wish4.0 isn't found in the
Xdefault location, namely /usr/local/bin/wish4.0.  If your copy of
Xwish4.0 is found in /usr/bin/wish4.0, then you would change the first
Xlines of subtile and fourier to read:
X
X#!/usr/bin/wish4.0
X
X[The even more recent Tcl-7.5/Tk-4.1 distribution will also work.]
X
XThe supplied Makefile will compile _fourier.c, if possible and it
Xshould be possible on any machine that hosts a C compiler.
X
X------------------------------------------------------------------------
X
XUsing the programs.
X
Xsubtile uses the Tk GUI toolkit to present a graphical user interface.
XYou can probably use it without these instructions, just type subtile
Xto get it going.
X
Xsubtile presents a simple menu and a catalog of initial tilings.  The
Xmenu allows you to display this documentation or quit.  Click with the
Xleft mouse button on an initial tiling to select it.
X
XA subtile window will be drawn with the selected tiling and a menu of
Xoperations.  The operations menu may be modified as operations are
Xperformed.
X
XThe operations menu always provides entries for:
X
X	resetting the current tiling to its initial subdivision.
X	subdividing the current tiling.
X	computing the vertex atlas of the currently displayed
X		tiling (sometimes).
X	computing the fourier transform of the current tiling.
X	saving a postscript drawing of the current tiling.
X    	enabling tile by tile display rather than waiting for all
X		tiles to be drawn.
X	enabling overlay of successive drawings. 
X
XThe operations menu will also present tiling specific operations.
X
XSpecifically, the Penrose tilings implement operations for
Xinterconversions among:
X
X	kite and dart tiling
X	A triangulation
X	B triangulation
X	rhombic tiling
X
XAnd if you want the subdivide a Penrose tiling, you should convert
Xto the A or B triangulation first, subdivide, and then anneal back
Xto the original tiling.
X
XThe subtile window may be resized under window manager control.
X    
XThe subtile window may be scrolled using the scrollbars which are
Xadjacent to it, or by pressing the middle mouse button inside the
Xcanvas and dragging the canvas in the desired direction.
X    
XThe tiling may be scaled in size by pressing the right mouse button
Xand dragging toward or away from the upper left corner of the window.
X    
XScrolling and scaling may be done while a tiling is being constructed
Xif tile by tile display is enabled.
X
XThe tiles in a displayed tiling may be deleted by clicking on them
Xwith the left mouse button.  Deleted tiles may be undeleted by clicking
Xon them with the left mouse button, too.
X
XThe fourier program presents menues for:
X
X	operations to be performed
X	size of image to be computed
X	srange, or the range of fourier space to be computed
X	brightness of the image displayed
X
XThe transform is computed without any brightness scaling so the
Xbrightness may be adjusted after the transform computation is begun.
X
XA good strategy is to use small image sizes, eg 64, until you've found
Xthe appropriate srange, because the transform requires size^2
Xcomputations to complete.
X
X------------------------------------------------------------------------
X
XTo do list for subtile:
X
X   4) make dissections go in adjacent pieces.
X   8) color the tiles
X   10) clip a tiling to a disk or polygon
X   14) graphically edit prototiles and dissection rules
X   16) generate vertex atlases
X   17) generate tile names from vertex atlases
X   18) color tiles according to names
X   19) save and restore tilings as tcl
X   20) reproduce edge markings
X
XTo do list for fourier:
X
X   1) allow the computation to be aborted
X   2) save images to ppm files
X   3) reload saved images
X   4) compute layers to improve the resolution of an existing image
X
X------------------------------------------------------------------------
X
X-- rec@elf.org --
XSeptember 26, 1995
X
END_OF_FILE
if test 6091 -ne `wc -c <'subtile/README'`; then
    echo shar: \"'subtile/README'\" unpacked with wrong size!
fi
# end of 'subtile/README'
fi
if test -f 'subtile/ToDo' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'subtile/ToDo'\"
else
echo shar: Extracting \"'subtile/ToDo'\" \(55 characters\)
sed "s/^X//" >'subtile/ToDo' <<'END_OF_FILE'
X2) Allow sweeping deletions
X4) Generate vertex atlases
END_OF_FILE
if test 55 -ne `wc -c <'subtile/ToDo'`; then
    echo shar: \"'subtile/ToDo'\" unpacked with wrong size!
fi
# end of 'subtile/ToDo'
fi
if test -f 'subtile/_fourier.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'subtile/_fourier.c'\"
else
echo shar: Extracting \"'subtile/_fourier.c'\" \(2290 characters\)
sed "s/^X//" >'subtile/_fourier.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include <stdlib.h>
X#include <math.h>		/* Declares sin(), cos(), etc. */
X
X/*
X * To compile:
X *	cc -o _fourier  _fourier.c -lm
X */
X
Xstruct point {
X    double x, y;
X};
X
Xvoid fatal(char *msg)
X{
X  fprintf(stderr, "_fourier: %s\n", msg);
X  exit(1);
X}
X
Xmain(int argc, char *argv[])
X{
X  int n;							/* width and height of image */
X  double srange;						/* width/2 and height/2 of fourier space */
X  double scale;							/* scaling applied to magnitude */
X  int w, i, j, k;
X  struct point s;
X  struct point *source;
X  double re, im, *coeff;
X  int nsource;
X  double dot, mag;
X  int imag;
X
X  /*
X   * Read parameters.
X   */
X  if (argc != 1)
X    fatal("wrong number of arguments");
X  if (3 != scanf("%d %lf %d\n", &n, &srange, &nsource))
X    fatal("incomplete parameter line");
X  if (n <= 0)
X    fatal("size of image must be greater than 0");
X  if (srange <= 0)
X    fatal("range of fourier space must be greater than 0");
X
X  /*
X   * Allocate and read light sources.
X   */
X  source = (struct point *)malloc(nsource * sizeof(struct point));
X  for (i = 0; i < nsource; i += 1)
X    if (2 != scanf("%lf %lf\n", &source[i].x, &source[i].y))
X      fatal("bad point line");
X
X  /*
X   * Pre compute coefficients
X   */
X  coeff = calloc(n, sizeof(double));
X  for (i = 0; i < n; i += 1)
X    coeff[i] = 2 * M_PI * srange * ((float)i/(n-1) - .5);
X
X  scale = nsource > 0 ? 1.0 / nsource : 1;
X
X  /*
X   * Compute transform by blocks, starting from a block that sets the
X   * entire image to the value of the 0,0 pixel, then computing the
X   * other three quadrants of the image, and continuing by computing
X   * subquadrants until the individual pixels are done.
X   */
X  for (w = n; w >= 1; w /= 2) {
X    int wt2 = 2*w;
X    for (i = 0; i < n; i += w) {
X      s.y = coeff[i];
X      for (j = 0; j < n; j += w) {
X	if ((i%wt2) != 0 || (j%wt2) != 0 || w == n) {
X	  s.x = coeff[j];
X	  re = im = 0;
X	  for(k = 0; k < nsource; k++) {
X	    dot = s.x*source[k].x + s.y*source[k].y;
X	    re += cos(dot);
X	    im += sin(dot);
X	  }
X	  mag = scale * sqrt(re*re + im*im);
X	  /*
X	   * Report the current estimate for the magnitude in the rectangle
X	   * from j i to j+w i+w, namely the magnitude at j i.
X	   */
X	  printf("%f %d %d %d %d\n", mag, j, i, j+w, i+w);
X	  fflush(stdout);
X	}
X      }
X    }
X  }
X  exit(0);
X}
X
END_OF_FILE
if test 2290 -ne `wc -c <'subtile/_fourier.c'`; then
    echo shar: \"'subtile/_fourier.c'\" unpacked with wrong size!
fi
# end of 'subtile/_fourier.c'
fi
if test -f 'subtile/fourier' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'subtile/fourier'\"
else
echo shar: Extracting \"'subtile/fourier'\" \(5311 characters\)
sed "s/^X//" >'subtile/fourier' <<'END_OF_FILE'
X#!/usr/local/bin/wish4.0
X
X#
X# a program to compute and display fourier transforms of a point set
X# in two dimensions.
X#
X
X#
X# input data
X#
Xset fourier(points) [split [read stdin] \n];
Xset fourier(npoints) [llength $fourier(points)]
X
X#
X# parameters for the user interface
X#
Xset fourier(size) 256;
Xset fourier(size-menu) {16 32 64 128 256 512 1024};
Xset fourier(srange) 50;
Xset fourier(srange-menu) {200 150 100 90 80 70 60 50 40 30 20 10}
Xset fourier(brightness) 2;
Xset fourier(brightness-menu) {1 1.5 2 3 4 5 10 20 40 80 100 120}
X
X#
X# computed variables
X#
Xset fourier(scale) [expr $fourier(brightness)*256.0];
Xset fourier(percent) 0;
Xset fourier(image) {};
X
X#
X# menubutton frame
X#
Xpack [frame .m -border 2 -relief raised] -fill x;
X
X#
X# operations menu
X#
Xpack [menubutton .m.o -text Operations -menu .m.o.m] -side left;
Xmenu .m.o.m -tearoff no;
X.m.o.m add command -label Fourier -command fourier
X.m.o.m add separator
X.m.o.m add command -label Quit -command {destroy .}
X
X#
X# parameter menu
X#
Xpack [menubutton .m.p -text Parameters -menu .m.p.m] -side left
Xmenu .m.p.m -tearoff no;
X.m.p.m add cascade -label Size -menu .m.p.m.n;
X.m.p.m add cascade -label Srange -menu .m.p.m.s;
X.m.p.m add cascade -label Brightness -menu .m.p.m.b;
X
X#
X# image size submenu
X#
Xmenu .m.p.m.n -tearoff no;
Xforeach v $fourier(size-menu) {
X    .m.p.m.n add radiobutton -label $v -value $v -variable fourier(size) -command {.c configure -width $fourier(size) -height $fourier(size)};
X}
X
X#
X# fourier space range submenu
X#
Xmenu .m.p.m.s -tearoff no;
Xforeach v $fourier(srange-menu) {
X    .m.p.m.s add radiobutton -label $v -value $v -variable fourier(srange);
X}
X
X#
X# brightness menu
X#
Xmenu .m.p.m.b -tearoff no;
Xforeach v $fourier(brightness-menu) {
X    .m.p.m.b add radiobutton -label $v -value $v -variable fourier(brightness) -command set-brightness;
X}
X
X#
X# number of vertices in data set
X#
Xpack [label .m.n -text "$fourier(npoints) points"] -side left;
X
X#
X# canvas for displaying results
X#
Xpack [canvas .c -width $fourier(size) -height $fourier(size)] -fill both -expand true;
Xpack [scale .s -orient horizontal -from 0 -to 1000 -label {} -showvalue false -variable fourier(percent) -state disabled] -side top -fill x;
X
X#
X# compute the fourier transform
X#
Xproc fourier {} {
X    global fourier;
X    .c delete all;
X    set fourier(image) {};
X    set fourier(picture) [image create photo -height $fourier(size) -width $fourier(size)];
X    .c create image 0 0 -anchor nw -image $fourier(picture);
X    transform $fourier(picture) $fourier(size) $fourier(srange) $fourier(npoints) $fourier(points);
X}
X
X#
X# decide whether the _fourier.c program can be used
X#
Xproc transform {image n srange npoints points} {
X    if {[file exists _fourier]
X     || ([file exists _fourier.c] && [catch {exec cc -o _fourier _fourier.c -lm}] == 0)} {
X	fast-transform;
X    } else {
X	slow-transform;
X    }
X}
X	
X#
X# start the progress monitor
X#
Xproc init-progress {n} {
X    global fourier;
X    set fourier(percent) 0;
X    .s configure -from 0 -to [expr $n*$n];
X}
X
X#
X# update the progress monitor
X#
Xproc incr-progress {} {
X    global fourier;
X    .s configure -state normal;
X    incr fourier(percent);
X    .s configure -state disabled;
X}
X
X#
X# draw pixels to the output image
X#
Xproc image-pixels {mag x y xn yn} {
X    global fourier;
X    set mag [expr int($fourier(scale) * $mag)];
X    if {$mag > 255} {
X	set mag ff;
X    } else {
X	set mag [format %02x $mag];
X    }
X    $fourier(picture) put "{{\#$mag$mag$mag}}" -to $x $y $xn $yn;
X}
X
X#
X# adjust the brightness
X#
Xproc set-brightness {} {
X    global fourier;
X    set fourier(scale) [expr $fourier(brightness)*256.0];
X    foreach region $fourier(image) {
X	eval image-pixels $region;
X	update;
X    }
X}
X
X#
X# add pixels to the output image
X#
Xproc set-pixels {mag x y xn yn} {
X    global fourier;
X    lappend fourier(image) [list $mag $x $y $xn $yn];
X    image-pixels $mag $x $y $xn $yn;
X}
X
X#
X# compute the fourier transform in tcl, slowly
X#
Xproc slow-transform {} {
X    upvar n n srange srange npoints npoints points points;
X    set pi [expr 4*atan(1)];
X    if {$npoints == 0} {
X	set scale 1;
X    } else { 
X        set scale [expr 1.0 / $npoints];
X    }
X    for {set i 0} {$i < $n} {incr i} {
X	set c($i) [expr 2 * $pi * $srange * (double($i) / ($n-1) - .5)];
X    }
X    init-progress $n;
X    for {set w $n} {$w >= 1} {set w [expr $w/2]} {
X	set wt2 [expr $w*2];
X	for {set i 0} {$i < $n} {incr i $w} {
X	    set y $c($i);
X	    for {set j 0} {$j < $n} {incr j $w} {
X		if {($i%$wt2) != 0 || ($j%$wt2) != 0 || $w == $n} {
X		    set x $c($j);
X		    set re 0;
X		    set im 0;
X		    foreach p $points {
X			set dot $x*[lindex $p 0]+$y*[lindex $p 1];
X			append re +cos($dot);
X			append im +sin($dot);
X		    }
X		    set re [expr $re];
X		    set im [expr $im];
X		    set mag [expr $scale * sqrt($re*$re + $im*$im)];
X		    set-pixels $mag $j $i [expr $j+$w] [expr $i+$w];
X		    incr-progress;
X		    update;
X		}
X	    }
X	}
X    }
X}
X
X#
X# compute the fourier transform with a C program
X#
Xproc fast-transform {} {
X    global fourier;
X    upvar n n srange srange npoints npoints points points;
X    set input "$n $srange $npoints\n[join $points \n]";
X    set fp [open "|_fourier << {$input}" r];
X    init-progress $n;
X    set fourier(image) {};
X    while {[gets $fp line] >= 0} {
X	eval set-pixels $line;
X	incr-progress;
X	update;
X    }
X    close $fp;
X}
X
END_OF_FILE
if test 5311 -ne `wc -c <'subtile/fourier'`; then
    echo shar: \"'subtile/fourier'\" unpacked with wrong size!
fi
chmod +x 'subtile/fourier'
# end of 'subtile/fourier'
fi
if test ! -d 'subtile/lib' ; then
    echo shar: Creating directory \"'subtile/lib'\"
    mkdir 'subtile/lib'
fi
if test -f 'subtile/subtile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'subtile/subtile'\"
else
echo shar: Extracting \"'subtile/subtile'\" \(12533 characters\)
sed "s/^X//" >'subtile/subtile' <<'END_OF_FILE'
X#!/usr/local/bin/wish4.0
X
X########################################################################
X##
X## If you want to install subtile as a command, then set this
X## variable to point to the source directory so that the library
X## functions and tilings can be loaded.
X##
Xset subtile(home) .;
X
X########################################################################
X##
X## load library sources
X##
Xlappend auto_path $subtile(home)/lib;
X
X########################################################################
X##
X## load tiling definitions.
X##
Xset tcl_precision 17;
X
Xset Pi [expr 4*atan(1)];
Xset Tau [expr (1+sqrt(5))/2];
Xset Sqrt2 [expr sqrt(2)];
X
Xforeach t {penrose ammann danzer xdanzer binary pinwheel sphinx chair} {
X    source $subtile(home)/tiling/$t.tcl;
X}
X
Xset tcl_precision 6
X
X########################################################################
X##
X## default parameter values
X##
Xset subtile(no-draw) 0;
Xset subtile(scale) 80;
Xset subtile(edge) 200;
Xset subtile(overlay) 1;
Xset subtile(watch-tiles) 0;
Xset subtile(background) white;
Xset subtile(fill) {};
Xset subtile(activeFill) grey;
X
X########################################################################
X##
X## main window.
X##
X## the main window has a menu button on top
X## and a scrollable canvas below.  The scrollable
X## canvas is used to present a graphical menu of
X## tilings and start patterns.
X##
Xpack [frame .m -border 2 -relief raised] -side top -fill x
Xpack [frame .c] -fill both -expand true;
X
X#
X# the menu
X#
Xpack [menubutton .m.o -text Menu -menu .m.o.m] -side left
Xmenu .m.o.m -tearoff no;
X.m.o.m add command  -label {About Subtile} -command about-subtile
X.m.o.m add separator;
X.m.o.m add command -label Quit -command {destroy .}
X
Xproc about-subtile {} {
X    global subtile;
X    about-something {About Subtile} [exec cat $subtile(home)/README];
X}
X
X########################################################################
X##
X## tiling window.
X## when an initial tile or tiling is selected,
X## a tiling window is popped up with a menu and
X## the initial tiling.
X##
Xproc new-subtiling {} {
X    global subtile;
X    set w [new-window-name];
X    set start $subtile(start);
X    set tiling $subtile(tiling);
X    set scale $subtile(edge);
X    set background $subtile(background);
X    set fill $subtile(fill);
X    set activeFill $subtile(activeFill);
X
X    upvar \#0 $w subtile;
X    set subtile(scale) $scale;
X    set subtile(overlay) 0;
X    set subtile(watch-tiles) 1;
X    set subtile(no-draw) 0;
X    set subtile(start) $start;
X    set subtile(start-tiling) $tiling;
X    set subtile(tiling) $tiling;
X    set subtile(postscript) tiling.ps;
X    set subtile(landscape) 0;
X    set subtile(colormode) gray;
X    set subtile(background) $background;
X    set subtile(fill) $fill;
X    set subtile(activeFill) $activeFill;
X
X    toplevel $w;
X    wm title $w $subtile(tiling);
X    pack [frame $w.m -border 2 -relief raised] -side top -fill x;
X    pack [menubutton $w.m.o -text Operations -menu $w.m.o.m] -side left -anchor w;
X    update-ops-menu $w;
X    pack [canvas $w.c \
X	      -bg $subtile(background) \
X	      -width [expr 10+$subtile(scale)] \
X	      -height [expr 10+$subtile(scale)] \
X	      -xscrollincrement 1 \
X	      -yscrollincrement 1 \
X	     ] -fill both -expand true
X
X    #
X    # the canvas is configured to be larger than the displayed region
X    # mouse button 2 allows you to push the displayed region around
X    # mouse button 3 allows you to rescale the displayed image
X    #
X    $w.c bind tile <Enter> "$w.c itemconfigure current -fill {$subtile(activeFill)}";
X    $w.c bind tile <Leave> "$w.c itemconfigure current -fill {$subtile(fill)}";
X    $w.c bind tile <1> "delete-tile $w";
X    bind $w.c <2> "scroll-mark $w %x %y";
X    bind $w.c <Button2-Motion> "scroll-dragto $w %x %y";
X    bind $w.c <3> "scale-mark $w %x %y";
X    bind $w.c <Button3-Motion> "scale-dragto $w %x %y";
X
X    draw-subtiling $w;
X}
X
X#
X# rewrite the operation menu when the tiling changes
X#
Xproc update-ops-menu {w} {
X    global subtile;
X    upvar \#0 $w data;
X    set args $subtile($data(tiling)-ops-menu);
X    catch {destroy $w.m.o.m};
X    menu $w.m.o.m -tearoff no;
X    $w.m.o.m add command -label {Subdivide Tiling} -command "draw-subtiling $w";
X    $w.m.o.m add command -label {Reset Tiling} -command "reset-subtiling $w";
X    $w.m.o.m add command -label {Vertex Atlas} -command "vertex-atlas-subtiling $w";
X    $w.m.o.m add command -label {Fourier Map} -command "fourier-subtiling $w";
X    $w.m.o.m add command -label {Save Postscript} -command "save-subtiling $w";
X    $w.m.o.m add separator;
X    if {[llength $args]} {
X	foreach arg $args {
X	    set title [lindex $arg 0];
X	    set command [lindex $arg 1];
X	    $w.m.o.m add command -label $title -command "operate-subtiling $w {$command}";
X	}
X	$w.m.o.m add separator;
X    }
X    $w.m.o.m add checkbutton -label {Watch Tiling} -variable ${w}(watch-tiles);
X    $w.m.o.m add checkbutton -label {Overlay Tiling} -variable ${w}(overlay);
X    $w.m.o.m add separator;
X    $w.m.o.m add command -label Dismiss -command "destroy $w";
X}
X
X#
X# delete or undelete tiles from the current tiling
X#
Xproc delete-tile {w} {
X    upvar \#0 $w subtile;
X    foreach tag [$w.c gettags current] {
X	if {[regexp {^t([0-9]+)$} $tag all index]} {
X	    if {"[$w.c itemcget current -outline]" == {}} {
X		# undelete
X		$w.c itemconfigure current -fill $subtile(fill) -outline black;
X		set i [lsearch $subtile(deleted) $index];
X		set subtile(deleted) [lreplace $subtile(deleted) $i $i];
X	    } else {
X		# delete
X		$w.c itemconfigure current -fill {} -outline {};
X		lappend subtile(deleted) $index;
X	    }
X	}
X    }
X}
X
X#
X# start a new drawing
X#
Xproc start-tile-drawing {w} {
X    upvar \#0 $w subtile
X    if { ! $subtile(no-draw)} {
X	if { ! $subtile(overlay)} {
X	    $w.c delete all;
X	}
X    }
X}
X
X#
X# draw one tile
X#
Xproc draw-tile {w tags tile} {
X    upvar \#0 $w subtile
X    set id [eval $w.c create polygon [join [lrange $tile 1 end] { }]];
X    $w.c itemconfigure $id -tags $tags -fill $subtile(fill) -outline black;
X    $w.c scale $id 0 0 $subtile(scale) $subtile(scale);
X    if {$subtile(watch-tiles)} {
X	update;
X    }
X}
X
X#
X# draw all the tiles in a tiling
X#
Xproc draw-tiling {w tags tiles} {
X    upvar \#0 $w subtile;
X    if {$subtile(no-draw) != 1} {
X	start-tile-drawing $w;
X	set n -1;
X	foreach tile $tiles {
X	    draw-tile $w "$tags t[incr n]" $tile;
X	}
X    }
X}
X
X#
X# evaluate without any drawing
X#
Xproc with-no-drawing {w cmd} {
X    upvar \#0 $w subtile
X    set save $subtile(no-draw);
X    set subtile(no-draw) 1;
X    if {[catch {uplevel $cmd} result]} {
X	set subtile(no-draw) $save;
X	global errorInfo;
X	error $result $errorInfo;
X    } else {
X	set subtile(no-draw) $save;
X	return $result;
X    }
X}
X
X########################################################################
X##
X## user interface commands
X##
Xproc reset-subtiling {w} {
X    upvar \#0 $w subtile
X    set subtile(tiling) $subtile(start-tiling);
X    wm title $w $subtile(tiling);
X    update-ops-menu $w;
X    unset subtile(current-tiling);
X    draw-subtiling $w;
X}
X
Xproc draw-subtiling {w} {
X    upvar \#0 $w subtile
X    if {[info exists subtile(current-tiling)]} {
X	update-subtiling $w [$subtile(tiling)-make [current-subtiling $w] 1];
X    } else {
X	update-subtiling $w [$subtile(tiling)-make $subtile(start) 0];
X    }
X    if {$subtile(no-draw) != 1 && "$subtile(current-tiling)" != {}} {
X	draw-tiling $w tile $subtile(current-tiling);
X    }
X}
X
Xproc fourier-subtiling {w} {
X    upvar \#0 $w subtile
X    foreach tile $subtile(current-tiling) {
X	foreach p [lrange $tile 1 end] {
X	    set xy($p) {};
X	}
X    }
X    exec fourier << [join [array names xy] \n] &;
X}
X
Xproc operate-subtiling {w command} {
X    upvar \#0 $w subtile
X    if {[string match *-about* $command]} {
X	$command {};
X    } elseif {[info exists subtile(current-tiling)]} {
X	with-no-drawing $w {
X	    update-subtiling $w [$command [current-subtiling $w]];
X	}
X	draw-tiling $w tile $subtile(current-tiling);
X    }
X}
X
Xproc current-subtiling {w} {
X    upvar \#0 $w subtile
X    if {[info exists subtile(deleted)]} {
X	set newts {}
X	set i 0;
X	foreach tile $subtile(current-tiling) {
X	    if {[lsearch $subtile(deleted) $i] < 0} {
X		lappend newts $tile;
X	    }
X	    incr i;
X	}
X	unset subtile(deleted);
X	return $newts;
X    } else {
X	return $subtile(current-tiling);
X    }
X}
X
Xproc update-subtiling {w tt} {
X    upvar \#0 $w subtile
X    set tiling [lindex $tt 0];
X    set subtile(current-tiling) [lindex $tt 1];
X    if {"$tiling" != "$subtile(tiling)"} {
X	set subtile(tiling) $tiling;
X	wm title $w $tiling;
X	update-ops-menu $w;
X    }
X}
X
Xproc save-subtiling {w} {
X    upvar \#0 $w subtile
X    set wp ${w}ps
X    if {[winfo exists $wp]} {
X	wm deiconify $wp;
X	wm raise $wp;
X    } else {
X	toplevel $wp;
X	wm title $wp "Save $subtile(tiling)";
X	pack [frame $wp.f0] -side top;
X	pack [label $wp.f0.l -text {File:}] -side left;
X	pack [entry $wp.f0.e -textvariable ${w}(postscript)] -side left -expand true -fill x;
X	pack [checkbutton $wp.landscape -text {Landscape} -variable ${w}(landscape)] -side top -anchor w;
X	pack [radiobutton $wp.color -text {Color} -variable ${w}(colormode) -value color] -side top -anchor w;
X	pack [radiobutton $wp.gray -text {Gray}  -variable ${w}(colormode) -value gray] -side top -anchor w;
X	pack [radiobutton $wp.mono -text {Monochrome}  -variable ${w}(colormode) -value mono] -side top -anchor w;
X	pack [button $wp.save -text {Save} -command "do-save-subtiling $w"] -side top;
X    }
X}
X
Xproc do-save-subtiling {w} {
X    upvar \#0 $w subtile
X    $w.c postscript -file $subtile(postscript) -rotate $subtile(landscape) -colormode $subtile(colormode);
X}
X
Xproc vertex-atlas-subtiling {w} {
X    upvar \#0 $w subtile
X    set tilings [vertex-atlas-tiling $subtile(current-tiling)];
X    #puts "reviewed vertices";
X    set w [new-window-name];
X    toplevel $w;
X    catalog-tilings $w "Vertex atlas of $subtile(tiling)" $subtile(tiling) $tilings;
X}
X
X########################################################################
X#
X# tiling catalogs.
X# 
X#
X
X#
X# normalize a tiling collection.
X# the tilings are rescaled by a common factor such that the largest member
X# fills the unit square, and all are centered in the unit square.
X#
Xproc normalize-collection {collection} {
X    pset dx dy [dimension-collection $collection];
X    if {$dx > $dy} {
X	set s [expr 0.9/$dx]
X    } else {
X	set s [expr 0.9/$dy]
X    }
X    return [recenter-collection [rescale-collection $s $collection]];
X}
X
Xproc catalog-tilings {w title value tilings} {
X    if { ! [winfo exists $w.c]} {
X	global subtile $w;
X
X	foreach name {no-draw scale overlay watch-tiles background fill activeFill} {
X	    set ${w}($name) $subtile($name);
X	}
X	set ${w}(fill) white;
X	set ${w}(x) 5;
X	set ${w}(y) 5;
X	set ${w}(dx) [expr $subtile(scale)+10];
X	set ${w}(dy) [expr $subtile(scale)+10];
X
X	pack [canvasview $w.c \
X	  -bg $subtile(background) \
X	  -vscroll 1 \
X	  -xscrollincrement 1 \
X	  -yscrollincrement 1 \
X	 ] -fill both -expand true
X
X	bind $w.c <2> "scroll-mark $w %x %y";
X	bind $w.c <Button2-Motion> "scroll-dragto $w %x %y";
X	bind $w.c <3> "scale-mark $w %x %y";
X	bind $w.c <Button3-Motion> "scale-dragto $w %x %y";
X    }
X
X    upvar \#0 $w subtile;
X
X    # write the title for this tiling
X    $w.c create text $subtile(x) $subtile(y) -text $title -anchor nw -tag at$subtile(y);
X    set subtile(y) [expr 5+[lindex [$w.c bbox at$subtile(y)] 3]];
X
X    # draw the initial tiles for this tiling
X    set n [llength $tilings];
X    #puts "display $n tilings\n[join $tilings \n]";
X    foreach arg [normalize-collection $tilings] {
X	if {($n == 4 && $subtile(x) > 2*$subtile(dx)) || $subtile(x) > 3*$subtile(dx)} {
X	    set subtile(x) 5;
X	    incr subtile(y) $subtile(dy);
X	}
X	set tag "$title [lindex $arg 0]";
X	regsub -all { } $tag - tag;
X	draw-tiling $w $tag [lindex $arg 1];
X	$w.c move $tag $subtile(x) $subtile(y);
X	$w.c bind $tag <Enter> "$w.c itemconfigure current -fill {$subtile(activeFill)}";
X	$w.c bind $tag <Leave> "$w.c itemconfigure current -fill {$subtile(fill)}";
X	$w.c bind $tag <1> "set subtile(tiling) $value; set subtile(start) {[lindex $arg 1]}; new-subtiling";
X	incr subtile(x) $subtile(dx);
X    }
X    set subtile(x) 5;
X    incr subtile(y) $subtile(dy);
X    $w.c configure -scrollregion "0 0 [expr 3*$subtile(dx)+10] $subtile(y)" -width [expr 3*$subtile(dx)+10];
X}
X
X########################################################################
X##
X## build the initial tiling catalog.
X##
Xforeach tiling $subtile(tilings) {
X    set title [lindex $tiling 0];
X    set value [lindex $tiling 1];
X    set tiles $subtile($value-start-menu);
X    catalog-tilings .c $title $value $tiles;
X}
END_OF_FILE
if test 12533 -ne `wc -c <'subtile/subtile'`; then
    echo shar: \"'subtile/subtile'\" unpacked with wrong size!
fi
chmod +x 'subtile/subtile'
# end of 'subtile/subtile'
fi
if test ! -d 'subtile/tiling' ; then
    echo shar: Creating directory \"'subtile/tiling'\"
    mkdir 'subtile/tiling'
fi
if test -f 'subtile/lib/about.tcl' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'subtile/lib/about.tcl'\"
else
echo shar: Extracting \"'subtile/lib/about.tcl'\" \(372 characters\)
sed "s/^X//" >'subtile/lib/about.tcl' <<'END_OF_FILE'
Xproc about-something {title information} {
X    if {[winfo exists .about]} {
X	wm deiconify .about;
X	.about.t delete 0.0 end
X    } else {
X	toplevel .about;
X	pack [textview .about.t -vscroll 1] -side top -fill both -expand true;
X	pack [button .about.q -text Done -command {destroy .about}] -side top;
X    }
X    wm title .about $title
X    .about.t insert end $information;
X}
X
END_OF_FILE
if test 372 -ne `wc -c <'subtile/lib/about.tcl'`; then
    echo shar: \"'subtile/lib/about.tcl'\" unpacked with wrong size!
fi
# end of 'subtile/lib/about.tcl'
fi
if test -f 'subtile/lib/assign.tcl' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'subtile/lib/assign.tcl'\"
else
echo shar: Extracting \"'subtile/lib/assign.tcl'\" \(220 characters\)
sed "s/^X//" >'subtile/lib/assign.tcl' <<'END_OF_FILE'
Xproc pset {args} {
X    set n [llength $args];
X    set vals [lindex $args [incr n -1]];
X    foreach name [lrange $args 0 [incr n -1]] {
X	upvar $name var;
X	set var [lindex $vals 0];
X	set vals [lrange $vals 1 end];
X    }
X}
END_OF_FILE
if test 220 -ne `wc -c <'subtile/lib/assign.tcl'`; then
    echo shar: \"'subtile/lib/assign.tcl'\" unpacked with wrong size!
fi
# end of 'subtile/lib/assign.tcl'
fi
if test -f 'subtile/lib/bound-tiles.tcl' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'subtile/lib/bound-tiles.tcl'\"
else
echo shar: Extracting \"'subtile/lib/bound-tiles.tcl'\" \(1248 characters\)
sed "s/^X//" >'subtile/lib/bound-tiles.tcl' <<'END_OF_FILE'
X#
X# bound a tile
X#
Xproc bound-tile {tile} {
X    pset xmin ymin [lindex $tile 1];
X    pset xmax ymax "$xmin $ymin";
X    foreach point [lrange $tile 2 end] {
X	pset x y $point;
X	if {$x < $xmin} {
X	    set xmin $x;
X	} elseif {$x > $xmax} {
X	    set xmax $x;
X	}
X	if {$y < $ymin} {
X	    set ymin $y;
X	} elseif {$y > $ymax} {
X	    set ymax $y;
X	}
X    }
X    return "$xmin $ymin $xmax $ymax";
X}
X
X#
X# bound a tiling
X#
Xproc bound-tiling {tiles} {
X    pset xmin ymin xmax ymax [bound-tile [lindex $tiles 0]];
X    foreach tile [lrange $tiles 1 end] {
X	pset x0 y0 x1 y1 [bound-tile $tile];
X	if {$x0 < $xmin} {
X	    set xmin $x0;
X	}
X	if {$x1 > $xmax} {
X	    set xmax $x1;
X	}
X	if {$y0 < $ymin} {
X	    set ymin $y0;
X	}
X	if {$y1 > $ymax} {
X	    set ymax $y1;
X	}
X    }
X    return "$xmin $ymin $xmax $ymax";
X}
X
X#
X# bound a tile collection
X#
Xproc bound-collection {collection} {
X    pset xmin ymin xmax ymax [bound-tiling [lindex [lindex $collection 0] 1]]
X    foreach item [lrange $collection 1 end] {
X	pset x0 y0 x1 y1 [bound-tiling [lindex $item 1]];
X	if {$x0 < $xmin} {
X	    set xmin $x0;
X	}
X	if {$x1 > $xmax} {
X	    set xmax $x1;
X	}
X	if {$y0 < $ymin} {
X	    set ymin $y0;
X	}
X	if {$y1 > $ymax} {
X	    set ymax $y1;
X	}
X    }
X    return "$xmin $ymin $xmax $ymax";
X}
X
END_OF_FILE
if test 1248 -ne `wc -c <'subtile/lib/bound-tiles.tcl'`; then
    echo shar: \"'subtile/lib/bound-tiles.tcl'\" unpacked with wrong size!
fi
# end of 'subtile/lib/bound-tiles.tcl'
fi
if test -f 'subtile/lib/canvasview.tcl' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'subtile/lib/canvasview.tcl'\"
else
echo shar: Extracting \"'subtile/lib/canvasview.tcl'\" \(4155 characters\)
sed "s/^X//" >'subtile/lib/canvasview.tcl' <<'END_OF_FILE'
X#
X# canvasview widget
X#
X# the canvasview widget builds a frame which contains a canvas,
X# and optionally enables horizontal and/or vertical scroll bars.
X#
X
Xproc canvasview {w args} {
X    # establish widget data.
X    upvar #0 $w data;
X
X    # establish widget window.
X    frame $w -class Canvasview;
X    rename $w $w.frame;
X
X    # establish widget method dispatcher.
X    proc $w {method args} "return \[eval canvasview::method::\$method $w \$args\];"
X
X    # instantiate the widget.
X    pack [canvas $w.c] -expand true -fill both
X
X    # redirect bindings
X    bindtags $w.c "Canvas $w [winfo toplevel $w] all"
X
X    # default configuration
X    set data(options) {
X	{-vscroll vScroll VScroll 0}
X	{-hscroll hScroll HScroll 0}
X    }
X    foreach opt $data(options) {
X	set name [lindex $opt 0];
X	set data($name) [lindex $opt 3];
X    }
X
X    # apply the configuration options
X    canvasview::configure;
X
X    # return the widget name.
X    return $w;
X}
X#
X# widget methods
X#
Xproc canvasview::method::cget {w args} {
X    if {[llength $args] != 1} {
X	error "usage: pathName cget option";
X    } else {
X	return [lindex [$w configure $args] 4];
X    }
X}
Xproc canvasview::method::configure {w args} {
X    upvar #0 $w data;
X    if {[llength $args] == 0} {
X	set options {};
X	foreach opt $data(options) {
X	    set name [lindex $opt 0];
X	    if {[llength $opt] == 4} {
X		lappend opt $data($name);
X	    }
X	    lappend options $opt;
X	}
X	return [concat $options [$w.c configure]];
X    }
X    if {[llength $args] == 1} {
X	foreach opt $data(options) {
X	    set name [lindex $opt 0];
X	    if {"$name" == "$args"} {
X		if {[llength $opt] == 4} {
X		    lappend opt $data($name);
X		    return $opt;
X		} else {
X		    return [$w configure -[lindex $opt 2]];
X		}
X	    }
X	}
X	return [$w.c configure $args];
X    }
X    canvasview::configure;
X}
X
X#
X# install all methods except configure and cget from canvas
X#
Xforeach method {addtag bbox bind canvasx canvasy coords create dchars \
X		    delete dtag find focus gettags icursor index insert \
X		    itemcget itemconfigure lower move postscript raise \
X		    scale scan select type xview yview} {
X    proc canvasview::method::$method {w args} "eval \$w.c $method \$args";
X}
X#
X# internals
X#
Xproc canvasview::configure {} {
X    upvar w w;
X    upvar args args;
X    upvar data data;
X    set cargs {};
X    while {[llength $args] >= 2} {
X	set option [lindex $args 0];
X	set value [lindex $args 1];
X	set args [lrange $args 2 end];
X	switch -exact -- $option {
X	    -hscroll {
X		set data(-hscroll) [merge-boolean $value $data(-hscroll)];
X		canvasview::repack;
X	    }
X	    -vscroll {
X		set data(-vscroll) [merge-boolean $value $data(-vscroll)];
X		canvasview::repack;
X	    }
X	    default {
X		lappend cargs $option $value;
X	    }
X	}
X    }
X    if {[llength $args] != 0} {
X	error "unmatched option argument: $args";
X    }
X    if {"$cargs" != {}} {
X	return [eval $w.c configure $cargs];
X    } else {
X	return {};
X    }
X}
Xproc canvasview::repack {} {
X    upvar w w;
X    upvar data data;
X
X    $w.c configure -xscrollcommand {} -yscrollcommand {};
X    catch {pack forget $w.c};
X    catch {pack forget $w.e};
X    catch {destroy $w.e};
X    catch {pack forget $w.v};
X    catch {destroy $w.v};
X    catch {pack forget $w.h};
X    catch {destroy $w.h};
X
X    switch $data(-hscroll)$data(-vscroll) {
X	10 {
X	    pack [scrollbar $w.h -orient horizontal -command "$w.c xview"] -side bottom -fill x;
X	    pack $w.c -side top -fill both -expand true;
X	    $w.c configure -xscrollcommand "$w.h set";
X	}
X	01 {
X	    pack [scrollbar $w.v -orient vertical -command "$w.c yview"] -side right -fill y;
X	    pack $w.c -side left -fill both -expand true;
X	    $w.c configure -yscrollcommand "$w.v set";
X	}
X	11 {
X	    pack [frame $w.e] -side right -fill y;
X	    pack [frame $w.e.s] -side bottom;
X	    pack [scrollbar $w.v -orient vertical -command "$w.c yview"] -in $w.e -side right -fill y;
X	    pack [scrollbar $w.h -orient horizontal -command "$w.c xview"] -side bottom -fill x;
X	    pack $w.c -side top -fill both -expand true;
X	    $w.c configure -xscrollcommand "$w.h set" -yscrollcommand "$w.v set";
X	    bind $w.e.s <Configure> "$w.e.s configure -height \[winfo height $w.h]";
X	}
X    }
X}
END_OF_FILE
if test 4155 -ne `wc -c <'subtile/lib/canvasview.tcl'`; then
    echo shar: \"'subtile/lib/canvasview.tcl'\" unpacked with wrong size!
fi
# end of 'subtile/lib/canvasview.tcl'
fi
if test -f 'subtile/lib/dimension-tiles.tcl' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'subtile/lib/dimension-tiles.tcl'\"
else
echo shar: Extracting \"'subtile/lib/dimension-tiles.tcl'\" \(926 characters\)
sed "s/^X//" >'subtile/lib/dimension-tiles.tcl' <<'END_OF_FILE'
X#
X# dimension of a tile
X#
Xproc dimension-tile {tile} {
X    pset xmin ymin [lindex $tile 1];
X    pset xmax ymax "$xmin $ymin";
X    foreach point [lrange $tile 2 end] {
X	pset x y $point;
X	if {$x < $xmin} {
X	    set xmin $x;
X	} elseif {$x > $xmax} {
X	    set xmax $x;
X	}
X	if {$y < $ymin} {
X	    set ymin $y;
X	} elseif {$y > $ymax} {
X	    set ymax $y;
X	}
X    }
X    return [list [expr $xmax-$xmin] [expr $ymax-$ymin]];
X}
X
X#
X# dimension a tiling
X#
Xproc dimension-tiling {tiles} {
X    pset x0 y0 x1 y1 [bound-tiling $tiles];
X    return [list [expr $x1-$x0] [expr $y1-$y0]];
X}
X
X#
X# dimension a tile collection
X#
Xproc dimension-collection {collection} {
X    pset dx dy [dimension-tiling [lindex [lindex $collection 0] 1]]
X    foreach item [lrange $collection 1 end] {
X	pset dx1 dy1 [dimension-tiling [lindex $item 1]];
X	if {$dx < $dx1} {
X	    set dx $dx1;
X	}
X	if {$dy < $dy1} {
X	    set dy $dy1;
X	}
X    }
X    return [list $dx $dy];
X}
X
END_OF_FILE
if test 926 -ne `wc -c <'subtile/lib/dimension-tiles.tcl'`; then
    echo shar: \"'subtile/lib/dimension-tiles.tcl'\" unpacked with wrong size!
fi
# end of 'subtile/lib/dimension-tiles.tcl'
fi
if test -f 'subtile/lib/get-boolean.tcl' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'subtile/lib/get-boolean.tcl'\"
else
echo shar: Extracting \"'subtile/lib/get-boolean.tcl'\" \(458 characters\)
sed "s/^X//" >'subtile/lib/get-boolean.tcl' <<'END_OF_FILE'
X#
X# Translate a boolean value to integer
X#
Xproc get-boolean {val} {
X    switch -exact -- $val {
X	t - true - 1 - on {
X	    return 1;
X	}
X	f - false - 0 - off {
X	    return 0;
X	}
X	default {
X	    error "$val is not a boolean value";
X	}
X    }
X}
X
X#
X# Translate an extended boolean value and the current
X# value into an integer.
X#
Xproc merge-boolean {val curval} {
X    if {"$val" == "!"} {
X	return [expr ! $curval];
X    } else {
X	return [get-boolean $val];
X    }
X}
END_OF_FILE
if test 458 -ne `wc -c <'subtile/lib/get-boolean.tcl'`; then
    echo shar: \"'subtile/lib/get-boolean.tcl'\" unpacked with wrong size!
fi
# end of 'subtile/lib/get-boolean.tcl'
fi
if test -f 'subtile/lib/list.tcl' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'subtile/lib/list.tcl'\"
else
echo shar: Extracting \"'subtile/lib/list.tcl'\" \(604 characters\)
sed "s/^X//" >'subtile/lib/list.tcl' <<'END_OF_FILE'
X##
X## useful routines for lists
X##
X
X##
X## return the elements of list which are not elements of list2
X##
Xproc list-difference {list1 list2} {
X    set l {};
X    foreach e $list1 {
X	if {[lsearch $list2 $e] < 0} {
X	    lappend l $e;
X	}
X    }
X    return $l;
X}
X
X##
X## return the list generated by repeating c n times.
X##
Xproc lrepeat {c n} {
X    set l 0;
X    while {[incr n -1] >= 0} {
X	lappend l $c;
X    }
X    return $l;
X}
X
X##
X## return the list with the elements in reverse order
X##
Xproc lreverse {list} {
X    set nlist {};
X    foreach e $list {
X	set nlist [linsert $nlist 0 $e];
X    }
X    return $nlist;
X}
END_OF_FILE
if test 604 -ne `wc -c <'subtile/lib/list.tcl'`; then
    echo shar: \"'subtile/lib/list.tcl'\" unpacked with wrong size!
fi
# end of 'subtile/lib/list.tcl'
fi
if test -f 'subtile/lib/new-window-name.tcl' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'subtile/lib/new-window-name.tcl'\"
else
echo shar: Extracting \"'subtile/lib/new-window-name.tcl'\" \(158 characters\)
sed "s/^X//" >'subtile/lib/new-window-name.tcl' <<'END_OF_FILE'
X#
X# invent a toplevel window name
X#
Xset new-window-name::nth 0;
X
Xproc new-window-name {} {
X    upvar \#0 new-window-name::nth nth
X    return .f[incr nth];
X}
X
END_OF_FILE
if test 158 -ne `wc -c <'subtile/lib/new-window-name.tcl'`; then
    echo shar: \"'subtile/lib/new-window-name.tcl'\" unpacked with wrong size!
fi
# end of 'subtile/lib/new-window-name.tcl'
fi
if test -f 'subtile/lib/orient-tiles.tcl' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'subtile/lib/orient-tiles.tcl'\"
else
echo shar: Extracting \"'subtile/lib/orient-tiles.tcl'\" \(1306 characters\)
sed "s/^X//" >'subtile/lib/orient-tiles.tcl' <<'END_OF_FILE'
X#
X# force a tile to anti-clockwise vertex order
X#
Xproc tile-signed-area {tile} {
X    set a 0;
X    set pi [lindex $tile 1];
X    set pj [lindex $tile 2];
X    set vij [vsub $pj $pi];
X    for {set i 3} {$i < [llength $tile]} {incr i} {
X	set pk [lindex $tile $i];
X	set vik [vsub $pk $pi];
X	set a [expr $a + [vcross $vij $vik]];
X	set vij $vik;
X    }
X    return $a;
X}
X
Xproc clockwise-tile-p {tile} {
X    if {[tile-signed-area $tile] < 0} {
X	return 1;
X    } else {
X	return 0;
X    }
X}
X
Xproc anti-clockwise-tile-p {tile} {
X    if {[tile-signed-area $tile] > 0} {
X	return 1;
X    } else {
X	return 0;
X    }
X}
X
Xproc anti-clockwise-tile {tile} {
X    if {[anti-clockwise-tile-p $tile]} {
X	return $tile;
X    } else {
X	set newt [lindex $tile 0];
X	for {set i [llength $tile]} {[incr i -1] > 0} {} {
X	    lappend newt [lindex $tile $i];
X	}
X	return $newt;
X    }
X}
X
X#
X# force a tiling to anti-clockwise vertex order
X#
Xproc anti-clockwise-tiling {tiles} {
X    set newts {};
X    foreach tile $tiles {
X	lappend newts [anti-clockwise-tile $tile];
X    }
X    return $newts;
X}
X
X#
X# force a collection to anti-clockwise vertex order
X#
Xproc anti-clockwise-collection {collection} {
X    set newc {};
X    foreach item $collection {
X	lappend newc [list [lindex $item 0] [anti-clockwise-tiling [lindex $item 1]]];
X    }
X    return $newc;
X}
X
END_OF_FILE
if test 1306 -ne `wc -c <'subtile/lib/orient-tiles.tcl'`; then
    echo shar: \"'subtile/lib/orient-tiles.tcl'\" unpacked with wrong size!
fi
# end of 'subtile/lib/orient-tiles.tcl'
fi
if test -f 'subtile/lib/recenter-tiles.tcl' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'subtile/lib/recenter-tiles.tcl'\"
else
echo shar: Extracting \"'subtile/lib/recenter-tiles.tcl'\" \(768 characters\)
sed "s/^X//" >'subtile/lib/recenter-tiles.tcl' <<'END_OF_FILE'
X#
X# recenter a tile
X#
Xproc recenter-tile {dx dy tile} {
X    set newt [lindex $tile 0];
X    foreach point [lrange $tile 1 end] {
X	pset x y $point;
X	lappend newt [list [expr $x+$dx] [expr $y+$dy]];
X    }
X    return $newt;
X}
X
X#
X# recenter a tiling
X#
Xproc recenter-tiling {tiles} {
X    pset xmin ymin xmax ymax [bound-tiling $tiles];
X    set dx [expr -$xmin+(1-($xmax-$xmin))/2];
X    set dy [expr -$ymin+(1-($ymax-$ymin))/2];
X    set newts {};
X    foreach tile $tiles {
X	lappend newts [recenter-tile $dx $dy $tile];
X    }
X    return $newts;
X}
X
X#
X# recenter a collection of tilings
X#
Xproc recenter-collection {collection} {
X    set newc {};
X    foreach item $collection {
X	lappend newc [list [lindex $item 0] [recenter-tiling [lindex $item 1]]];
X    }
X    return $newc;
X}
X
END_OF_FILE
if test 768 -ne `wc -c <'subtile/lib/recenter-tiles.tcl'`; then
    echo shar: \"'subtile/lib/recenter-tiles.tcl'\" unpacked with wrong size!
fi
# end of 'subtile/lib/recenter-tiles.tcl'
fi
if test -f 'subtile/lib/rescale-tiles.tcl' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'subtile/lib/rescale-tiles.tcl'\"
else
echo shar: Extracting \"'subtile/lib/rescale-tiles.tcl'\" \(605 characters\)
sed "s/^X//" >'subtile/lib/rescale-tiles.tcl' <<'END_OF_FILE'
X#
X# rescale a tile
X#
Xproc rescale-tile {s tile} {
X    set newt [lindex $tile 0];
X    foreach point [lrange $tile 1 end] {
X	pset x y $point;
X	lappend newt [list [expr $x*$s] [expr $y*$s]];
X    }
X    return $newt;
X}
X
X#
X# rescale a tiling
X#
Xproc rescale-tiling {s tiles} {
X    set newts {}
X    foreach tile $tiles {
X	lappend newts [rescale-tile $s $tile];
X    }
X    return $newts;
X}
X
X#
X# rescale a tile collection
X#
Xproc rescale-collection {s collection} {
X    set newc {};
X    foreach item $collection {
X	lappend newc [list [lindex $item 0] [rescale-tiling $s [lindex $item 1]]];
X    }
X    return $newc;
X}
X
END_OF_FILE
if test 605 -ne `wc -c <'subtile/lib/rescale-tiles.tcl'`; then
    echo shar: \"'subtile/lib/rescale-tiles.tcl'\" unpacked with wrong size!
fi
# end of 'subtile/lib/rescale-tiles.tcl'
fi
if test -f 'subtile/lib/scale.tcl' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'subtile/lib/scale.tcl'\"
else
echo shar: Extracting \"'subtile/lib/scale.tcl'\" \(410 characters\)
sed "s/^X//" >'subtile/lib/scale.tcl' <<'END_OF_FILE'
X#
X# implement page scaling by pulling or pushing away from the
X# upper left corner???
X#
Xproc scale-mark {w x y} {
X    upvar \#0 $w d;
X    set d(s-m-r2) [expr pow($x,2)+pow($y,2)];
X}
X
Xproc scale-dragto {w x y} {
X    upvar \#0 $w d;
X    set r2 [expr pow($x,2)+pow($y,2)];
X    set s [expr sqrt(double($r2)/$d(s-m-r2))]
X    set d(s-m-r2) $r2;
X    set d(scale) [expr $d(scale)*$s];
X    $w.c scale all 0 0 $s $s;
X}
X
END_OF_FILE
if test 410 -ne `wc -c <'subtile/lib/scale.tcl'`; then
    echo shar: \"'subtile/lib/scale.tcl'\" unpacked with wrong size!
fi
# end of 'subtile/lib/scale.tcl'
fi
if test -f 'subtile/lib/scroll.tcl' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'subtile/lib/scroll.tcl'\"
else
echo shar: Extracting \"'subtile/lib/scroll.tcl'\" \(373 characters\)
sed "s/^X//" >'subtile/lib/scroll.tcl' <<'END_OF_FILE'
X#
X# implement page scrolling by pushing the page
X#
Xproc scroll-mark {w x y} {
X    upvar \#0 $w d;
X    set d(s-m-x) $x;
X    set d(s-m-y) $y;
X}
X
Xproc scroll-dragto {w x y} {
X    upvar \#0 $w d;
X    set dx [expr -($x-$d(s-m-x))];
X    set dy [expr -($y-$d(s-m-y))];
X    set d(s-m-x) $x;
X    set d(s-m-y) $y;
X    $w.c xview scroll $dx units;
X    $w.c yview scroll $dy units;
X}
X
END_OF_FILE
if test 373 -ne `wc -c <'subtile/lib/scroll.tcl'`; then
    echo shar: \"'subtile/lib/scroll.tcl'\" unpacked with wrong size!
fi
# end of 'subtile/lib/scroll.tcl'
fi
if test -f 'subtile/lib/tclIndex' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'subtile/lib/tclIndex'\"
else
echo shar: Extracting \"'subtile/lib/tclIndex'\" \(3574 characters\)
sed "s/^X//" >'subtile/lib/tclIndex' <<'END_OF_FILE'
X# Tcl autoload index file, version 2.0
X# This file is generated by the "auto_mkindex" command
X# and sourced to set up indexing information for one or
X# more commands.  Typically each line is a command that
X# sets an element in the auto_index array, where the
X# element name is the name of a command and the value is
X# a script that loads the command.
X
Xset auto_index(canvasview) "source $dir/canvasview.tcl"
Xset auto_index(canvasview::method::cget) "source $dir/canvasview.tcl"
Xset auto_index(canvasview::method::configure) "source $dir/canvasview.tcl"
Xset auto_index(canvasview::configure) "source $dir/canvasview.tcl"
Xset auto_index(canvasview::repack) "source $dir/canvasview.tcl"
Xset auto_index(get-boolean) "source $dir/get-boolean.tcl"
Xset auto_index(merge-boolean) "source $dir/get-boolean.tcl"
Xset auto_index(vunpack) "source $dir/vector.tcl"
Xset auto_index(vmake) "source $dir/vector.tcl"
Xset auto_index(vadd) "source $dir/vector.tcl"
Xset auto_index(vsub) "source $dir/vector.tcl"
Xset auto_index(vscale) "source $dir/vector.tcl"
Xset auto_index(vsum) "source $dir/vector.tcl"
Xset auto_index(vneg) "source $dir/vector.tcl"
Xset auto_index(rmake) "source $dir/vector.tcl"
Xset auto_index(vrotate) "source $dir/vector.tcl"
Xset auto_index(vdot) "source $dir/vector.tcl"
Xset auto_index(vcross) "source $dir/vector.tcl"
Xset auto_index(vangle) "source $dir/vector.tcl"
Xset auto_index(vlength) "source $dir/vector.tcl"
Xset auto_index(textview) "source $dir/textview.tcl"
Xset auto_index(textview::method::cget) "source $dir/textview.tcl"
Xset auto_index(textview::method::configure) "source $dir/textview.tcl"
Xset auto_index(textview::configure) "source $dir/textview.tcl"
Xset auto_index(textview::repack) "source $dir/textview.tcl"
Xset auto_index(pset) "source $dir/assign.tcl"
Xset auto_index(scroll-mark) "source $dir/scroll.tcl"
Xset auto_index(scroll-dragto) "source $dir/scroll.tcl"
Xset auto_index(about-something) "source $dir/about.tcl"
Xset auto_index(scale-mark) "source $dir/scale.tcl"
Xset auto_index(scale-dragto) "source $dir/scale.tcl"
Xset auto_index(vertex-atlas-tiling) "source $dir/vertex-atlas.tcl"
Xset auto_index(vertex-atlas::choose-key) "source $dir/vertex-atlas.tcl"
Xset auto_index(new-window-name) "source $dir/new-window-name.tcl"
Xset auto_index(bound-tile) "source $dir/bound-tiles.tcl"
Xset auto_index(bound-tiling) "source $dir/bound-tiles.tcl"
Xset auto_index(bound-collection) "source $dir/bound-tiles.tcl"
Xset auto_index(dimension-tile) "source $dir/dimension-tiles.tcl"
Xset auto_index(dimension-tiling) "source $dir/dimension-tiles.tcl"
Xset auto_index(dimension-collection) "source $dir/dimension-tiles.tcl"
Xset auto_index(tile-signed-area) "source $dir/orient-tiles.tcl"
Xset auto_index(clockwise-tile-p) "source $dir/orient-tiles.tcl"
Xset auto_index(anti-clockwise-tile-p) "source $dir/orient-tiles.tcl"
Xset auto_index(anti-clockwise-tile) "source $dir/orient-tiles.tcl"
Xset auto_index(anti-clockwise-tiling) "source $dir/orient-tiles.tcl"
Xset auto_index(anti-clockwise-collection) "source $dir/orient-tiles.tcl"
Xset auto_index(rescale-tile) "source $dir/rescale-tiles.tcl"
Xset auto_index(rescale-tiling) "source $dir/rescale-tiles.tcl"
Xset auto_index(rescale-collection) "source $dir/rescale-tiles.tcl"
Xset auto_index(recenter-tile) "source $dir/recenter-tiles.tcl"
Xset auto_index(recenter-tiling) "source $dir/recenter-tiles.tcl"
Xset auto_index(recenter-collection) "source $dir/recenter-tiles.tcl"
Xset auto_index(list-difference) "source $dir/list.tcl"
Xset auto_index(lrepeat) "source $dir/list.tcl"
Xset auto_index(lreverse) "source $dir/list.tcl"
END_OF_FILE
if test 3574 -ne `wc -c <'subtile/lib/tclIndex'`; then
    echo shar: \"'subtile/lib/tclIndex'\" unpacked with wrong size!
fi
# end of 'subtile/lib/tclIndex'
fi
if test -f 'subtile/lib/textview.tcl' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'subtile/lib/textview.tcl'\"
else
echo shar: Extracting \"'subtile/lib/textview.tcl'\" \(3964 characters\)
sed "s/^X//" >'subtile/lib/textview.tcl' <<'END_OF_FILE'
X#
X# textview widget
X#
X# the textview widget builds a frame which contains the text of a file,
X# or a stream, or a list of strings, and optionally enables horizontal
X# and or vertical scroll bars.
X#
X
Xproc textview {w args} {
X    # establish the widget local state binding.
X    upvar #0 $w data;
X
X    # establish a Tk frame widget.
X    frame $w -class Textview;
X    rename $w $w.frame;
X
X    # widget method dispatcher.
X    proc $w {method args} "return \[eval textview::method::\$method $w \$args\];"
X
X    # instantiate the widget
X    pack [text $w.t] -expand true -fill both
X
X    # redirect bindings
X    bindtags $w.t "Text $w [winfo toplevel $w] all"
X
X    # default configuration
X    set data(options) {
X	{-vscroll vScroll VScroll 0}
X	{-hscroll hScroll HScroll 0}
X    };
X    foreach opt $data(options) {
X	set name [lindex $opt 0];
X	set data($name) [lindex $opt 3];
X    }
X    
X    # apply the configuration options
X    textview::configure;
X
X    # return the widget name.
X    return $w;
X}
X#
X# widget methods.
X#
Xproc textview::method::cget {w args} {
X    if {[llength $args] != 1} {
X	error "usage: pathName cget option";
X    } else {
X	return [lindex [$w configure $args] 4];
X    }
X}
Xproc textview::method::configure {w args} {
X    upvar #0 $w data;
X    if {[llength $args] == 0} {
X	set options {};
X	foreach opt $data(options) {
X	    set name [lindex $opt 0];
X	    if {[llength $opt] == 4} {
X		lappend opt $data($name);
X	    }
X	    lappend options $opt;
X	}
X	return [concat $options [$w.t configure]];
X    }
X    if {[llength $args] == 1} {
X	foreach opt $data(options) {
X	    set name [lindex $opt 0];
X	    if {"$name" == "$args"} {
X		if {[llength $opt] == 4} {
X		    lappend opt $data($name);
X		    return $opt;
X		} else {
X		    return [$w configure -[lindex $opt 2]];
X		}
X	    }
X	}
X	return [$w.t configure $name];
X    }
X    return [textview::configure];
X}
X#
X# methods from text
X#
Xforeach method {bbox compare debug delete dlineinfo get index insert mark\
X		scan search see tag window xview yview} {
X    proc textview::method::$method {w args} "eval \$w.t $method \$args";
X}
X#
X# Internals
X#
Xproc textview::configure {} {
X    upvar w w;
X    upvar args args;
X    upvar data data;
X    set targs {};
X    while {[llength $args] >= 2} {
X	set option [lindex $args 0];
X	set value [lindex $args 1];
X	set args [lrange $args 2 end];
X	switch -exact -- $option {
X	    -hscroll {
X		set data(-hscroll) [merge-boolean $value $data(-hscroll)];
X		textview::repack;
X	    }
X	    -vscroll {
X		set data(-vscroll) [merge-boolean $value $data(-vscroll)];
X		textview::repack;
X	    }
X	    default {
X		lappend targs $option $value;
X	    }
X	}
X    }
X    if {[llength $args] != 0} {
X	error "unmatched option argument: $args";
X    }
X    if {"$targs" != {}} {
X	return [eval $w.t configure $targs];
X    } else {
X	return {};
X    }
X}
X
Xproc textview::repack {} {
X    upvar w w;
X    upvar data data;
X
X    $w.t configure -xscrollcommand {} -yscrollcommand {};
X    catch {pack forget $w.e};
X    catch {destroy $w.e};
X    catch {pack forget $w.v};
X    catch {destroy $w.v};
X    catch {pack forget $w.h};
X    catch {destroy $w.h};
X
X    switch $data(-hscroll)$data(-vscroll) {
X	10 {
X	    pack [scrollbar $w.h -orient horizontal -command "$w.t xview" -takefocus 0] -before $w.t -side bottom -fill x;
X	    $w.t configure -xscrollcommand "$w.h set";
X	}
X	01 {
X	    pack [scrollbar $w.v -orient vertical -command "$w.t yview" -takefocus 0] -before $w.t -side right -fill y;
X	    $w.t configure -yscrollcommand "$w.v set";
X	}
X	11 {
X	    pack [frame $w.e] -before $w.t -side right -fill y;
X	    pack [frame $w.e.s] -side bottom;
X	    pack [scrollbar $w.v -orient vertical -command "$w.t yview" -takefocus 0] -in $w.e -side right -fill y;
X	    pack [scrollbar $w.h -orient horizontal -command "$w.t xview" -takefocus 0] -before $w.t -side bottom -fill x;
X	    $w.t configure -xscrollcommand "$w.h set" -yscrollcommand "$w.v set";
X	    bind $w.e.s <Configure> "$w.e.s configure -height \[winfo height $w.h]";
X	}
X    }
X}
END_OF_FILE
if test 3964 -ne `wc -c <'subtile/lib/textview.tcl'`; then
    echo shar: \"'subtile/lib/textview.tcl'\" unpacked with wrong size!
fi
# end of 'subtile/lib/textview.tcl'
fi
if test -f 'subtile/lib/vector.tcl' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'subtile/lib/vector.tcl'\"
else
echo shar: Extracting \"'subtile/lib/vector.tcl'\" \(1466 characters\)
sed "s/^X//" >'subtile/lib/vector.tcl' <<'END_OF_FILE'
X# unpack a 2d vector into components
Xproc vunpack {args} {
X    foreach v $args {
X	upvar $v u ${v}0 u0 ${v}1 u1;
X	set u0 [lindex $u 0];
X	set u1 [lindex $u 1];
X    }
X}
X# pack two components into a 2d vector
Xproc vmake {u0 u1} {
X    return [list [uplevel "expr $u0"] [uplevel "expr $u1"]];
X}
X# add two 2d vectors
Xproc vadd {u v} {
X    vunpack u v;
X    return [vmake $u0+$v0 $u1+$v1];
X}
X# subtract two 2d vectors
Xproc vsub {u v} {
X    vunpack u v;
X    return [vmake $u0-$v0 $u1-$v1];
X}
X# scale a vector by a scalar factor
Xproc vscale {s u} {
X    vunpack s u;
X    return [vmake $s0*$u0 $s0*$u1];
X}
X# sum a list of 2d vectors
Xproc vsum {u args} {
X    vunpack u;
X    foreach v $args {
X	vunpack v;
X	append u0 +$v0;
X	append u1 +$v1;
X    }
X    return [vmake $u0 $u1];
X}
X# negate a vector
Xproc vneg {u} {
X    return [vsub {0 0} $u];
X}
X# make a 2d rotation by angle a
Xproc rmake {a} {
X    return [vmake cos($a) sin($a)];
X}
X# apply a 2d rotation to a 2d vector
Xproc vrotate {r u} {
X    vunpack r u;
X    return [vmake $r0*$u0-$r1*$u1 $r1*$u0+$r0*$u1];
X}
X# dot product of two 2d vectors
Xproc vdot {a b} {
X    vunpack a b;
X    return [expr $a0*$b0 + $a1*$b1];
X}
X# cross product of two 2d vectors
Xproc vcross {a b} {
X    vunpack a b;
X    return [expr $a0*$b1-$a1*$b0];
X}
X# angle between two vectors measured counter clockwise
Xproc vangle {a b} {
X    return [expr atan2([vcross $a $b], [vdot $a $b])];
X}
X# length of a vector
Xproc vlength {a} {
X    return [expr sqrt([vdot $a $a])];
X}
END_OF_FILE
if test 1466 -ne `wc -c <'subtile/lib/vector.tcl'`; then
    echo shar: \"'subtile/lib/vector.tcl'\" unpacked with wrong size!
fi
# end of 'subtile/lib/vector.tcl'
fi
if test -f 'subtile/lib/vertex-atlas.tcl' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'subtile/lib/vertex-atlas.tcl'\"
else
echo shar: Extracting \"'subtile/lib/vertex-atlas.tcl'\" \(4028 characters\)
sed "s/^X//" >'subtile/lib/vertex-atlas.tcl' <<'END_OF_FILE'
Xproc vertex-atlas-tiling {tiling} {
X
X    # create a map of tiles incident to each vertex
X    global tcl_precision;
X    set z [vmake 0 0];
X    foreach tile $tiling {
X	# the tile type
X	set type [lindex $tile 0];
X	# the first vertex
X	set pj [lindex $tile 1];
X	# is this a clockwise tile
X	set cw [clockwise-tile-p $tile];
X	# from the 2nd to the last and on to the first
X	# form the vector from pi to the previous vertex
X	set vis {};
X	set vijs {};
X	foreach pi [concat [lrange $tile 2 end] [list $pj]] {
X	    # compute the edge vector
X	    set vij [vsub $pi $pj];
X	    # normalize to unit length
X	    set vij [vscale [expr 1/[vlength $vij]] $vij]
X	    # remember the edge vector
X	    lappend vijs $vij;
X	    # remember the vertices at lower precision
X	    set tcl_precision 3;
X	    lappend vis [vadd $z $pi];
X	    set tcl_precision 6;
X	    # step to the next vertex
X	    set pj $pi;
X	}
X	# extend the vij list by the first
X	lappend vijs [lindex $vijs 0];
X	# make the list clockwise
X	if { ! $cw } {
X	    set vijs [lreverse $vijs];
X	    set vis [lreverse $vis];
X	}
X	# now install the vertices
X	for {set i 0} {$i < [llength $vis]} {incr i} {
X	    lappend vertices([lindex $vis $i]) [list [lindex $vijs $i] [vneg [lindex $vijs [expr $i+1]]] $tile];
X	    #puts "[lindex $vis $i], cw? $cw,  [lindex $vijs $i] [vneg [lindex $vijs [expr $i+1]]]\n\t$tile"
X	}
X    }
X
X    # for each vertex found,
X    # match the tiles incident to the vertex
X    # by their edge vectors
X    foreach vertex [array names vertices] {
X	#puts "vertex $vertex";
X	if {[llength $vertices($vertex)] < 3} {
X	    unset vertices($vertex);
X	    continue;
X	}
X	catch {unset edge};
X	catch {unset vcw};
X	catch {unset ang};
X	set t 0;
X	# find the edges radiating from the vertex
X	foreach item $vertices($vertex) {
X	    # get the edges incident to the vertex
X	    pset vij vik tile $item;
X	    #puts "$vertex -> $item"
X	    # remember this tile as containing this edge
X	    lappend edge($vij) $t;
X	    lappend edge($vik) $t;
X	    # remember the more clockwise edge and its angle
X	    set vcw($t) $vik;
X	    set ang($t) [format {%.2f} [expr 180 * [vangle $vij $vik] / 3.14159265359]];
X	    # step to next tile
X	    incr t;
X	}
X	# follow tiles around the vertex clockwise
X	set inds {};
X	set n 0;
X	for {set last 0} {1} {set last $new} {
X	    # accumulate the tile indexes
X	    lappend inds $last;
X
X	    # find the clockwise edge of the tile
X	    set v $vcw($last);
X
X	    #puts "$last $v $edge($v)"
X
X	    # test for incomplete vertex, ie on edge of tiling
X	    if {[llength $edge($v)] != 2} {
X		unset inds;
X		break;
X	    }
X
X	    # determine which of the tile indexes is new
X	    foreach new $edge($v) {
X		if {$new != $last} {
X		    break;
X		}
X	    }
X
X	    # see if we are finished, ie back to the start
X	    if {$new == [lindex $inds 0]} {
X		break;
X	    }
X	    # look out for endless loops
X	    if {[incr n] > 30} {
X		puts "endless loop: $inds\n[join $vertices($vertex) \n]";
X		unset inds;
X		break;
X	    }
X	}
X	# test for complete vertex
X	if { ! [info exists inds]} {
X	    continue;
X	}
X	# build a descriptor
X	set key {};
X	set tiles {};
X	foreach ix $inds {
X	    pset vij vik tile [lindex $vertices($vertex) $ix];
X	    lappend key $ang($ix)/[lindex $tile 0];
X	    lappend tiles $tile;
X	}
X	set i [vertex-atlas::choose-key $key]
X	set key [concat [lrange $key $i end] [lrange $key 0 [expr $i-1]]];
X	set tiles [concat [lrange $tiles $i end] [lrange $tiles 0 [expr $i-1]]];
X	if { ! [info exists atlas($key)]} {
X	    set atlas($key) {};
X	    lappend tilings [list $key $tiles];
X	    #puts "installed $key [join $tiles \n]"
X	}
X    }
X    return $tilings;
X}
X
Xproc vertex-atlas::choose-key {key} {
X    lappend list $key;
X    for {set i 1} {$i < [llength $key]} {incr i} {
X	lappend list [concat [lrange $key $i end] [lrange $key 0 [expr $i-1]]];
X    }
X    set sort [lsort $list];
X    set i1 [lsearch $list [lindex $sort 0]];
X    set i2 0;
X    foreach item $list {
X	if {"$item" == "[lindex $sort 0]"} {
X	    break;
X	}
X	incr i2;
X    }
X    if {$i2 != $i1} {
X	puts "lsearch error";
X    }
X    return $i1;
X}
END_OF_FILE
if test 4028 -ne `wc -c <'subtile/lib/vertex-atlas.tcl'`; then
    echo shar: \"'subtile/lib/vertex-atlas.tcl'\" unpacked with wrong size!
fi
# end of 'subtile/lib/vertex-atlas.tcl'
fi
if test -f 'subtile/tiling/ammann.tcl' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'subtile/tiling/ammann.tcl'\"
else
echo shar: Extracting \"'subtile/tiling/ammann.tcl'\" \(14442 characters\)
sed "s/^X//" >'subtile/tiling/ammann.tcl' <<'END_OF_FILE'
X########################################################################
X##
X## Ammann tilings
X##
Xlappend subtile(tilings) \
X    {{Ammann A2} ammann-A2} \
X    {{Ammann A3} ammann-A3} \
X    {{Ammann A4} ammann-A4} \
X    {{Ammann A5 - square and rhomb} ammann-A5} \
X    {{Ammann A5 - triangles and rhomb } ammann-A5T};
X
Xset ammann(ammann-g) [expr sqrt(2)/(1+sqrt(2))];
Xset ammann(ammann-h) [expr 2*sin(3*$Pi/8)/(4*sin(3*$Pi/8)+2*cos(3*$Pi/8))];
Xset ammann(ammann-i) [expr 1/(2+sqrt(2))];
X
X
Xproc ammann-about {tiles} {
X    about-something {About Ammann Tilings} {
X	The Ammann tilings are described in Gruenbaum and Shephard (1987) in
X	section 10.4.  The Ammann octagonal tiling, A5, is also discussed in
X	Senechal (1995) section 7.3.
X
X	The A3 tiling composition rule is not yet implemented.
X
X	There's an error in the	description of the A4 tiling - the tiling has
X	a self-similar composition rule when p/q = sqrt(2)/2, not sqrt(2).
X
X	The A5/octagonal tiling has a composition rule which requires half
X	squares.
X    }
X    return $tiles;
X}
X
X########################################################################
X#
X# the golden^2 A2 where p/q = r/s = Tau and r/p = sqrt(Tau)
X#
Xset p $Tau;
Xset q 1;
Xset r [expr $Tau*sqrt($Tau)];
Xset s [expr sqrt($Tau)];
Xset S [list [list ammann-A2-s\
X		 [vmake 0 0]\
X		 [vmake $p 0]\
X		 [vmake $p $s]\
X		 [vmake $p+$q $s]\
X		 [vmake $p+$q $r+$s]\
X		 [vmake 0 $r+$s]\
X		]];
Xset L [list [list ammann-A2-l\
X		 [vmake 0 0]\
X		 [vmake $p+$q 0]\
X		 [vmake $p+$q $s]\
X		 [vmake $p+$q+$p $s]\
X		 [vmake $p+$q+$p $r+$s]\
X		 [vmake 0 $r+$s]\
X		]];
Xset subtile(ammann-A2-ops-menu) \
X    [list \
X	 {{About Amman Tilings} ammann-about} \
X	];
Xset subtile(ammann-A2-start-menu) \
X    [list \
X	 [list Small $S] \
X	 [list Large $L] \
X	];
X
Xproc ammann-A2-make {tiles divide} {
X    if {$divide == 0} {
X	return [list ammann-A2 $tiles];
X    } else {
X	return [list ammann-A2 [ammann-A2-dissect $tiles]];
X    }
X}
Xproc ammann-A2-dissect {tiles} {
X    global Tau;
X    set newt {};
X    foreach t1 $tiles {
X	set type [lindex $t1 0];
X	set a [lindex $t1 1];
X	set b [lindex $t1 2];
X	set c [lindex $t1 3];
X	set d [lindex $t1 4];
X	set e [lindex $t1 5];
X	set f [lindex $t1 6];
X	switch -exact $type {
X	    ammann-A2-s {
X		set p [vadd $c [vscale 1/$Tau [vsub $c $d]]];
X		set q [vadd $a [vscale 1/$Tau [vsub $f $a]]];
X		set r [vadd $p [vscale 1/$Tau [vsub $c $b]]];
X		lappend newt\
X		    [list ammann-A2-s $q $r $p $c $b $a]\
X		    [list ammann-A2-l $d $p $r $q $f $e];
X	    }
X	    ammann-A2-l {
X		set q [vadd $f [vscale 1/$Tau [vsub $a $f]]];
X		set p [vadd $q [vscale 1/$Tau [vsub $d $c]]];
X		set r [vadd $p [vscale 1/$Tau [vsub $c $b]]];
X		set s [vadd $r [vsub [vsub $d $c] [vsub $p $q]]];
X		set t [vadd $b [vsub $f $q]];
X		set u [vadd $f [vsub $d $c]];
X		lappend newt\
X		    [list ammann-A2-s $q $p $r $s $u $f]\
X		    [list ammann-A2-l $d $c $t $s $u $e]\
X		    [list ammann-A2-l $t $r $p $q $a $b];
X	    }
X	    default {
X		error "unknown tile type $type";
X	    }
X	}
X    }
X    return $newt;
X}
X########################################################################
X#
X# The A3 tiling from G&S.
X# the dissection is not done yet.
X#
Xset Tau2 [expr $Tau*$Tau];
Xset Tau3 [expr $Tau2*$Tau];
Xset A [list [list ammann-A3-a\
X		 [vmake 0 1+$Tau]\
X		 [vmake 0 1]\
X		 [vmake $Tau 1]\
X		 [vmake $Tau 0]\
X		 [vmake $Tau3 0]\
X		 [vmake $Tau3 $Tau2]]];
Xset B [list [list ammann-A3-b\
X		 [vmake 0 $Tau3]\
X		 [vmake 0 $Tau]\
X		 [vmake $Tau2 $Tau]\
X		 [vmake $Tau2 0]\
X		 [vmake $Tau3 0]\
X		 [vmake $Tau3 $Tau2]\
X		 [vmake 2*$Tau2 $Tau2]\
X		 [vmake 2*$Tau2 $Tau3]]];
Xset C [list [list ammann-A3-c\
X		 [vmake $Tau-1 $Tau3]\
X		 [vmake $Tau-1 $Tau2]\
X		 [vmake 0 $Tau2]\
X		 [vmake 0 $Tau]\
X		 [vmake $Tau $Tau]\
X		 [vmake $Tau 0]\
X		 [vmake 2*$Tau 0]\
X		 [vmake 2*$Tau $Tau2]\
X		 [vmake 2*$Tau+1 $Tau2]\
X		 [vmake 2*$Tau+1 $Tau3]]];
Xset subtile(ammann-A3-ops-menu) \
X    [list \
X	 {{About Amman Tilings} ammann-about} \
X	];
X
Xset subtile(ammann-A3-start-menu) \
X    [list \
X	 [list Small $A] \
X	 [list Medium $C] \
X	 [list Large $B] \
X	];
X
Xproc ammann-A3-make {tiles divide} {
X    if {$divide == 0} {
X	return [list ammann-A3 $tiles];
X    } else {
X	return [list ammann-A3 [ammann-A3-dissect $tiles]];
X    }
X}
X
X# this isn't done, yet
Xproc ammann-A3-dissect {tiles} {
X    global Tau;
X    set newt {};
X    foreach t1 $tiles {
X	set type [lindex $t1 0];
X	set a [lindex $t1 1];
X	set b [lindex $t1 2];
X	set c [lindex $t1 3];
X	set d [lindex $t1 4];
X	set e [lindex $t1 5];
X	set f [lindex $t1 6];
X	switch -exact $type {
X	    ammann-A3-a {
X		set g [vadd $e [vsub $b $c]];
X		set h [vadd $f [vsub $d $g]];
X		set j [vadd $g [vsub $a $b]];
X		set i [vadd $h [vsub $d $c]];
X		lappend newt [list ammann-A3-b $a $b $c $d $g $j $i $h];
X		lappend newt [list ammann-A3-a $f $h $i $j $g $e];
X	    }
X	    ammann-A3-b {
X		# remaining input vertices
X		set g [lindex $t1 7];
X		set h [lindex $t1 8];
X		# new vertices
X		set i [vadd $c [vsub $d $e]];
X		set k [vadd $a [vsub $e $d]];
X		set m [vadd $k [vsub $d $c]];
X		set j [vadd $k [vsub $i $b]];
X		set o [vadd $f [vsub $k $j]];
X		set l [vsum $i [vsub $a $b] [vsub $m $k]];
X		set p [vsum $j [vsub $b $a] [vsub $k $m]];
X		set n [vsum $o [vsub $e $f] [vsub $c $d]];
X		set r [vadd $p [vsub $j $k]];
X		set q [vsum $r [vsub $j $p] [vsub $g $h]];
X		lappend newt [list ammann-A3-a $b $i $l $m $k $a];
X		lappend newt [list ammann-A3-c $n $o $q $r $p $j $k $m $l $i];
X		lappend newt [list ammann-A3-a $f $o $n $c $d $e];
X		lappend newt [list ammann-A3-a $j $p $r $q $g $h];
X	    }
X	    ammann-A3-c {
X		# remaining input vertices
X		set g [lindex $t1 7];
X		set h [lindex $t1 8];
X		set i [lindex $t1 9];
X		set j [lindex $t1 10];
X		# new vertices
X		set k [vadd $a [vscale 0.5 [vadd [vsub $j $a] [vsub $f $g]]]];
X		set l [vadd $k [vsub $d $c]];
X		set m [vsum $l [vsub $k $a]];
X		set n [vsum $m [vsub $i $j] [vsub $k $l]];
X		set o [vadd $h [vsub $a $k]];
X		set p [vsum $e [vsub $g $f] [vsub $o $h]];
X		lappend newt [list ammann-A3-c $p $o $n $m $l $k $a $b $c $d];
X		lappend newt [list ammann-A3-a $h $o $p $e $f $g];
X		lappend newt [list ammann-A3-a $k $l $m $n $i $j];
X	    }
X	    default {
X		error "unknown tile type $type";
X	    }
X	}
X    }
X    return $newt;
X}
X	    
X########################################################################
X#
X# the block and key (?) tiling
X#
X# there appears to be a repeated error in Gruenbaum and Shephard
X# that claims this tiling has a self similar composition when p/q = sqrt(2),
X# but it really should be p/q = sqrt(2)/2.
X#
Xset p $Sqrt2/2;
Xset q 1;
Xset S [list [list ammann-A4-s\
X		 [vmake 0 $p+$q+$p]\
X		 [vmake 0 $p]\
X		 [vmake $q $p]\
X		 [vmake $q 0]\
X		 [vmake $q+$p 0]\
X		 [vmake $q+$p $p+$q+$p]]];
Xset L [list [list ammann-A4-l\
X		 [vmake 0 $p+$q+$p]\
X		 [vmake 0 $p]\
X		 [vmake $p $p]\
X		 [vmake $p 0]\
X		 [vmake $p+$q+$p 0]\
X		 [vmake $p+$q+$p $p+$q]\
X		 [vmake $p+$q $p+$q]\
X		 [vmake $p+$q $p+$q+$p]]];
Xset subtile(ammann-A4-ops-menu) \
X    [list \
X	 {{About Amman Tilings} ammann-about} \
X	];
Xset subtile(ammann-A4-start-menu) \
X    [list \
X	 [list Small $S] \
X	 [list Large $L] \
X	];
X
Xproc ammann-A4-make {tiles divide} {
X    if {$divide == 0} {
X	return [list ammann-A4 $tiles];
X    } else {
X	return [list ammann-A4 [ammann-A4-dissect $tiles]];
X    }
X}
X
Xproc ammann-A4-dissect {tiles} {
X    global Sqrt2;
X    set newt {};
X    foreach t1 $tiles {
X	set type [lindex $t1 0];
X	set a [lindex $t1 1];
X	set b [lindex $t1 2];
X	set c [lindex $t1 3];
X	set d [lindex $t1 4];
X	set e [lindex $t1 5];
X	set f [lindex $t1 6];
X	switch -exact $type {
X	    ammann-A4-s {
X		# basic edges in subdivided tile
X		set pqh [vsub $e $d];
X		set pqv [vsub $d $c];
X		set ph [vsub [vsub $f $a] [vscale 2 $pqh]];
X		set pv [vsub [vsub $b $a] [vscale 2 $pqv]];
X		# clockwise from a around the edge
X		set p [vadd $a $pqv];
X		set q [vadd $b $pqh];
X		set s [vadd $f $pqv];
X		set r [vadd $s $pqv];
X		set t [vadd $a $pqh];
X		# jogs in
X		set p1 [vadd $p $ph];
X		set p11 [vadd $p1 $pv];
X		set q1 [vsub $q $pqv];
X		set q2 [vadd $q $pqh]
X		set r1 [vsub $r $ph];
X		set s1 [vsub $s $pqh];
X		set t1 [vadd $t $pv];
X		set t11 [vadd $t1 $ph];
X		lappend newt [list ammann-A4-s $q $q1 $p11 $p1 $p $b];
X		lappend newt [list ammann-A4-s $d $c $q2 $r1 $r $e];
X		lappend newt [list ammann-A4-s $s $s1 $t11 $t1 $t $f];
X		lappend newt [list ammann-A4-l $a $p $p1 $p11 [vadd $p11 $pqh] $t11 $t1 $t];
X		lappend newt [list ammann-A4-l $q $q2 $r1 $r $s $s1 [vadd $p11 $pqh] $q1];
X	    }
X	    ammann-A4-l {
X		# remaining input vertices
X		set g [lindex $t1 7];
X		set h [lindex $t1 8];
X		# basic edges in subdivided tiles
X		set pqh [vsub $c $b];
X		set pqv [vsub $d $c];
X		set ph [vsub [vsub $e $d] [vscale 2 $pqh]];
X		set pv [vsub [vsub $b $a] [vscale 2 $pqv]];
X		# clockwise from a around the edge
X		set p [vadd $a $pqv];
X		set q [vsub $e $pqh];
X		set r [vsub $e $pqv];
X		set s [vadd $a $pqh];
X		# jogs in from from edge
X		set p1 [vadd $p $ph];
X		set p11 [vadd $p1 $pv];
X		set c1 [vsub $c $pqv];
X		set c2 [vadd $c $pqh];
X		set q1 [vsub $q $pv];
X		set q11 [vsub $q1 $ph];
X		set r1 [vsub $r $ph];
X		set r11 [vsub $r1 $pv];
X		set g1 [vadd $g $pqv];
X		set g2 [vsub $g $pqh];
X		set s1 [vadd $s $pv];
X		set s11 [vadd $s1 $ph];
X		lappend newt [list ammann-A4-s $c $c1 $p11 $p1 $p $b];
X		lappend newt [list ammann-A4-s $c $c2 $q11 $q1 $q $d];
X		lappend newt [list ammann-A4-s $g $g2 $s11 $s1 $s $h];
X		lappend newt [list ammann-A4-s $g $g1 $r11 $r1 $r $f];
X		lappend newt [list ammann-A4-l $a $p $p1 $p11 [vadd $p11 $pqh] $s11 $s1 $s];
X		lappend newt [list ammann-A4-l $e $r $r1 $r11 [vsub $r11 $pqh] $q11 $q1 $q];
X		lappend newt [list ammann-A4-l $c $c2 [vsub $r11 $pqh] $g1 $g $g2 [vadd $p11 $pqh] $c1];
X	    }
X	    default {
X		error "unknown tile type $type";
X	    }
X	}
X    }
X    return $newt;
X}
X
X########################################################################
X#
X# the octagonal tiling
X#
Xset r [list [list ammann-A5-r\
X		 [vmake 0 sin(3*$Pi/8)]\
X		 [vmake cos(3*$Pi/8) 0]\
X		 [vmake 2*cos(3*$Pi/8) sin(3*$Pi/8)]\
X		 [vmake cos(3*$Pi/8) 2*sin(3*$Pi/8)]]];
Xset s [list [list ammann-A5-s\
X		 [vmake 0 $Sqrt2/2]\
X		 [vmake $Sqrt2/2 $Sqrt2]\
X		 [vmake $Sqrt2 $Sqrt2/2]\
X		 [vmake $Sqrt2/2 0]\
X		]];
Xset subtile(ammann-A5-ops-menu) \
X    [list \
X	 {{About Amman Tilings} ammann-about} \
X	 {{Convert to triangles and rhomb} ammann-do-A5-dissect-to-A5T} \
X	];
Xset subtile(ammann-A5-start-menu) \
X    [list \
X	 [list Rhomb $r] \
X	 [list Square $s] \
X	];
X
Xproc ammann-do-A5-dissect-to-A5T {tiles} {
X    return [list ammann-A5T [ammann-A5-dissect-to-A5T $tiles]];
X}
Xproc ammann-A5-make {tiles divide} {
X    if {$divide == 0} {
X	return [list ammann-A5 $tiles];
X    } else {
X	return [list ammann-A5 [ammann-A5T-anneal-to-A5 [ammann-A5T-dissect [ammann-A5-dissect-to-A5T $tiles]]]];
X    }
X}
Xproc ammann-A5-dissect-to-A5T {tiles} {
X    set newt {};
X    foreach t1 $tiles {
X	set type [lindex $t1 0];
X	switch -exact $type {
X	    ammann-A5-r {
X		lappend newt $t1;
X	    }
X	    ammann-A5-s {
X		set a [lindex $t1 1];
X		set b [lindex $t1 2];
X		set c [lindex $t1 3];
X		set d [lindex $t1 4];
X		lappend newt\
X		    [list ammann-A5T-tL $a $b $d]\
X		    [list ammann-A5T-tR $c $b $d];
X	    }
X	}
X    }
X    return $newt;
X}
X
Xset r [list [list ammann-A5-r\
X		 [vmake 0 sin(3*$Pi/8)]\
X		 [vmake cos(3*$Pi/8) 0]\
X		 [vmake 2*cos(3*$Pi/8) sin(3*$Pi/8)]\
X		 [vmake cos(3*$Pi/8) 2*sin(3*$Pi/8)]]];
Xset tL [list [list ammann-A5T-tL\
X		  [vmake 0 $Sqrt2/2]\
X		  [vmake $Sqrt2/2 $Sqrt2]\
X		  [vmake $Sqrt2/2 0]\
X		 ]];
Xset tR [list [list ammann-A5T-tR\
X		  [vmake $Sqrt2 $Sqrt2/2]\
X		  [vmake $Sqrt2/2 $Sqrt2]\
X		  [vmake $Sqrt2/2 0]\
X		 ]];
Xset subtile(ammann-A5T-ops-menu) \
X    [list \
X	 {{About Amman Tilings} ammann-about} \
X	 {{Anneal to A5 square and rhomb} ammann-do-A5T-anneal-to-A5} \
X	];
Xset subtile(ammann-A5T-start-menu) \
X    [list \
X	 [list Rhomb $r] \
X	 [list {Left half-square} $tL] \
X	 [list {Right half-square} $tR] \
X	];
X
Xproc ammann-do-A5T-anneal-to-A5 {tiles} {
X    return [list ammann-A5 [ammann-A5T-anneal-to-A5 $tiles]];
X}
Xproc ammann-A5T-make {tiles divide} {
X    if {$divide == 0} {
X	return [list ammann-A5T $tiles];
X    } else {
X	return [list ammann-A5T [ammann-A5T-dissect $tiles]];
X    }
X}
Xproc ammann-A5T-dissect {tiles} {
X    set newt {};
X    foreach t1 $tiles {
X	set type [lindex $t1 0];
X	set a [lindex $t1 1];
X	set b [lindex $t1 2];
X	set c [lindex $t1 3];
X	switch -exact $type {
X	    ammann-A5-r {
X		set d [lindex $t1 4];
X		upvar \#0 ammann(ammann-g) g;
X		upvar \#0 ammann(ammann-h) h;
X		set p [vadd $a [vscale $g [vsub $b $a]]];
X		set q [vadd $c [vscale $g [vsub $b $c]]];
X		set r [vadd $c [vscale $g [vsub $d $c]]];
X		set s [vadd $a [vscale $g [vsub $d $a]]];
X		set t [vadd $b [vscale $h [vsub $d $b]]];
X		set u [vadd $d [vscale $h [vsub $b $d]]];
X		lappend newt\
X		    [list ammann-A5-r $p $b $q $t]\
X		    [list ammann-A5-r $t $c $u $a]\
X		    [list ammann-A5-r $s $u $r $d]\
X		    [list ammann-A5T-tR $t $p $a]\
X		    [list ammann-A5T-tL $u $s $a]\
X		    [list ammann-A5T-tL $t $q $c]\
X		    [list ammann-A5T-tR $u $r $c];
X	    }
X	    ammann-A5T-tL -
X	    ammann-A5T-tR {
X		if {"$type" == {ammann-A5T-tL}} {
X		    set othertype ammann-A5T-tR;
X		} else {
X		    set othertype ammann-A5T-tL;
X		}
X		upvar \#0 ammann(ammann-g) g;
X		upvar \#0 ammann(ammann-h) h;
X		upvar \#0 ammann(ammann-i) i;
X		set p [vadd $b [vscale $g [vsub $a $b]]];
X		set q [vadd $b [vscale $i [vsub $c $b]]];
X		set r [vadd $c [vscale $i [vsub $b $c]]];
X		set s [vadd $a [vscale $g [vsub $c $a]]];
X		set t [vadd $r [vsub $s $c]];
X		lappend newt\
X		    [list ammann-A5-r $p $a $t $q]\
X		    [list ammann-A5-r $r $t $s $c]\
X		    [list $type $t $r $q]\
X		    [list $othertype $q $p $b]\
X		    [list $othertype $t $s $a];
X	    }
X	    default {
X		error "unknown tile type $type";
X	    }
X	}
X    }
X    return $newt;
X}
Xproc ammann-A5T-anneal-to-A5 {tiles} {
X    set newt {};
X    foreach t1 $tiles {
X	switch [lindex $t1 0] {
X	    ammann-A5-r {
X		lappend newt $t1;
X	    }
X	    ammann-A5T-tL {
X		set point [lindex $t1 2],[lindex $t1 3];
X		if {[info exists t($point)]} {
X		    set t2 [lindex $t($point) 0];
X		    lappend newt [list ammann-A5-s [lindex $t1 1] [lindex $t1 2] [lindex $t2 1] [lindex $t2 3]];
X		    unset t($point);
X		} else {
X		    lappend t($point) $t1;
X		}
X	    }
X	    ammann-A5T-tR {
X		set point [lindex $t1 2],[lindex $t1 3];
X		if {[info exists t($point)]} {
X		    set t2 [lindex $t($point) 0];
X		    lappend newt [list ammann-A5-s [lindex $t2 1] [lindex $t2 2] [lindex $t1 1] [lindex $t1 3]];
X		    unset t($point);
X		} else {
X		    lappend t($point) $t1;
X		}
X	    }
X	}
X    }
X    return $newt;
X}
X
END_OF_FILE
if test 14442 -ne `wc -c <'subtile/tiling/ammann.tcl'`; then
    echo shar: \"'subtile/tiling/ammann.tcl'\" unpacked with wrong size!
fi
# end of 'subtile/tiling/ammann.tcl'
fi
if test -f 'subtile/tiling/binary.tcl' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'subtile/tiling/binary.tcl'\"
else
echo shar: Extracting \"'subtile/tiling/binary.tcl'\" \(1972 characters\)
sed "s/^X//" >'subtile/tiling/binary.tcl' <<'END_OF_FILE'
X########################################################################
X##
X## binary prototiles
X##
Xlappend subtile(tilings) {Binary binary};
X
Xset binary(binary-d1) [vmake sqrt(2+$Tau) 0];
Xset binary(binary-a1) [rmake $Pi/10];
Xset binary(binary-a2) [rmake -$Pi/10];
X
Xset c [vmake cos($Pi/5) sin($Pi/5)];
Xset e [vmake cos(2*$Pi/5) sin(2*$Pi/5)];
Xset t [list [list binary-t {0 0} {1.5 0} [vscale 1.5 [vadd 1 $c]] [vscale 1.5 $c]]];
Xset T [list [list binary-T {0 0} {1.5 0} [vscale 1.5 [vadd 1 $e]] [vscale 1.5 $e]]];
Xset subtile(binary-ops-menu) {};
Xset subtile(binary-start-menu) \
X    [list \
X	 [list {Thick rhomb} $T] \
X	 [list {Thin rhomb} $t] \
X	];
X
Xproc binary-make {tiles divide} {
X    if {$divide == 0} {
X	return [list binary $tiles];
X    } else {
X	set newt {};
X	foreach t1 $tiles {
X	    eval lappend newt [eval binary-dissect $t1];
X	}
X	return [list binary $newt];
X    }
X}
X
Xproc binary-dissect {type a b c d} {
X    switch -exact $type {
X	binary-t {
X	    upvar \#0 binary(binary-d1) d1;
X	    upvar \#0 binary(binary-a1) a1
X	    upvar \#0 binary(binary-a2) a2
X	    set w [vadd $a [vrotate $a2 [vscale 1/$d1 [vsub $b $a]]]];
X	    set y [vadd $a [vrotate $a1 [vscale 1/$d1 [vsub $d $a]]]];
X	    set z [vsub [vadd $w $y] $a];
X	    set u [vsub [vadd $z $d] $y];
X	    return [list\
X			[list binary-T $z $y $a $w]\
X			[list binary-t  $w $b $u $z]\
X			[list binary-t  $u $d $y $z]\
X		       ];
X	}
X	binary-T {
X	    upvar \#0 binary(binary-d1) d1;
X	    upvar \#0 binary(binary-a1) a1
X	    upvar \#0 binary(binary-a2) a2
X	    set w [vadd $a [vrotate $a2 [vscale 1/$d1 [vsub $b $a]]]];
X	    set y [vadd $a [vrotate $a2 [vscale 1/$d1 [vsub $d $a]]]];
X	    set z [vsub [vadd $w $y] $a];
X	    set u [vsub [vadd $z $d] $y];
X	    set v [vsub [vadd $b $z] $w];
X	    return [list\
X			[list binary-T $z $y $a $w]\
X			[list binary-T $z $u $d $y]\
X			[list binary-T $z $v $c $u]\
X			[list binary-t  $w $b $v $z]\
X		       ];
X	}
X	default {
X	    error "unknown tile type $type";
X	}
X    }
X}
X
END_OF_FILE
if test 1972 -ne `wc -c <'subtile/tiling/binary.tcl'`; then
    echo shar: \"'subtile/tiling/binary.tcl'\" unpacked with wrong size!
fi
# end of 'subtile/tiling/binary.tcl'
fi
if test -f 'subtile/tiling/chair.tcl' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'subtile/tiling/chair.tcl'\"
else
echo shar: Extracting \"'subtile/tiling/chair.tcl'\" \(1189 characters\)
sed "s/^X//" >'subtile/tiling/chair.tcl' <<'END_OF_FILE'
X########################################################################
X##
X## Chair tiling
X##
Xlappend subtile(tilings) {Chair chair};
X
Xset subtile(chair-ops-menu) {};
X
Xset subtile(chair-start-menu) \
X    [list \
X	 [list Chair {{chair {1 1} {1 2} {0 2} {0 0} {2 0} {2 1}}}] \
X	];
X
Xproc chair-make {tiles divide} {
X    if {$divide == 0} {
X	return [list chair $tiles];
X    } else {
X	set newt {};
X	foreach t1 $tiles {
X	    eval lappend newt [eval chair-dissect $t1];
X	}
X	return [list chair $newt];
X    }
X}
X
Xproc chair-dissect {type a b c d e f} {
X    set r [vscale 1/2.0 [vadd $a $b]];
X    set s [vscale 1/2.0 [vadd $d $c]];
X    set t [vscale 1/2.0 [vadd $d $e]];
X    set u [vscale 1/2.0 [vadd $a $f]];
X    set v [vscale 1/8.0 [vsum [vscale 3 $c] $d [vscale 2 [vadd $a $b]]]];
X    set w [vscale 1/8.0 [vsum [vscale 2 $a] [vscale 4 $d] $c $e]];
X    set x [vscale 1/8.0 [vsum [vscale 2 [vadd $a $f]] $d [vscale 3 $e]]];
X    set y [vscale 1/4.0 [vsum [vscale 2 $a] $c $d]];
X    set z [vscale 1/4.0 [vsum [vscale 2 $a] $d $e]];
X    return [list\
X		[list chair $a $r $v $w $x $u]\
X		[list chair $v $r $b $c $s $y]\
X		[list chair $w $y $s $d $t $z]\
X		[list chair $x $z $t $e $f $u]\
X	       ];
X}
X
END_OF_FILE
if test 1189 -ne `wc -c <'subtile/tiling/chair.tcl'`; then
    echo shar: \"'subtile/tiling/chair.tcl'\" unpacked with wrong size!
fi
# end of 'subtile/tiling/chair.tcl'
fi
if test -f 'subtile/tiling/danzer.tcl' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'subtile/tiling/danzer.tcl'\"
else
echo shar: Extracting \"'subtile/tiling/danzer.tcl'\" \(4958 characters\)
sed "s/^X//" >'subtile/tiling/danzer.tcl' <<'END_OF_FILE'
X########################################################################
X##
X## Danzer's triangular prototiles with 7-fold symmetry
X## triangle A - isoceles with sides b-a-a
X## triangle B - scalene with sides a-c-b (in left and right handed versions)
X## triangle C - isoceles with sides a-c-c
X## edge b = 0.445041867913 * a
X## edge c = 0.801937735804 * a
X## 
X## The edges scale by 0.356895867892 when dissecting
X##
Xlappend subtile(tilings) {{Danzer triangular 7-fold} danzer};
X
Xset danzer(danzer-a) 1.0;
Xset danzer(danzer-b) [expr 0.445041867913 * $danzer(danzer-a)];
Xset danzer(danzer-c) [expr 0.801937735804 * $danzer(danzer-a)];
Xset danzer(danzer-x) [expr (1+pow($danzer(danzer-b),2)-pow($danzer(danzer-c),2))*$danzer(danzer-a)/2.0];
Xset danzer(danzer-y) [expr sqrt(pow($danzer(danzer-b),2)-pow($danzer(danzer-x),2))];
Xset danzer(danzer-g) 0.356895867892;
X
Xproc danzer-about {tiles} {
X    about-something {About Danzer's 7-fold Tiling} {
X	Danzer's 7-fold tiling is described in section 7.4.1 of
X	Senechal (1995).
X	
X	It is remarkable because it is the first
X	tiling to display 7-fold symmetry.
X    }
X    return $tiles;
X}
X
Xset AL [list [list danzer-A\
X		  {0 0}\
X		  [vmake $danzer(danzer-b) 0]\
X		  [vmake $danzer(danzer-b)/2.0 sqrt(1-pow($danzer(danzer-b)/2.0,2))]\
X		 ]];
Xset AR [list [list danzer-A\
X		  [vmake $danzer(danzer-b) 0]\
X		  {0 0}\
X		  [vmake $danzer(danzer-b)/2.0 sqrt(1-pow($danzer(danzer-b)/2.0,2))]\
X		 ]];
Xset BL [list [list danzer-BL\
X		  {0 0}\
X		  [vmake $danzer(danzer-a) 0]\
X		  [vmake $danzer(danzer-x) $danzer(danzer-y)]\
X		 ]];
Xset BR [list [list danzer-BR\
X		  [vmake $danzer(danzer-a) 0]\
X		  {0 0}\
X		  [vmake $danzer(danzer-a)-$danzer(danzer-x) $danzer(danzer-y)]\
X		 ]];
Xset CL [list [list danzer-C\
X		  {0 0}\
X		  [vmake $danzer(danzer-a) 0]\
X		  [vmake $danzer(danzer-a)/2.0 sqrt(pow($danzer(danzer-c),2)-pow($danzer(danzer-a)/2.0,2))]\
X		 ]];
Xset CR [list [list danzer-C\
X		  [vmake $danzer(danzer-a) 0]\
X		  {0 0}\
X		  [vmake $danzer(danzer-a)/2.0 sqrt(pow($danzer(danzer-c),2)-pow($danzer(danzer-a)/2.0,2))]\
X		 ]];
Xset subtile(danzer-ops-menu) \
X    [list \
X	 {{About Danzer Tiles} danzer-about} \
X	];
Xset subtile(danzer-start-menu) \
X    [list \
X	 [list {Small isosceles} $AL] \
X	 [list {Mirrored small isoceles} $AR] \
X	 [list {Scalene} $BL] \
X	 [list {Mirrored scalene} $BR] \
X	 [list {Large isosceles triangle} $CL] \
X	 [list {Mirrored large isosceles} $CR] \
X	];
X
Xproc danzer-make {tiles divide} {
X    if {$divide == 0} {
X	return [list danzer $tiles];
X    } else {
X	return [list danzer [danzer-dissect $tiles]];
X    }
X}
X
Xproc danzer-dissect {tiles} {
X    set newt {};
X    foreach t1 $tiles {
X	set type [lindex $t1 0];
X	set a [lindex $t1 1];
X	set b [lindex $t1 2];
X	set c [lindex $t1 3];
X	switch -exact $type {
X	    danzer-A {
X		upvar \#0 danzer(danzer-g) g;
X		set p [vadd $c [vscale $g [vsub $a $c]]];
X		set r [vadd $a [vscale $g [vsub $c $a]]];
X		set q [vadd $c [vscale $g [vsub $b $c]]];
X		set s [vadd $b [vscale $g [vsub $c $b]]];
X		set t [vadd $p [vsub $q $c]];
X		set u [vadd $a [vscale $g [vsub $b $a]]];
X		lappend newt\
X		    [list danzer-A $q $p $c]\
X		    [list danzer-A $q $p $t]\
X		    [list danzer-A $t $s $b]\
X		    [list danzer-A $t $r $a]\
X		    [list danzer-BR $t $q $s]\
X		    [list danzer-BR $a $t $u]\
X		    [list danzer-BL $t $p $r]\
X		    [list danzer-C $b $t $u];
X	    }
X	    danzer-BL -
X	    danzer-BR {
X		upvar \#0 danzer(danzer-g) g;
X		upvar \#0 danzer(danzer-a) ka;
X		upvar \#0 danzer(danzer-b) kb;
X		upvar \#0 danzer(danzer-c) kc;
X		set p [vadd $a [vscale $g [vsub $c $a]]];
X		set q [vadd $c [vscale $g*$kb/$kc [vsub $b $c]]];
X		set r [vadd $a [vscale $g [vsub $b $a]]];
X		set s [vadd $b [vscale $g*$ka/$kc [vsub $c $b]]];
X		set t [vadd $b [vscale $g [vsub $a $b]]];
X		lappend newt\
X		    [list danzer-A $s $t $b]\
X		    [list $type $a $r $p]\
X		    [list $type $c $r $q]\
X		    [list $type $s $r $t]\
X		    [list danzer-C $c $r $p]\
X		    [list danzer-C $s $r $q];
X	    }
X	    danzer-C {
X		upvar \#0 danzer(danzer-g) g;
X		upvar \#0 danzer(danzer-a) ka;
X		upvar \#0 danzer(danzer-b) kb;
X		upvar \#0 danzer(danzer-c) kc;
X		set p [vadd $a [vscale $g*$kb/$kc [vsub $c $a]]];
X		set q [vadd $c [vscale $g*$ka/$kc [vsub $a $c]]];
X		set r [vadd $c [vscale $g*$kb/$kc [vsub $b $c]]];
X		set s [vadd $b [vscale $g*$ka/$kc [vsub $c $b]]];
X		set t [vadd $b [vscale $g [vsub $a $b]]];
X		set u [vadd $a [vscale $g [vsub $b $a]]];
X		set v [vadd $q [vscale $g*$kb/$kc [vsub $b $q]]];
X		set w [vadd $b [vscale $g*$ka/$kc [vsub $q $b]]];
X		lappend newt\
X		    [list danzer-A $q $v $c]\
X		    [list danzer-A $s $w $b]\
X		    [list danzer-A $w $t $b]\
X		    [list danzer-BL $a $u $p]\
X		    [list danzer-BL $q $u $v]\
X		    [list danzer-BL $c $v $r]\
X		    [list danzer-BL $s $v $w]\
X		    [list danzer-BL $w $u $t]\
X		    [list danzer-C $q $u $p]\
X		    [list danzer-C $s $v $r]\
X		    [list danzer-C $w $u $v];
X	    }
X	    default {
X		error "unknown tile type $type";
X	    }
X	}
X    }
X    return $newt;
X}
X
END_OF_FILE
if test 4958 -ne `wc -c <'subtile/tiling/danzer.tcl'`; then
    echo shar: \"'subtile/tiling/danzer.tcl'\" unpacked with wrong size!
fi
# end of 'subtile/tiling/danzer.tcl'
fi
if test -f 'subtile/tiling/penrose.tcl' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'subtile/tiling/penrose.tcl'\"
else
echo shar: Extracting \"'subtile/tiling/penrose.tcl'\" \(16695 characters\)
sed "s/^X//" >'subtile/tiling/penrose.tcl' <<'END_OF_FILE'
X########################################################################
X##
X## Penrose tilings.
X##
X## The penrose kite-and-dart tiling is dissected into the A
X## triangulation by dividing kites along their long diagonals and darts
X## along their short diagonals.
X## The penrose rhomb tiling is dissected into the B triangulation by
X## dividing the large rhombs along their long diagonals and the small
X## rhomb along their short diagonals.
X## The penrose A trianguluation is dissected into the B triangulation
X## by renaming the small A triangles into large B triangles and
X## dividing the large A triangles into large B and small B
X## triangles.
X## The penrose B triangulation is dissected into the A triangulation
X## by renaming the small B triangles into large A triangles and
X## dividing the large B triangles into large A and small A triangles.
X##
X## The reverse annealing steps are also supported.
X##
X## There are further complicating details necessary to preserve the
X## vertex colorings which distinguish left and right handed forms of
X## each triangle.
X##
X## Each triangle is represented as a name and three vertices.  The
X## vertices are listed in counter clockwise order starting from the
X## lower left corner when the triangle is sitting on its base with the
X## two equal edges pointing up.  (Life would be simpler if I ordered
X## the mirror image vertices as clockwise).
X##
X##         +
X##        / \
X##       /   \
X##      /     \
X##     /       \
X##    /         \
X##   /           \
X##  /             \
X## o---------------+
X##
X
Xlappend subtile(tilings) \
X    {{Penrose kite and dart} penrose-KD} \
X    {{Penrose rhomb} penrose-R} \
X    {{Penrose B triangles} penrose-B}\
X    {{Penrose A triangles} penrose-A};
X
Xset penrose(pt) [expr (1/$Tau)/(1+1/$Tau)];
Xset penrose(pT) [expr 1/(1+$Tau)];
Xset penrose(pT2) [expr 1/($Tau*$Tau)];
X
X#
X#
X#
Xproc penrose-about {tiles} {
X    about-something {About Penrose Tilings} {
X	The Penrose tilings are discussed at length in Senechal (1995) and in
X	Gruenbaum and Shephard (1987).
X
X	Subtile implements the kite and dart tiling, the rhomb tiling, and the
X	two triangulations generated by slicing kites, darts, and rhombs into
X	halves.
X
X	The A triangulation is generated by slicing kites along their long
X	diagonals and darts along their short diagonals.
X
X	The B triangulation is generated by slicing large rhombs along their
X	long diagonals and small rhombs along their short diagonals.
X
X	The A and B triangulations can be converted into each other by
X	dissection or annealing. 
X    }
X    return $tiles;
X}
X#
X# kite and dart tilings
X#
Xset a [vmake 0 $Tau*sin($Pi/5)];
Xset b [vmake ($Tau+1)/2 0];
Xset c [vmake $Tau+1 $Tau*sin($Pi/5)];
Xset d [vmake ($Tau+1)/2 2*$Tau*sin($Pi/5)];
Xset e [vadd $a [vscale $Tau/($Tau+1) [vsub $c $a]]];
X
Xset K [list [list penrose-KD-K $d $e $b $a]];
Xset D [list [list penrose-KD-D $d $c $b $e]];
X
Xset subtile(penrose-KD-ops-menu) \
X    [list \
X	 {{About Penrose Tilings} penrose-about} \
X	 {{Dissect to A triangles} penrose-do-KD-dissect-to-A} \
X	];
Xset subtile(penrose-KD-start-menu) \
X    [list \
X	 [list Kite $K]\
X	 [list Dart $D] \
X	];
X
Xproc penrose-do-KD-dissect-to-A {tiles} {
X    return [list penrose-A [penrose-KD-dissect-to-A $tiles]];
X}
X
Xproc penrose-KD-make {tiles divide} {
X    if {$divide == 0} {
X	return [list penrose-KD $tiles];
X    } else {
X	return [list penrose-KD \
X		    [penrose-A-anneal-to-KD \
X			 [penrose-B-dissect-to-A \
X			      [penrose-A-dissect-to-B \
X				   [penrose-KD-dissect-to-A $tiles]]]]];
X    }
X}
X
X#
X# A triangle tilings - dissection of kite and dart
X#
Xset TL [list [list penrose-A-TL\
X		  [vmake 0 $Tau*sin(2*$Pi/5)]\
X		  [vmake 1 $Tau*sin(2*$Pi/5)]\
X		  [vmake 0.5 0]]];
Xset TR [list [list penrose-A-TR\
X		  [vmake 1 $Tau*sin(2*$Pi/5)]\
X		  [vmake 0 $Tau*sin(2*$Pi/5)]\
X		  [vmake 0.5 2*$Tau*sin(2*$Pi/5)]]];
Xset tL [list [list penrose-A-tL\
X		  [vmake 0 sin($Pi/5)]\
X		  [vmake $Tau sin($Pi/5)]\
X		  [vmake $Tau/2 0]]];
Xset tR [list [list penrose-A-tR\
X		  [vmake $Tau sin($Pi/5)]\
X		  [vmake 0 sin($Pi/5)]\
X		  [vmake $Tau/2 2*sin($Pi/5)]]];
Xset subtile(penrose-A-ops-menu) \
X    [list \
X	 {{About Penrose Tilings} penrose-about} \
X	 {{Anneal to kites and darts} penrose-do-A-anneal-to-KD} \
X	 {{Dissect to B triangles} penrose-do-A-dissect-to-B} \
X	 {{Anneal to B triangles} penrose-do-A-anneal-to-B} \
X	];
Xset subtile(penrose-A-start-menu) \
X    [list \
X	 [list {Small A Left} $tL] \
X	 [list {Small A Right} $tR] \
X	 [list {Large A Left} $TL] \
X	 [list {Large A Right} $TR] \
X	];
X
Xproc penrose-do-A-anneal-to-KD {tiles} {
X    return [list penrose-KD [penrose-A-anneal-to-KD $tiles]];
X}
X
Xproc penrose-do-A-dissect-to-B {tiles} {
X    return [list penrose-B [penrose-A-dissect-to-B $tiles]];
X}
Xproc penrose-do-A-anneal-to-B {tiles} {
X    return [list penrose-B [penrose-A-anneal-to-B $tiles]];
X}
Xproc penrose-A-make {tiles divide} {
X    if {$divide == 0} {
X	return [list penrose-A $tiles];
X    } else {
X	return [list penrose-A [penrose-B-dissect-to-A [penrose-A-dissect-to-B $tiles]]];
X    }
X}
X
X#
X# B triangle tilings - dissection of rhombs, dissection or annealing of A triangles.
X#
Xset tL [list [list penrose-B-tL\
X		  [vmake 0 $Tau*sin(2*$Pi/5)]\
X		  [vmake 1 $Tau*sin(2*$Pi/5)]\
X		  [vmake 0.5 0]]];
Xset tR [list [list penrose-B-tR\
X		  [vmake 1 $Tau*sin(2*$Pi/5)]\
X		  [vmake 0 $Tau*sin(2*$Pi/5)]\
X		  [vmake 0.5 2*$Tau*sin(2*$Pi/5)]]];
Xset TL [list [list penrose-B-TL\
X		  [vmake 0 $Tau*sin($Pi/5)]\
X		  [vmake $Tau+1 $Tau*sin($Pi/5)]\
X		  [vmake ($Tau+1)/2 0]]];
Xset TR [list [list penrose-B-TR\
X		  [vmake $Tau+1 $Tau*sin($Pi/5)]\
X		  [vmake 0 $Tau*sin($Pi/5)]\
X		  [vmake ($Tau+1)/2 2*$Tau*sin($Pi/5)]]];
Xset subtile(penrose-B-ops-menu) \
X    [list \
X	 {{About Penrose Tilings} penrose-about} \
X	 {{Anneal to rhombs} penrose-do-B-anneal-to-R} \
X	 {{Dissect to A triangles} penrose-do-B-dissect-to-A} \
X	 {{Anneal to A triangles} penrose-do-B-anneal-to-A} \
X	];
Xset subtile(penrose-B-start-menu) \
X    [list \
X	 [list {Small B Left} $tL] \
X	 [list {Small B Right} $tR] \
X	 [list {Large B Left} $TL] \
X	 [list {Large B Right} $TR] \
X	];
X
Xproc penrose-do-B-anneal-to-R {tiles} {
X    return [list penrose-R [penrose-B-anneal-to-R $tiles]];
X}
Xproc penrose-do-B-dissect-to-A {tiles} {
X    return [list penrose-A [penrose-B-dissect-to-A $tiles]];
X}
Xproc penrose-do-B-anneal-to-A {tiles} {
X    return [list penrose-A [penrose-B-anneal-to-A $tiles]];
X}
Xproc penrose-B-make {tiles divide} {
X    if {$divide == 0} {
X	return [list penrose-B $tiles];
X    } else {
X	return [list penrose-B [penrose-A-dissect-to-B [penrose-B-dissect-to-A $tiles]]];
X    }
X}
X    
X#
X# rhomb tilings
X#
Xset r [list [list penrose-R-r\
X		 [vmake 0 $Tau*sin(2*$Pi/5)]\
X		 [vmake 0.5 0]\
X		 [vmake 1 $Tau*sin(2*$Pi/5)]\
X		 [vmake 0.5 2*$Tau*sin(2*$Pi/5)]]];
Xset R [list [list penrose-R-R\
X		 [vmake 0 $Tau*sin($Pi/5)]\
X		 [vmake ($Tau+1)/2 0]\
X		 [vmake $Tau+1 $Tau*sin($Pi/5)]\
X		 [vmake ($Tau+1)/2 2*$Tau*sin($Pi/5)]]];
Xset subtile(penrose-R-ops-menu) \
X    [list \
X	 {{About Penrose Tilings} penrose-about} \
X	 {{Dissect to B triangles} penrose-do-R-dissect-to-B} \
X	];
Xset subtile(penrose-R-start-menu) \
X    [list \
X	 [list {Large rhomb} $R] \
X	 [list {Small rhomb} $r] \
X	];
X
Xproc penrose-do-R-dissect-to-B {tiles} {
X    return [list penrose-B [penrose-R-dissect-to-B $tiles]];
X}
Xproc penrose-R-make {tiles divide} {
X    if {$divide == 0} {
X	return [list penrose-R $tiles];
X    } else {
X	return [list penrose-R \
X		    [penrose-B-anneal-to-R \
X			 [penrose-A-dissect-to-B \
X			      [penrose-B-dissect-to-A \
X				   [penrose-R-dissect-to-B $tiles]]]]];
X    }
X}
X
X#
X# annealing utility
X#
Xproc penrose-tile-match {type listname tilename} {
X    upvar $listname list;
X    upvar $tilename tile;
X    if { ! [info exists list]} {
X	return 0;
X    }
X    for {set i 0} {$i < [llength $list]} {incr i} {
X	set t1 [lindex $list $i];
X	if {"[lindex $t1 0]" == "$type"} {
X	    set list [lreplace $list $i $i];
X	    if {"$list" == {}} {
X		unset list;
X	    }
X	    set tile $t1;
X	    return 1;
X	}
X    }
X    return 0;
X}
X
X    
X#
X# dissect a list of penrose-R tiles to a list of penrose-B tiles
X#
Xproc penrose-R-dissect-to-B {tiles} {
X    set newt {};
X    foreach tile $tiles {
X	set type [lindex $tile 0];
X	set a [lindex $tile 1];
X	set b [lindex $tile 2];
X	set c [lindex $tile 3];
X	set d [lindex $tile 4];
X	switch -exact $type {
X	    penrose-R-R {
X		lappend newt [list penrose-B-TL $a $c $b] [list penrose-B-TR $c $a $d];
X	    }
X	    penrose-R-r {
X		lappend newt [list penrose-B-tL $a $c $b] [list penrose-B-tR $c $a $d];
X	    }
X	    default {
X		error "found tile of type $type";
X	    }
X	}
X    }
X    return $newt;
X}
X
X#
X# anneal a list of penrose-B tiles to a list of penrose-R tiles
X#
Xproc penrose-B-anneal-to-R {tiles} {
X    set newt {};
X    foreach t1 $tiles {
X	set type [lindex $t1 0];
X	set a [lindex $t1 1];
X	set b [lindex $t1 2];
X	set c [lindex $t1 3];
X	switch -exact $type {
X	    penrose-B-tL {
X		set point $a,$b;
X		if {[penrose-tile-match penrose-B-tR t($point) t2]} {
X		    lappend newt [list penrose-R-r $a $c [lindex $t2 1] [lindex $t2 3]];
X		} else {
X		    lappend t($point) $t1;
X		}
X	    }
X	    penrose-B-tR {
X		set point $b,$a;
X		if {[penrose-tile-match penrose-B-tL t($point) t2]} {
X		    lappend newt [list penrose-R-r [lindex $t2 1] [lindex $t2 3] $a $c];
X		} else {
X		    lappend t($point) $t1;
X		}
X	    }
X	    penrose-B-TL {
X		set point $a,$b;
X		if {[penrose-tile-match penrose-B-TR t($point) t2]} {
X		    lappend newt [list penrose-R-R $a $c [lindex $t2 1] [lindex $t2 3]];
X		} else {
X		    lappend t($point) $t1;
X		}
X	    }
X	    penrose-B-TR {
X		set point $b,$a;
X		if {[penrose-tile-match penrose-B-TL t($point) t2]} {
X		    lappend newt [list penrose-R-R [lindex $t2 1] [lindex $t2 3] $a $c];
X		} else {
X		    lappend t($point) $t1;
X		}
X	    }
X	    default {
X		error "found tile of type $type";
X	    }
X	}
X    }
X    return $newt;
X}
X
X#
X# dissect a list of penrose-B tiles to a list of penrose-A tiles
X#
Xproc penrose-B-dissect-to-A {tiles} {
X    upvar \#0 penrose(pT) pT;
X    set newt {};
X    foreach tile $tiles {
X	set type [lindex $tile 0];
X	set a [lindex $tile 1];
X	set b [lindex $tile 2];
X	set c [lindex $tile 3];
X	switch -exact $type {
X	    penrose-B-tL {
X		lappend newt [list penrose-A-TL $a $b $c];
X	    }
X	    penrose-B-tR {
X		lappend newt [list penrose-A-TR $a $b $c];
X	    }
X	    penrose-B-TL {
X		set d [vadd $b [vscale $pT [vsub $a $b]]];
X		lappend newt [list penrose-A-TR $d $c $a] [list penrose-A-tL $b $c $d];
X	    }
X	    penrose-B-TR {
X		set d [vadd $a [vscale $pT [vsub $b $a]]];
X		lappend newt [list penrose-A-TL $c $d $b] [list penrose-A-tR $c $a $d];
X	    }
X	    default {
X		error "found tile of type $type";
X	    }
X	}
X    }
X    return $newt;
X}
X
X#
X# anneal a list of penrose-A tiles to a list of penrose-B tiles
X#
Xproc penrose-A-anneal-to-B {tiles} {
X    set newt {};
X    foreach t1 $tiles {
X	set type [lindex $t1 0];
X	set a [lindex $t1 1];
X	set b [lindex $t1 2];
X	set c [lindex $t1 3];
X	switch -exact $type {
X	    penrose-A-tL {
X		set point $b,$c;
X		if {[penrose-tile-match penrose-A-TR t($point) t2]} {
X		    lappend newt [list penrose-B-TL [lindex $t2 3] $a $b];
X		} else {
X		    lappend t($point) $t1;
X		}
X	    }
X	    penrose-A-TR {
X		set point $b,$a;
X		if {[penrose-tile-match penrose-A-tL t($point) t2]} {
X		    lappend newt [list penrose-B-TL $c [lindex $t2 1] [lindex $t2 2]];
X		} else {
X		    lappend t($point) $t1;
X		}
X	    }
X	    penrose-A-TL {
X		set point $a,$b;
X		if {[penrose-tile-match penrose-A-tR t($point) t2]} {
X		    lappend newt [list penrose-B-TR [lindex $t2 2] $c $a];
X		} else {
X		    lappend t($point) $t1;
X		}
X	    }
X	    penrose-A-tR {
X		set point $a,$c;
X		if {[penrose-tile-match penrose-A-TL t($point) t2]} {
X		    lappend newt [list penrose-B-TR $b [lindex $t2 3] [lindex $t2 1]];
X		} else {
X		    lappend t($point) $t1;
X		}
X	    }
X	    default {
X		error "found tile of type $type";
X	    }
X	}
X    }
X    foreach point [array names t] {
X	foreach t1 $t($point) {
X	    set type [lindex $t1 0];
X	    set a [lindex $t1 1];
X	    set b [lindex $t1 2];
X	    set c [lindex $t1 3];
X	    switch -exact $type {
X		penrose-A-TR {
X		    lappend newt [list penrose-B-tR $a $b $c];
X		}
X		penrose-A-TL {
X		    lappend newt [list penrose-B-tL $a $b $c];
X		}
X		default {
X		    puts stderr "leftover tile: $t1";
X		}
X	    }
X	}
X    }
X    return $newt;
X}
X#
X# dissect a list of penrose-A tiles into a list of penrose-B tiles
X#
Xproc penrose-A-dissect-to-B {tiles} {
X    upvar \#0 penrose(pT2) pT2;
X    set newt {};
X    foreach tile $tiles {
X	set type [lindex $tile 0];
X	set a [lindex $tile 1];
X	set b [lindex $tile 2];
X	set c [lindex $tile 3];
X	switch -exact $type {
X	    penrose-A-tL {
X		lappend newt [list penrose-B-TL $a $b $c];
X	    }
X	    penrose-A-tR {
X		lappend newt [list penrose-B-TR $a $b $c];
X	    }
X	    penrose-A-TL {
X		set d [vadd $a [vscale $pT2 [vsub $c $a]]];
X		lappend newt [list penrose-B-TL $b $c $d] [list penrose-B-tL $d $a $b];
X	    }
X	    penrose-A-TR {
X		set d [vadd $b [vscale $pT2 [vsub $c $b]]];
X		lappend newt [list penrose-B-TR $c $a $d] [list penrose-B-tR $b $d $a];
X	    }
X	    default {
X		error "found tile of type $type";
X	    }
X	}
X    }
X    return $newt;
X}
X#
X# anneal a list of penrose-B tiles into a list of penrose-A tiles
X#
Xproc penrose-B-anneal-to-A {tiles} {
X    set newt {};
X    foreach t1 $tiles {
X	set type [lindex $t1 0];
X	set a [lindex $t1 1];
X	set b [lindex $t1 2];
X	set c [lindex $t1 3];
X	switch -exact $type {
X	    penrose-B-tL {
X		set point $a,$c;
X		if {[penrose-tile-match penrose-B-TL t($point) t2]} {
X		    lappend newt [list penrose-A-TL $b $c [lindex $t2 2]];
X		} else {
X		    lappend t($point) $t1;
X		}
X	    }
X	    penrose-B-TL {
X		set point $c,$a;
X		if {[penrose-tile-match penrose-B-tL t($point) t2]} {
X		    lappend newt [list penrose-A-TL [lindex $t2 2] [lindex $t2 3] $b];
X		} else {
X		    lappend t($point) $t1;
X		}
X	    }
X	    penrose-B-tR {
X		set point $b,$c;
X		if {[penrose-tile-match penrose-B-TR t($point) t2]} {
X		    lappend newt [list penrose-A-TR $c $a [lindex $t2 1]];
X		} else {
X		    lappend t($point) $t1;
X		}
X	    }
X	    penrose-B-TR {
X		set point $c,$b;
X		if {[penrose-tile-match penrose-B-tR t($point) t2]} {
X		    lappend newt [list penrose-A-TR [lindex $t2 3] [lindex $t2 1] $a];
X		} else {
X		    lappend t($point) $t1;
X		}
X	    }
X	    default {
X		error "found tile of type $type";
X	    }
X	}
X    }
X    foreach point [array names t] {
X	foreach t1 $t($point) {
X	    set type [lindex $t1 0];
X	    set a [lindex $t1 1];
X	    set b [lindex $t1 2];
X	    set c [lindex $t1 3];
X	    switch -exact $type {
X		penrose-B-TR {
X		    lappend newt [list penrose-A-tR $a $b $c];
X		}
X		penrose-B-TL {
X		    lappend newt [list penrose-A-tL $a $b $c];
X		}
X		default {
X		    puts stderr "leftover tile: $t1";
X		}
X	    }
X	}
X    }
X    return $newt;
X}
X#
X# dissect a list of penrose-KD tiles into a list of penrose-A tiles
X#
Xproc penrose-KD-dissect-to-A {tiles} {
X    set newt {};
X    foreach tile $tiles {
X	set type [lindex $tile 0];
X	set a [lindex $tile 1];
X	set b [lindex $tile 2];
X	set c [lindex $tile 3];
X	set d [lindex $tile 4];
X	switch -exact $type {
X	    penrose-KD-K {
X		lappend newt [list penrose-A-TL $b $c $d] [list penrose-A-TR $a $b $d];
X	    }
X	    penrose-KD-D {
X		lappend newt [list penrose-A-tL $b $c $d] [list penrose-A-tR $a $b $d];
X	    }
X	    default {
X		error "found tile of type $type";
X	    }
X	}
X    }
X    return $newt;
X}
X#
X# anneal a list of penrose-A tiles into a list of penrose-A tiles
X#
Xproc penrose-A-anneal-to-KD {tiles} {
X    set newt {};
X    foreach t1 $tiles {
X	set type [lindex $t1 0];
X	set a [lindex $t1 1];
X	set b [lindex $t1 2];
X	set c [lindex $t1 3];
X	switch -exact $type {
X	    penrose-A-tL {
X		set point $a,$c;
X		if {[info exists t($point)]} {
X		    set t2 [lindex $t($point) 0];
X		    lappend newt [list penrose-KD-D [lindex $t2 1] [lindex $t2 2] $b $c];
X		    unset t($point);
X		} else {
X		    lappend t($point) $t1;
X		}
X	    }
X	    penrose-A-tR {
X		set point $b,$c;
X		if {[info exists t($point)]} {
X		    set t2 [lindex $t($point) 0];
X		    lappend newt [list penrose-KD-D $a $b [lindex $t2 2] [lindex $t2 3]];
X		    unset t($point);
X		} else {
X		    lappend t($point) $t1;
X		}
X	    }
X	    penrose-A-TL {
X		set point $a,$c;
X		if {[info exists t($point)]} {
X		    set t2 [lindex $t($point) 0];
X		    lappend newt [list penrose-KD-K [lindex $t2 1] [lindex $t2 2] $b $c];
X		    unset t($point);
X		} else {
X		    lappend t($point) $t1;
X		}
X	    }
X	    penrose-A-TR {
X		set point $b,$c;
X		if {[info exists t($point)]} {
X		    set t2 [lindex $t($point) 0];
X		    lappend newt [list penrose-KD-K $a $b [lindex $t2 2] [lindex $t2 3]];
X		    unset t($point);
X		} else {
X		    lappend t($point) $t1;
X		}
X	    }
X	    default {
X		error "found tile of type $type";
X	    }
X	}
X    }
X    return $newt;
X}
X
END_OF_FILE
if test 16695 -ne `wc -c <'subtile/tiling/penrose.tcl'`; then
    echo shar: \"'subtile/tiling/penrose.tcl'\" unpacked with wrong size!
fi
# end of 'subtile/tiling/penrose.tcl'
fi
if test -f 'subtile/tiling/pinwheel.tcl' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'subtile/tiling/pinwheel.tcl'\"
else
echo shar: Extracting \"'subtile/tiling/pinwheel.tcl'\" \(942 characters\)
sed "s/^X//" >'subtile/tiling/pinwheel.tcl' <<'END_OF_FILE'
X########################################################################
X##
X## Pinwheel tiling
X##
Xlappend subtile(tilings) {Pinwheel pinwheel}
X
Xset pinwheel {{pinwheel {0 0} {3 0} {0 1.5}}};
X
Xset subtile(pinwheel-ops-menu) {};
Xset subtile(pinwheel-start-menu) \
X    [list \
X	 [list Pinwheel $pinwheel] \
X	];
X
Xproc pinwheel-make {tiles divide} {
X    if {$divide == 0} {
X	return [list pinwheel $tiles];
X    } else {
X	set newt {};
X	foreach t1 $tiles {
X	    eval lappend newt [eval pinwheel-dissect $t1];
X	}
X	return [list pinwheel $newt];
X    }
X}
X
Xproc pinwheel-dissect {type a b c} {
X    set w [vscale 1/2.0 [vadd $a $b]];
X    set x [vscale 1/5.0 [vadd [vscale 3 $b] [vscale 2 $c]]];
X    set y [vscale 1/5.0 [vadd $b [vscale 4 $c]]];
X    set z [vscale 1/2.0 [vadd $a $y]];
X    return [list\
X		[list pinwheel $y $a $c]\
X		[list pinwheel $z $w $a]\
X		[list pinwheel $x $y $w]\
X		[list pinwheel $x $b $w]\
X		[list pinwheel $z $w $y]\
X	       ];
X}
X
END_OF_FILE
if test 942 -ne `wc -c <'subtile/tiling/pinwheel.tcl'`; then
    echo shar: \"'subtile/tiling/pinwheel.tcl'\" unpacked with wrong size!
fi
# end of 'subtile/tiling/pinwheel.tcl'
fi
if test -f 'subtile/tiling/sphinx.tcl' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'subtile/tiling/sphinx.tcl'\"
else
echo shar: Extracting \"'subtile/tiling/sphinx.tcl'\" \(1163 characters\)
sed "s/^X//" >'subtile/tiling/sphinx.tcl' <<'END_OF_FILE'
X########################################################################
X##
X## Sphinx tiling
X##
Xlappend subtile(tilings) {Sphinx sphinx}
X
Xset subtile(sphinx-ops-menu) {};
X
Xset q [expr sqrt(3)];
X
Xset sphinx [list [list sphinx [vmake 2.0 $q] [vmake 1.5  $q/2.0] [vmake 0.5 $q/2.0] {0 0} {3 0}]];
X
Xset subtile(sphinx-start-menu) \
X    [list \
X	 [list Sphinx $sphinx] \
X	];
X
X
Xproc sphinx-make {tiles divide} {
X    if {$divide == 0} {
X	return [list sphinx $tiles];
X    } else {
X	set newt {};
X	foreach t1 $tiles {
X	    eval lappend newt [eval sphinx-dissect $t1];
X	}
X	return [list sphinx $newt];
X    }
X}
X
Xproc sphinx-dissect {type a b c d e} {
X    set x1 [vscale 1/2.0 [vadd $d $b]]; 
X    set x2 [vscale 1/6.0 [vsum [vscale 2 $d] $e [vscale 3 $b]]]; 
X    set x3 [vscale 1/12.0 [vsum [vscale 2 $d] [vscale 4 $e] [vscale 3 $a] [vscale 3 $e]]];
X    set x4 [vscale 1/4.0 [vadd [vscale 3 $e] $a]]; 
X    set x5 [vscale 1/4.0 [vsum [vscale 2 $b] $a $e]];
X    set x6 [vscale 1/2.0 [vadd $d $e]]; 
X    return [list\
X		[list sphinx  $c $x1 $x2 $x6  $d]\
X		[list sphinx $x6 $x2 $x1  $c $x5]\
X		[list sphinx  $b $x5 $x3 $x4  $a]\
X		[list sphinx $x5 $x3 $x4  $e $x6]\
X	       ];
X}
X
END_OF_FILE
if test 1163 -ne `wc -c <'subtile/tiling/sphinx.tcl'`; then
    echo shar: \"'subtile/tiling/sphinx.tcl'\" unpacked with wrong size!
fi
# end of 'subtile/tiling/sphinx.tcl'
fi
if test -f 'subtile/tiling/xdanzer.tcl' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'subtile/tiling/xdanzer.tcl'\"
else
echo shar: Extracting \"'subtile/tiling/xdanzer.tcl'\" \(5135 characters\)
sed "s/^X//" >'subtile/tiling/xdanzer.tcl' <<'END_OF_FILE'
X########################################################################
X##
X## Definitely not Danzer's triangular prototiles with 7-fold symmetry.
X##
X## This is an erroneous dissection rule for Danzer's tiling.
X## In short, it isn't an aperiodic tiling at all, it's just
X## a recursive subdivision of the plane, of which there are
X## many.
X## The error is in failing to see that the large and small
X## isosceles triangles appear in left and right handed forms
X## in the substitution atlas.  The rule reproduced here always
X## uses the same handed form of the A and C triangles.
X##
Xlappend subtile(tilings) {{Danzer triangular 7-fold - NOT} xdanzer};
X
Xset xdanzer(danzer-a) 1.0;
Xset xdanzer(danzer-b) [expr 0.445041867913 * $xdanzer(danzer-a)];
Xset xdanzer(danzer-c) [expr 0.801937735804 * $xdanzer(danzer-a)];
Xset xdanzer(danzer-x) [expr (1+pow($xdanzer(danzer-b),2)-pow($xdanzer(danzer-c),2))*$xdanzer(danzer-a)/2.0];
Xset xdanzer(danzer-y) [expr sqrt(pow($xdanzer(danzer-b),2)-pow($xdanzer(danzer-x),2))];
Xset xdanzer(danzer-g) 0.356895867892;
X
Xproc xdanzer-about {tiles} {
X    about-something {About Danzer NOT} {
X	This tiling isn't even a tiling.  It's a mistake that I made
X	when transcribing the Danzer 7-fold tiling from Senechal's
X	book.  It was an instructive mistake because I hadn't yet
X	recognized that aperiodic substitution tilings are a very
X	small subset of	the set recursive planar subdivisions.
X	
X	It's interesting, too, because you can't distinguish this
X	substitution rule from the true Danzer 7-fold rule without the
X	edge markings.
X
X	It's also interesting because it's fourier transform is very
X	different from the others.
X    }
X    return $tiles;
X}
X
Xset subtile(xdanzer-ops-menu) \
X    [list \
X	 {{About Danzer NOT} xdanzer-about} \
X	];
X
Xset A [list [list danzer-A\
X		 {0 0}\
X		 [vmake $xdanzer(danzer-b) 0]\
X		 [vmake $xdanzer(danzer-b)/2.0 sqrt(1-pow($xdanzer(danzer-b)/2.0,2))]\
X		]];
Xset BL [list [list danzer-BL\
X		  {0 0}\
X		  [vmake $xdanzer(danzer-a) 0]\
X		  [vmake $xdanzer(danzer-x) $xdanzer(danzer-y)]\
X		 ]];
Xset BR [list [list danzer-BR\
X		  [vmake $xdanzer(danzer-a) 0]\
X		  {0 0}\
X		  [vmake $xdanzer(danzer-a)-$xdanzer(danzer-x) $xdanzer(danzer-y)]\
X		 ]];
Xset C [list [list danzer-C\
X		 {0 0}\
X		 [vmake $xdanzer(danzer-a) 0]\
X		 [vmake $xdanzer(danzer-a)/2.0 sqrt(pow($xdanzer(danzer-c),2)-pow($xdanzer(danzer-a)/2.0,2))]\
X		]];
X
Xset subtile(xdanzer-start-menu) \
X    [list \
X	 [list {Small isosceles triangle} $A]\
X	 [list {Scalene triangle 1} $BL]\
X	 [list {Scalene triangle 2} $BR]\
X	 [list {Large isosceles triangle} $C]\
X	];
X
X
Xproc xdanzer-make {tiles divide} {
X    if {$divide == 0} {
X	return [list xdanzer $tiles];
X    } else {
X	return [list xdanzer [xdanzer-dissect $tiles]];
X    }
X}
X
Xproc xdanzer-dissect {tiles} {
X    set newt {};
X    foreach t1 $tiles {
X	set type [lindex $t1 0];
X	set a [lindex $t1 1];
X	set b [lindex $t1 2];
X	set c [lindex $t1 3];
X	switch -exact $type {
X	    danzer-A {
X		upvar \#0 xdanzer(danzer-g) g;
X		set p [vadd $c [vscale $g [vsub $a $c]]];
X		set r [vadd $a [vscale $g [vsub $c $a]]];
X		set q [vadd $c [vscale $g [vsub $b $c]]];
X		set s [vadd $b [vscale $g [vsub $c $b]]];
X		set t [vadd $p [vsub $q $c]];
X		set u [vadd $a [vscale $g [vsub $b $a]]];
X		lappend newt\
X		    [list danzer-A $p $q $c]\
X		    [list danzer-A $q $p $t]\
X		    [list danzer-A $s $t $b]\
X		    [list danzer-A $t $r $a]\
X		    [list danzer-BR $t $q $s]\
X		    [list danzer-BR $a $t $u]\
X		    [list danzer-BL $t $p $r]\
X		    [list danzer-C $b $t $u];
X	    }
X	    danzer-BL -
X	    danzer-BR {
X		upvar \#0 xdanzer(danzer-g) g;
X		upvar \#0 xdanzer(danzer-a) ka;
X		upvar \#0 xdanzer(danzer-b) kb;
X		upvar \#0 xdanzer(danzer-c) kc;
X		set p [vadd $a [vscale $g [vsub $c $a]]];
X		set q [vadd $c [vscale $g*$kb/$kc [vsub $b $c]]];
X		set r [vadd $a [vscale $g [vsub $b $a]]];
X		set s [vadd $b [vscale $g*$ka/$kc [vsub $c $b]]];
X		set t [vadd $b [vscale $g [vsub $a $b]]];
X		lappend newt\
X		    [list danzer-A $s $t $b]\
X		    [list $type $a $r $p]\
X		    [list $type $c $r $q]\
X		    [list $type $s $r $t]\
X		    [list danzer-C $r $c $p]\
X		    [list danzer-C $r $s $q];
X	    }
X	    danzer-C {
X		upvar \#0 xdanzer(danzer-g) g;
X		upvar \#0 xdanzer(danzer-a) ka;
X		upvar \#0 xdanzer(danzer-b) kb;
X		upvar \#0 xdanzer(danzer-c) kc;
X		set p [vadd $a [vscale $g*$kb/$kc [vsub $c $a]]];
X		set q [vadd $c [vscale $g*$ka/$kc [vsub $a $c]]];
X		set r [vadd $c [vscale $g*$kb/$kc [vsub $b $c]]];
X		set s [vadd $b [vscale $g*$ka/$kc [vsub $c $b]]];
X		set t [vadd $b [vscale $g [vsub $a $b]]];
X		set u [vadd $a [vscale $g [vsub $b $a]]];
X		set v [vadd $q [vscale $g*$kb/$kc [vsub $b $q]]];
X		set w [vadd $b [vscale $g*$ka/$kc [vsub $q $b]]];
X		lappend newt\
X		    [list danzer-A $q $v $c]\
X		    [list danzer-A $s $w $b]\
X		    [list danzer-A $w $t $b]\
X		    [list danzer-BL $a $u $p]\
X		    [list danzer-BL $q $u $v]\
X		    [list danzer-BL $c $v $r]\
X		    [list danzer-BL $s $v $w]\
X		    [list danzer-BL $w $u $t]\
X		    [list danzer-C $u $q $p]\
X		    [list danzer-C $v $s $r]\
X		    [list danzer-C $u $w $v];
X	    }
X	    default {
X		error "unknown tile type $type";
X	    }
X	}
X    }
X    return $newt;
X}
X
END_OF_FILE
if test 5135 -ne `wc -c <'subtile/tiling/xdanzer.tcl'`; then
    echo shar: \"'subtile/tiling/xdanzer.tcl'\" unpacked with wrong size!
fi
# end of 'subtile/tiling/xdanzer.tcl'
fi
echo shar: End of shell archive.
exit 0
