/*
** Copyright (C) 2009 by Roger E Critchlow Jr,
** Santa Fe, New Mexico, USA
** rec@elf.org
**
** This program is free software; you can redistribute it and/or
** modify it under the terms of the GNU General Public License
** as published by the Free Software Foundation; either version 2
** of the License, or (at your option) any later version.
** 
** This program is distributed in the hope that it will be useful,
** but WITHOUT ANY WARRANTY; without even the implied warranty of
** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
** GNU General Public License for more details.
** 
** You should have received a copy of the GNU General Public License
** along with this program; if not, write to the Free Software
** Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
**
** The home page for this source is
**	http://www.elf.org/quantum-classical-clock/
** a copy of the GNU GPL may be found at
**	http://www.gnu.org/copyleft/gpl.html,
*/

var c = {
 width: 1200,
 height: 800,
 dpi: 200,
 steps: 32
};

function draw_stuff(sx, sy) {
  // get the root svg document    
  var root = document.getElementById("root");

  // get the view svg document
  var view = document.getElementById("view");

  // compute dimensions from dimensions
  // set page size in svg
  set_attr(view, {width: c.width/c.dpi+"in", height: c.height/c.dpi+"in", viewBox: "0 0 "+c.width+" "+c.height});
  set_attr(root, {width: c.width+"px", height: c.height+"px"});

  // make a group
  var g = g_node({transform: "translate("+(c.width/2)+","+(c.height/2)+") scale("+sx+","+sy+")"});
  root.appendChild(g);
  return g;
}

/*
** Our quantum bit is a linear combination of 60 of these centered at each
** of the integer shift register points.  The position of the bit is given
** by the square of the linear combination interpreted as a probability
** distribution.  At integer times, the bit is localized to a shift register
** bin, at intermediate times it is delocalized.  We need to compute the
** linear combinations representing the bit for one step, the solutions for
** other steps can be generated by rotational symmetry.
*/
function draw_overlaps() {
  var g = draw_stuff(1,-1);

  // compute the overlap between two functions
  // is this right?
  function overlap(i, j) {
	var o = cpx(0,0);
	var ni = 0;
	var nj = 0;
	for(var k = -30; k < 30; k += 0.0625) {
	  var pki = Phi_at(k,i);
	  var pkj = Phi_at(k,j);
	  var x1 = pki.r, y1 = pki.i;
	  var x2 = pkj.r, y2 = pkj.i;
	  o = cpxadd(o, cpxmulcnj(pki, pkj));
	  ni += cpxmag(pki);
	  nj += cpxmag(pkj);
	}
	var n = Math.sqrt(ni*nj);
	return cpx(o.r/n, o.i/n);
  }
  // compute the overlaps between a function centered at i
  // and the functions centered at integral points
  function compute_overlaps(i, y) {
	var polyline = document.createElementNS(SVG_NS, "polyline");
	var points = "";
	for (var j = -30; j < 30; j += 1) {
	  var oij = overlap(i, j);
	  var k = cpxmag(oij);
	  var x = j*15+100;
	  points += " "+x+" "+y+" "+x+" "+(y+k*25)+" "+x+" "+y;
	}
	polyline.setAttribute("points", points);
	polyline.setAttribute("fill", "black");
	polyline.setAttribute("stroke", "black");
	return polyline;
  }
  // scan through the intermediate sixteenths
  for (var i = 0; i <= 1; i += 0.0625) {
	g.appendChild(compute_overlaps(i, i*600-300));
  }
}

/*
** That's confusing, I would think that x * conj(y) would equal conj(x) * y,
** but its x * conj(y) = conj(conj(x) * y).
*/
function draw_phi() {
  var g = draw_stuff(1,-1);

  // label the hours
  g.appendChild(draw_curve(-3, 3, 0.01, 200, real_phi, "black"));
  g.appendChild(draw_curve(-3, 3, 0.01, 200, imag_phi, "gray"));
  g.appendChild(draw_x_axis(-3, 3, 1, 200));
  g.appendChild(draw_y_axis(-1, 1, 1, 200));
}

function draw_phi2() {
  var g = draw_stuff(1,-1);

  g.appendChild(draw_curve(-3, 3, 0.01, 200, phi_mag, "black"));
  g.appendChild(draw_x_axis(-3, 3, 1, 200));
  g.appendChild(draw_y_axis(-1, 1, 1, 200));
}

function draw_Phi() {
  var g = draw_stuff(1,-1);

  // label the hours
  g.appendChild(draw_curve(-3, 3, 0.01, 200, real_Phi, "black"));
  g.appendChild(draw_curve(-3, 3, 0.01, 200, imag_Phi, "gray"));
  g.appendChild(draw_x_axis(-3, 3, 1, 200));
  g.appendChild(draw_y_axis(-1, 1, 1, 200));
}

function draw_Phi2() {
  var g = draw_stuff(1,-1);

  g.appendChild(draw_curve(-3, 3, 0.01, 200, Phi_mag, "black"));
  g.appendChild(draw_x_axis(-3, 3, 1, 200));
  g.appendChild(draw_y_axis(-1, 1, 1, 200));
}

function draw_Phi_and_phi() {
  var g = draw_stuff(1,-1);

  // label the hours
  g.appendChild(draw_curve(-3, 3, 0.01, 200, real_Phi, "#ff0000"));
  g.appendChild(draw_curve(-3, 3, 0.01, 200, imag_Phi, "#7f0000"));
  g.appendChild(draw_curve(-3, 3, 0.01, 200, real_phi, "#0000ff"));
  g.appendChild(draw_curve(-3, 3, 0.01, 200, imag_phi, "#00007f"));
  g.appendChild(draw_x_axis(-3, 3, 1, 200));
  g.appendChild(draw_y_axis(-1, 1, 1, 200));
}

function draw_sinc() {
  var g = draw_stuff(1,-1);

  g.appendChild(draw_curve(-3, 3, 0.01, 200, sinc, "black"));
  g.appendChild(draw_x_axis(-3, 3, 1, 200));
  g.appendChild(draw_y_axis(-1, 1, 1, 200));
}

function draw_sinc2() {
  var g = draw_stuff(1,-1);

  g.appendChild(draw_curve(-3, 3, 0.01, 200, sinc2, "black"));
  g.appendChild(draw_x_axis(-3, 3, 1, 200));
  g.appendChild(draw_y_axis(-1, 1, 1, 200));
}

function draw_curve(xmin, xmax, dx, scale, f, stroke) {
  var polyline = document.createElementNS(SVG_NS, "polyline");
  var sep = ""
  var points = "";
  while (xmin < xmax) {
	points += sep + (scale*xmin) + " " + (scale*f(xmin));
	xmin += dx;
	sep = ","
  }
  points += sep + (scale*xmax) + " " + (scale*f(xmax));
  polyline.setAttribute("points", points);        
  polyline.setAttribute("fill", "none");
  polyline.setAttribute("stroke", stroke);
  return polyline;    
}

function draw_x_axis(xmin, xmax, dx, scale) {
  var polyline = document.createElementNS(SVG_NS, "polyline");
  var sep = ""
  var points = "";
  while (xmin <= xmax) {
	var x = (scale*xmin);
	points += sep + x+" 0," + x+" 10," + x+" -10," + x+" 0";
	xmin += dx;
	sep = ",";
  }
  polyline.setAttribute("points", points);        
  polyline.setAttribute("fill", "none");
  polyline.setAttribute("stroke", "black");
  return polyline;    
}
function draw_y_axis(ymin, ymax, dy, scale) {
  var polyline = document.createElementNS(SVG_NS, "polyline");
  var sep = ""
  var points = "";
  while (ymin <= ymax) {
	var y = (scale*ymin);
	points += sep + "0 "+y + ",10 "+y + ",-10 "+y + ",0 "+y;
	ymin += dy;
	sep = ",";
  }
  polyline.setAttribute("points", points);        
  polyline.setAttribute("fill", "none");
  polyline.setAttribute("stroke", "black");
  return polyline;    
}

/*
** well, we have sinc(x pi) = x == 0 ? 1 : sin(x pi) / (x pi)
** then we have phi(x pi) = e ^ (i x pi) sinc(x pi)
** which generates the positional basis that Norm uses.
** then we know that e ^ (i theta) = cos(theta) + i sin(theta)
** so we get e ^ (i theta)  sinc(theta) = sinc(theta) * (cos(theta) + i sin(theta))
*/

function make_table() {
  var ndiv = 16;
  document.write("function c(r,i) { return cpx(r,i); }<br/>\n");
  document.write("var a = [<br/>\n");
  for (var m = -30; m < 30; m += 1) {
	if (m > -30)
	  document.write(",<br/>\n");
	document.write("["+m);
	for (var i = 0; i < ndiv; i += 1) {
	  var p = Phi_at(i/ndiv,m);
	  if (Math.abs(p.r) < 0.001) p.r = 0;
	  if (Math.abs(p.i) < 0.001) p.i = 0;
	  document.write(",c("+p.r+","+p.i+")");
	}
	document.write("]");
  }
  document.write("];<br/>\n");
}

function set_attr(node, attr) {
  for (var i in attr)
	node.setAttribute(i, ""+attr[i]);
  return node;
}
